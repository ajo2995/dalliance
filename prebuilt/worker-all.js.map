{"version":3,"sources":["node_modules/browser-pack/_prelude.js","js/bam.js","worker-all.js","js/bigwig.js","js/bin.js","js/color.js","js/cram.js","js/das.js","js/encode.js","js/fetchworker.js","js/lh3utils.js","js/sha1.js","js/spans.js","js/utils.js","node_modules/es6-promise/dist/commonjs/main.js","node_modules/es6-promise/dist/commonjs/promise/all.js","node_modules/es6-promise/dist/commonjs/promise/asap.js","node_modules/es6-promise/dist/commonjs/promise/cast.js","node_modules/es6-promise/dist/commonjs/promise/config.js","node_modules/es6-promise/dist/commonjs/promise/polyfill.js","node_modules/es6-promise/dist/commonjs/promise/promise.js","node_modules/es6-promise/dist/commonjs/promise/race.js","node_modules/es6-promise/dist/commonjs/promise/reject.js","node_modules/es6-promise/dist/commonjs/promise/resolve.js","node_modules/es6-promise/dist/commonjs/promise/utils.js","node_modules/jszlib/js/inflate.js","node_modules/process/browser.js"],"names":["e","t","n","r","s","o","u","a","require","i","f","Error","code","l","exports","call","length","1","module","BamFile","_getBaiRefLength","uncba","offset","p","nbin","readInt","b","nchnk","nintv","minBlockIndex","q","v","readVob","bi","block","makeBam","data","bai","indexChunks","callback","attempted","slice","fetch","header","makeBam2","timeout","parseBamHeader","unc","unbgzf","byteLength","Uint8Array","magic","BAM_MAGIC","toString","headLen","String","fromCharCode","nRef","bam","chrToIndex","indexToChr","lName","name","j","indexOf","substring","push","indices","parseBai","baiMagic","BAI_MAGIC","nref","ref","blockStart","Math","min","chunks","result","url","replace","RegExp","BamRecord","spans","bin","Range","union","intersection","readShort","readByte","readFloat","readInt64","lh3utils","reg2bins","Chunk","BamFlags","MULTIPLE_SEGMENTS","ALL_SEGMENTS_ALIGN","SEGMENT_UNMAPPED","NEXT_SEGMENT_UNMAPPED","REVERSE_COMPLEMENT","NEXT_REVERSE_COMPLEMENT","FIRST_SEGMENT","LAST_SEGMENT","SECONDARY_ALIGNMENT","QC_FAIL","DUPLICATE","SUPPLEMENTARY","prototype","blocksForRange","refId","max","index","this","intBinsL","intBins","leafChunks","otherChunks","c","cs","ce","lowest","minLin","maxLin","lb","prunedOtherChunks","chnk","maxv","intChunks","sort","c0","c1","dif","minv","mergedChunks","cur","nc","chr","opts","tramp","records","ba","finished","thisB","readBamRecords","chrId","fetchMin","fetchMax","undefined","start_stop","buffer","bind","SEQRET_DECODER","CIGAR_DECODER","sink","blockSize","blockEnd","record","refID","pos","bmn","mq","nl","flag_nc","flag","lseq","nextRef","nextPos","segment","light","seqLength","includeName","readName","nextSegment","cigar","cigop","seq","seqBytes","sb","qseq","quals","value","tag","type","cc","elen","reader","atype","alen","./bin","./lh3utils","./spans","2","bwg_readOffset","M1","M2","M3","M4","BigWig","BigWigView","bwg","cirTreeOffset","cirTreeLength","isSummary","makeBwg","salted","sa","Int16Array","la","Int32Array","BIG_WIG_MAGIC","BIG_BED_MAGIC","BIG_WIG_MAGIC_BE","BIG_BED_MAGIC_BE","version","numZoomLevels","chromTreeOffset","unzoomedDataOffset","unzoomedIndexOffset","fieldCount","definedFieldCount","asOffset","totalSummaryOffset","uncompressBufSize","extHeaderOffset","zoomLevels","zl","zlReduction","zlData","zlIndex","reduction","dataOffset","indexOffset","readChromTree","getAutoSQL","as","schema","BBIExtraIndex","bbi","field","das","DASFeature","DASGroup","utils","shallowCopy","jszlib","jszlib_inflate_buffer","inflateBuffer","arrayCopy","BIG_WIG_TYPE_GRAPH","BIG_WIG_TYPE_VSTEP","BIG_WIG_TYPE_FSTEP","BED_COLOR_REGEXP","chromsToIDs","idsToChroms","maxID","udo","eb","bpt","keySize","rootNodeOffset","bptReadNode","nodeType","cnt","childOffset","key","ki","charCode","chromId","substr","readWigData","chrName","readWigDataById","cirHeader","cirBlockSize","blocksToFetch","outstanding","filter","Date","now","fmin","fmax","toks","cirFobRecur","level","instrument","console","log","cachedCirRoot","cirFobRecur2","fetchFeatures","maxCirBlockSpan","blockSpan","fetchRanges","ranges","fr","cirFobStartFetch","attempts","resultBuffer","contains","cirBlockData","isLeaf","lo","startChrom","startBase","endChrom","endBase","blockOffset","size","recurOffsets","b0","b1","features","createFeature","_chromId","k","parseFeatures","splice","fetchStart","fetchSize","fb","tmp","fa","Float32Array","itemCount","start","end","validCnt","maxVal","sumData","summaryOpts","score","maxScore","itemStep","itemSpan","blockType","dfc","rest","ch","bedColumns","featureOpts","split","label","parseInt","isNaN","orientation","color","test","itemRgb","col","fields","thickStart","thickEnd","blockCount","blockSizes","blockStarts","exonFrames","grp","id","notes","groups","geneId","geneName","geneName2","gg","spanList","bmin","bmax","span","tsList","ts","codingRegion","tl","tlList","readingFrame","tlOffset","readframe","brf","readframeExplicit","getFirstAdjacent","dir","getFirstAdjacentById","blockToFetch","bestBlockChr","bestBlockOffset","chrx","bestFeature","bestChr","bestPos","fi","exec","bestRecur","getUnzoomedView","unzoomedView","cirLen","nzl","getZoomedView","z","zh","view","_tsFetch","zoom","topLevelReductionCache","feats","thresholdSearch","referencePoint","threshold","fbThresholdSearchRecur","candidates","c2","d","chrOrd","candidate","rp","fromRef","initialChr","header_re","field_re","headerMatch","declType","comment","m","getExtraIndices","extraIndexCount","extraIndexListOffset","eil","ii","eiType","eiFieldCount","eiOffset","eiField","lookup","nodeOffset","valSize","node","Uint16Array","Uint32Array","lastChildOffset","localeCompare","./das","./utils","3","BlobFetchable","blob","URLFetchable","_typeof","bstringToBuffer","charCodeAt","buf","readIntBE","Symbol","iterator","obj","constructor","sha1","b64_sha1","Promise","webkitSlice","FileReader","onloadend","ev","readAsBinaryString","FileReaderSync","res","readAsArrayBuffer","ns","ne","seed","isSafari","navigator","userAgent","fetchAsText","getURL","then","req","XMLHttpRequest","salt","open","setRequestHeader","onreadystatechange","readyState","status","responseText","credentials","withCredentials","send","err","resolver","urlOrObj","resolve","attempt","truncatedLength","setTimeout","abort","overrideMimeType","responseType","clearTimeout","response","bl","mozResponseArrayBuffer","convertBuffer","ArrayBuffer","./sha1","es6-promise","4","DColour","red","green","blue","hex2","x","y","dasColourForName","palette","match","COLOR_RE","CSS_COLOR_RE","black","makeColourSteps","steps","stops","colours","dcolours","ci","grad","STEP_LOOP","si","rs","frac","ca","cb","fill","toSvgString","makeGradient","color1","color2","color3","toHexString","yellow","white","gray","grey","lightskyblue","lightsalmon","hotpink","5","CramFile","_getCraiRefLength","makeCram","crai","makeCram2","parseCramHeader","CRAM_MAGIC","cram","parseCrai","craiMagic","CRAI_MAGIC","resultBB","CramRecord","CramFlags","readCramRecords","6","DASSegment","description","DASSource","a1","a2","options","uri","coords","props","dasBaseURI","DASCoords","coordsMatch","taxon","auth","DASSequence","alpha","alphabet","DASLink","desc","DASAlignment","objects","blocks","DASStylesheet","styles","DASStyle","parseGradient","getAttribute","colors","se","getElementsByTagName","stop","firstChild","nodeValue","DASRegistry","elementValue","element","children","childNodes","ni","childElementOf","hasChildNodes","child","Node","ELEMENT_NODE","nextSibling","dasLinksOf","links","Array","maybeLinkChilden","linkXML","parentNode","dasNotesOf","maybeNotes","doCrossDomainRequest","handler","custAuth","window","XDomainRequest","onload","dom","ActiveXObject","async","loadXML","ontimeout","responseXML","isDasBooleanTrue","toLowerCase","isDasBooleanNotFalse","copyStylesheet","ss","nss","sh","_methodRE","_labelRE","_typeRE","style","_gradient","pusho","isBounded","toDASQuery","getURI","entryPoints","dasURI","segs","segMin","segMax","seg","segId","segSize","segDesc","sequence","seqs","segAlpha","segSeq","rawSeq","idx","space","toUpperCase","features_uri","filters","group","g","gi","adjacent","adj","ai","ti","maxbins","join","msg","segmentMap","segmentXML","segmentID","featureXMLs","feature","dasFeature","spos","epos","tec","te","typeId","typeCv","method","ori","groupXML","dasGroup","pec","parts","pi","parents","alignments","aliXMLs","aliXML","ali","objXMLs","oi","objXML","accession","dbSource","dbVersion","blockXMLs","blockXML","order","segments","segXMLs","segXML","object","strand","pushStyle","styleHolder","stylesheet","successCB","failureCB","creds","stylesheet_uri","typeXMLs","typeStyle","glyphXMLs","glyphXML","glyph","localName","sources","failure","quri","sourceXMLs","sourceXML","versionXMLs","versionXML","coordXMLs","coordXML","coord","caps","capXMLs","capXML","fep","propXMLs","source","source_uri","capabilities","errHandler","xUser","btoa","xPass","./color","7","lookupEncodeURI","json","accept","reject","resp","JSON","parse","location","EncodeURLHolder","rawurl","EncodeFetchable","getURLPromise","urlPromise","urlPromiseValidity","self","8","global","BAMWorkerFetcher","BBIWorkerFetcher","proxyResolver","lid","newID","resolveResolvers","postMessage","cmd","bigwig","encode","connections","idSeed","onmessage","event","command","bamF","baiF","indexBlob","indexUri","bamObj","error","cramF","craiF","cramObj","CRAMWorkerFetcher","transport","textXHR","con","connection","leap","quantLeap","under","meta","search","query","rr","time","scales","ei","extraIndices","map","is","./bam","./bigwig","./cram","./encode","9","Vob","allowZero","bint","lim","oBlockList","ptr","totalSize","xlen","out","cursor","reg2bin","beg","list","10","hex_sha1","rstr2hex","rstr_sha1","str2rstr_utf8","rstr2b64","binb2rstr","binb_sha1","rstr2binb","input","hex_tab","hexcase","output","charAt","tab","len","triplet","b64pad","w","olda","oldb","oldc","oldd","olde","bit_rol","safe_add","sha1_ft","sha1_kt","lsw","msw","num","11","_min","_max","_Compound","sorted","_rangeOrder","merged","current","shift","forEach","range","_ranges","s0","s1","insertRange","r0","r1","l0","l1","i0","i1","or","lapMin","lapMax","coverage","tot","rl","ri","rangeOrder","isContiguous","_pushRanges","lower_bound","floor","ub","rangeOver","12","pushnew","pushnewo","pick","arrayIndexOf","arrayRemove","makeElement","attribs","ele","document","createElement","createTextNode","appendChild","makeElementNS","namespace","createElementNS","setAttrs","setAttr","attr","attr_name_cache","_attr","lcc","setAttribute","removeChildren","removeChild","miniJSONify","exc","Observed","listeners","Awaited","queue","saltURL","__dalliance_saltSeed","relativeURL","base","rel","li","lastIndexOf","resolveUrlToPage","href","addListener","addListenerAndFire","removeListener","get","set","provide","await","AMINO_ACID_TRANSLATION","TTT","TTC","TTA","TTG","CTT","CTC","CTA","CTG","ATT","ATC","ATA","ATG","GTT","GTC","GTA","GTG","TCT","TCC","TCA","TCG","CCT","CCC","CCA","CCG","ACT","ACC","ACA","ACG","GCT","GCC","GCA","GCG","TAT","TAC","TAA","TAG","CAT","CAC","CAA","CAG","AAT","AAC","AAA","AAG","GAT","GAC","GAA","GAG","TGT","TGC","TGA","TGG","CGT","CGC","CGA","CGG","AGT","AGC","AGA","AGG","GGT","GGC","GGA","GGG","trim","13","polyfill","./promise/polyfill","./promise/promise","14","all","promises","isArray","TypeError","resolveAll","results","remaining","promise","isFunction","15","process","useNextTick","nextTick","flush","useMutationObserver","iterations","observer","BrowserMutationObserver","observe","characterData","useSetTimeout","local","tuple","arg","asap","scheduleFlush","browserGlobal","MutationObserver","WebKitMutationObserver","_process","16","cast","17","configure","arguments","config","18","es6PromiseSupport","RSVPPromise","./promise","19","_subscribers","invokeResolver","resolvePromise","rejectPromise","reason","invokeCallback","settled","detail","succeeded","failed","hasCallback","handleThenable","FULFILLED","REJECTED","subscribe","parent","onFulfillment","onRejection","subscribers","publish","_detail","resolved","objectOrFunction","val","fulfill","_state","PENDING","SEALED","publishFulfillment","publishRejection","race","staticResolve","staticReject","thenPromise","callbacks","catch","./all","./asap","./cast","./config","./race","./reject","./resolve","20","21","22","23","Object","getTime","24","ZStream","Inflate","was","InfBlocks","checkfn","hufts","MANY","mode","IB_TYPE","reset","left","table","blens","bb","tb","codes","InfCodes","last","bitk","bitb","read","write","check","inftree","InfTree","inflate_trees_fixed","bd","td","fixed_bl","fixed_bd","fixed_tl","fixed_td","Z_OK","src","srcOffset","dest","destOffset","count","arrayCopy_fast","hasSubarray","subarray","BYTES_PER_ELEMENT","byteOffset","arrayCopy_slow","afterUncOffset","inflateInit","DEF_WBITS","next_in","next_in_index","avail_in","obuf","next_out","next_out_index","avail_out","inflate","Z_NO_FLUSH","Z_STREAM_END","Z_BUF_ERROR","newob","MAX_WBITS","BMAX","PRESET_DICT","Z_FINISH","Z_DEFLATED","Z_NEED_DICT","Z_STREAM_ERROR","Z_DATA_ERROR","Z_MEM_ERROR","METHOD","FLAG","DICT4","DICT3","DICT2","DICT1","DICT0","BLOCKS","CHECK4","CHECK3","CHECK2","CHECK1","DONE","BAD","inflate_mask","IB_LENS","IB_STORED","IB_TABLE","IB_BTREE","IB_DTREE","IB_CODES","IB_DRY","IB_DONE","IB_BAD","cplens","cplext","cpdist","cpdext","nowrap","istate","inflateEnd","ret","inflateSync","inflateSetDictionary","dictionary","dictLength","inflateReset","total_in","total_out","free","wbits","marker","need","adler","proc","_adler","adler32","set_dictionary","mark","inflateSyncPoint","sync_point","INFBLOCKS_BORDER","inflate_flush","init","inflate_trees_bits","inflate_trees_dynamic","IC_START","IC_LEN","IC_LENEXT","IC_DIST","IC_DISTEXT","IC_COPY","IC_LIT","IC_WASH","IC_END","IC_BADCODE","tl_index","td_index","lbits","dbits","ltree","ltree_index","dtree","dtree_index","tree","tindex","inflate_fast","tree_index","lit","dist","tp","tp_index","ml","md","tp_index_t_3","huft_build","bindex","hp","hn","h","mask","xp","initWorkArea","nd","vsize","testArray","25","defaultSetTimout","defaultClearTimeout","runTimeout","fun","cachedSetTimeout","runClearTimeout","cachedClearTimeout","cleanUpNextTick","draining","currentQueue","concat","queueIndex","drainQueue","run","Item","array","noop","args","apply","title","browser","env","argv","versions","on","once","off","removeAllListeners","emit","binding","cwd","chdir","umask"],"mappings":"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,GAAA,EAAA,IACA,GAAA,EAAA,GAAA,EAAA,EAAA,IAAA,EAAA,EAAA,GAAA,EAAA,EAAA,IACA,GAAA,EAAA,GAAA,EAAA,EAAA,IAAA,EAAA,EAAA,GAAA,EAAA,EAAA,IACA,EAAA,EAAA,EAAA,EAAA,EAAA,IAAA,EAAA,EAAA,GAAA,EAAA,EAAA,IACA,GAAA,EAAA,EAAA,EAAA,EAAA,GAAA,EAAA,EAAA,GAAA,EAAA,EAAA,IACA,GAAA,EAAA,GAAA,EAAA,EAAA,IAAA,EAAA,EAAA,GAAA,EAAA,EAAA,IACA,GAAA,EAAA,GAAA,EAAA,EAAA,IAAA,EAAA,EAAA,GAAA,EAAA,EAAA,IACA,EAAA,EAAA,GAAA,EAAA,EAAA,IAAA,EAAA,EAAA,GAAA,EAAA,EAAA,IACA,GAAA,EAAA,EAAA,EAAA,EAAA,GAAA,EAAA,EAAA,GAAA,GAAA,EAAA,IACA,GAAA,EAAA,GAAA,EAAA,EAAA,IAAA,EAAA,EAAA,GAAA,EAAA,EAAA,IACA,GAAA,EAAA,GAAA,EAAA,EAAA,GAAA,EAAA,EAAA,GAAA,EAAA,EAAA,IACA,EAAA,EAAA,EAAA,EAAA,EAAA,IAAA,EAAA,EAAA,GAAA,EAAA,EAAA,IACA,GAAA,EAAA,EAAA,EAAA,EAAA,GAAA,EAAA,EAAA,GAAA,EAAA,EAAA,IACA,GAAA,EAAA,GAAA,EAAA,EAAA,IAAA,EAAA,EAAA,GAAA,EAAA,EAAA,IACA,GAAA,EAAA,GAAA,EAAA,EAAA,IAAA,EAAA,EAAA,GAAA,EAAA,EAAA,IACA,EAAA,EAAA,GAAA,EAAA,EAAA,IAAA,EAAA,EAAA,GAAA,EAAA,EAAA,IACA,GAAA,EAAA,EAAA,EAAA,EAAA,GAAA,EAAA,EAAA,GAAA,IAAA,EAAA,EACA,GAAA,EAAA,GAAA,EAAA,EAAA,IAAA,EAAA,EAAA,GAAA,EAAA,EAAA,IACA,GAAA,EAAA,GAAA,EAAA,EAAA,IAAA,EAAA,EAAA,GAAA,EAAA,EAAA,IACA,EAAA,EAAA,EAAA,EAAA,EAAA,IAAA,EAAA,EAAA,GAAA,EAAA,EAAA,IACA,GAAA,EAAA,EAAA,EAAA,EAAA,GAAA,EAAA,EAAA,GAAA,EAAA,EAAA,IACA,GAAA,EAAA,GAAA,EAAA,EAAA,IAAA,EAAA,EAAA,GAAA,EAAA,EAAA,IACA,GAAA,EAAA,GAAA,EAAA,EAAA,IAAA,EAAA,EAAA,GAAA,EAAA,EAAA,IACA,EAAA,EAAA,GAAA,EAAA,EAAA,IAAA,EAAA,EAAA,GAAA,EAAA,EAAA,IACA,GAAA,EAAA,IAAA,EAAA,EAAA,GAAA,EAAA,EAAA,GAAA,GAAA,EAAA,IACA,GAAA,EAAA,GAAA,EAAA,EAAA,IAAA,EAAA,EAAA,GAAA,EAAA,EAAA,IACA,GAAA,EAAA,GAAA,EAAA,EAAA,GAAA,EAAA,EAAA,GAAA,EAAA,EAAA,IACA,EAAA,EAAA,EAAA,EAAA,EAAA,IAAA,EAAA,EAAA,GAAA,EAAA,EAAA,IACA,GAAA,EAAA,EAAA,EAAA,EAAA,GAAA,EAAA,EAAA,GAAA,EAAA,EAAA,IACA,GAAA,EAAA,GAAA,EAAA,EAAA,IAAA,EAAA,EAAA,GAAA,EAAA,EAAA,IACA,GAAA,EAAA,GAAA,EAAA,EAAA,IAAA,EAAA,EAAA,GAAA,EAAA,EAAA,IACA,EAAA,EAAA,EAAA,EAAA,EAAA,IAAA,EAAA,EAAA,GAAA,EAAA,EAAA,IACA,GAAA,EAAA,EAAA,EAAA,EAAA,GAAA,EAAA,EAAA,GAAA,GAAA,EAAA,IACA,GAAA,EAAA,GAAA,EAAA,EAAA,IAAA,EAAA,EAAA,GAAA,EAAA,EAAA,IACA,GAAA,EAAA,GAAA,EAAA,EAAA,IAAA,EAAA,EAAA,GAAA,EAAA,EAAA,IACA,EAAA,EAAA,EAAA,EAAA,EAAA,IAAA,EAAA,EAAA,GAAA,EAAA,EAAA,IACA,GAAA,EAAA,EAAA,EAAA,EAAA,GAAA,EAAA,EAAA,GAAA,EAAA,EAAA,IACA,GAAA,EAAA,GAAA,EAAA,EAAA,IAAA,EAAA,EAAA,GAAA,EAAA,EAAA,IACA,GAAA,EAAA,GAAA,EAAA,EAAA,IAAA,EAAA,EAAA,GAAA,EAAA,EAAA,IACA,EAAA,EAAA,GAAA,EAAA,EAAA,IAAA,EAAA,EAAA,GAAA,EAAA,EAAA,IACA,GAAA,EAAA,EAAA,EAAA,EAAA,GAAA,EAAA,EAAA,GAAA,GAAA,EAAA,IACA,GAAA,EAAA,GAAA,EAAA,EAAA,IAAA,EAAA,EAAA,GAAA,EAAA,EAAA,IACA,GAAA,EAAA,GAAA,EAAA,EAAA,GAAA,EAAA,EAAA,GAAA,EAAA,EAAA,IACA,EAAA,EAAA,EAAA,EAAA,EAAA,IAAA,EAAA,EAAA,GAAA,EAAA,EAAA,IACA,GAAA,EAAA,EAAA,EAAA,EAAA,GAAA,EAAA,EAAA,GAAA,EAAA,EAAA,IACA,GAAA,EAAA,GAAA,EAAA,EAAA,IAAA,EAAA,EAAA,GAAA,EAAA,EAAA,IACA,GAAA,EAAA,GAAA,EAAA,EAAA,IAAA,EAAA,EAAA,GAAA,EAAA,EAAA,IACA,EAAA,EAAA,GAAA,EAAA,EAAA,IAAA,EAAA,EAAA,GAAA,EAAA,EAAA,IACA,GAAA,EAAA,EAAA,EAAA,EAAA,GAAA,EAAA,EAAA,GAAA,IAAA,EAAA,EACA,GAAA,EAAA,GAAA,EAAA,EAAA,IAAA,EAAA,EAAA,GAAA,EAAA,EAAA,IACA,GAAA,EAAA,GAAA,EAAA,EAAA,IAAA,EAAA,EAAA,GAAA,EAAA,EAAA,IACA,EAAA,EAAA,EAAA,EAAA,EAAA,IAAA,EAAA,EAAA,GAAA,EAAA,EAAA,IACA,GAAA,EAAA,EAAA,EAAA,EAAA,GAAA,EAAA,EAAA,GAAA,EAAA,EAAA,IACA,GAAA,EAAA,GAAA,EAAA,EAAA,IAAA,EAAA,EAAA,GAAA,EAAA,EAAA,IACA,GAAA,EAAA,GAAA,EAAA,EAAA,IAAA,EAAA,EAAA,GAAA,EAAA,EAAA,IACA,EAAA,EAAA,GAAA,EAAA,EAAA,IAAA,EAAA,EAAA,GAAA,EAAA,EAAA,IACA,GAAA,EAAA,IAAA,EAAA,EAAA,GAAA,EAAA,EAAA,GAAA,GAAA,EAAA,IACA,GAAA,EAAA,GAAA,EAAA,EAAA,IAAA,EAAA,EAAA,GAAA,EAAA,EAAA,IAEA,GAAA,EAAA,GAAA,EAAA,EAAA,GAAA,EAAA,EAAA,GAAA,EAAA,EAAA,IACA,EAAA,EAAA,EAAA,EAAA,EAAA,IAAA,EAAA,EAAA,GAAA,EAAA,EAAA,IACA,GAAA,EAAA,EAAA,EAAA,EAAA,GAAA,EAAA,EAAA,GAAA,EAAA,EAAA,IACA,GAAA,EAAA,GAAA,EAAA,EAAA,IAAA,EAAA,EAAA,GAAA,EAAA,EAAA,IACA,GAAA,EAAA,GAAA,EAAA,EAAA,IAAA,EAAA,EAAA,GAAA,EAAA,EAAA,IACA,EAAA,EAAA,EAAA,EAAA,EAAA,IAAA,EAAA,EAAA,GAAA,EAAA,EAAA,IACA,GAAA,EAAA,EAAA,EAAA,EAAA,GAAA,EAAA,EAAA,GAAA,GAAA,EAAA,IACA,GAAA,EAAA,GAAA,EAAA,EAAA,IAAA,EAAA,EAAA,GAAA,EAAA,EAAA,IACA,GAAA,EAAA,GAAA,EAAA,EAAA,IAAA,EAAA,EAAA,GAAA,EAAA,EAAA,IACA,EAAA,EAAA,EAAA,EAAA,EAAA,IAAA,EAAA,EAAA,GAAA,EAAA,EAAA,IACA,GAAA,EAAA,EAAA,EAAA,EAAA,GAAA,EAAA,EAAA,GAAA,EAAA,EAAA,IACA,GAAA,EAAA,GAAA,EAAA,EAAA,IAAA,EAAA,EAAA,GAAA,EAAA,EAAA,IACA,GAAA,EAAA,GAAA,EAAA,EAAA,IAAA,EAAA,EAAA,GAAA,EAAA,EAAA,IACA,EAAA,EAAA,GAAA,EAAA,EAAA,IAAA,EAAA,EAAA,GAAA,EAAA,EAAA,IACA,GAAA,EAAA,EAAA,EAAA,EAAA,GAAA,EAAA,EAAA,GAAA,GAAA,EAAA,IACA,GAAA,EAAA,GAAA,EAAA,EAAA,IAAA,EAAA,EAAA,GAAA,EAAA,EAAA,IACA,GAAA,EAAA,GAAA,EAAA,EAAA,GAAA,EAAA,EAAA,GAAA,EAAA,EAAA,IACA,EAAA,EAAA,EAAA,EAAA,EAAA,IAAA,EAAA,EAAA,GAAA,EAAA,EAAA,IACA,GAAA,EAAA,EAAA,EAAA,EAAA,GAAA,EAAA,EAAA,GAAA,EAAA,EAAA,IACA,GAAA,EAAA,GAAA,EAAA,EAAA,IAAA,EAAA,EAAA,GAAA,EAAA,EAAA,IACA,GAAA,EAAA,GAAA,EAAA,EAAA,IAAA,EAAA,EAAA,GAAA,EAAA,EAAA,IACA,EAAA,EAAA,GAAA,EAAA,EAAA,IAAA,EAAA,EAAA,GAAA,EAAA,EAAA,IACA,GAAA,EAAA,EAAA,EAAA,EAAA,GAAA,EAAA,EAAA,GAAA,IAAA,EAAA,EACA,GAAA,EAAA,GAAA,EAAA,EAAA,IAAA,EAAA,EAAA,GAAA,EAAA,EAAA,IACA,GAAA,EAAA,GAAA,EAAA,EAAA,IAAA,EAAA,EAAA,GAAA,EAAA,EAAA,IACA,EAAA,EAAA,EAAA,EAAA,EAAA,IAAA,EAAA,EAAA,GAAA,EAAA,EAAA,IACA,GAAA,EAAA,EAAA,EAAA,EAAA,GAAA,EAAA,EAAA,GAAA,EAAA,EAAA,IACA,GAAA,EAAA,GAAA,EAAA,EAAA,IAAA,EAAA,EAAA,GAAA,EAAA,EAAA,IACA,GAAA,EAAA,GAAA,EAAA,EAAA,IAAA,EAAA,EAAA,GAAA,EAAA,EAAA,IACA,EAAA,EAAA,GAAA,EAAA,EAAA,IAAA,EAAA,EAAA,GAAA,EAAA,EAAA,IACA,GAAA,EAAA,IAAA,EAAA,EAAA,GAAA,EAAA,EAAA,GAAA,GAAA,EAAA,IACA,GAAA,EAAA,GAAA,EAAA,EAAA,IAAA,EAAA,EAAA,GAAA,EAAA,EAAA,IACA,GAAA,EAAA,GAAA,EAAA,EAAA,GAAA,EAAA,EAAA,GAAA,EAAA,EAAA,IACA,EAAA,EAAA,EAAA,EAAA,EAAA,IAAA,EAAA,EAAA,GAAA,EAAA,EAAA,IACA,GAAA,EAAA,EAAA,EAAA,EAAA,GAAA,EAAA,EAAA,GAAA,EAAA,EAAA,IACA,GAAA,EAAA,GAAA,EAAA,EAAA,IAAA,EAAA,EAAA,GAAA,EAAA,EAAA,IACA,GAAA,EAAA,GAAA,EAAA,EAAA,IAAA,EAAA,EAAA,GAAA,EAAA,EAAA,IACA,EAAA,EAAA,EAAA,EAAA,EAAA,IAAA,EAAA,EAAA,GAAA,EAAA,EAAA,IACA,GAAA,EAAA,EAAA,EAAA,EAAA,GAAA,EAAA,EAAA,GAAA,GAAA,EAAA,IACA,GAAA,EAAA,GAAA,EAAA,EAAA,IAAA,EAAA,EAAA,GAAA,EAAA,EAAA,IACA,GAAA,EAAA,GAAA,EAAA,EAAA,IAAA,EAAA,EAAA,GAAA,EAAA,EAAA,IACA,EAAA,EAAA,EAAA,EAAA,EAAA,IAAA,EAAA,EAAA,GAAA,EAAA,EAAA,IACA,GAAA,EAAA,EAAA,EAAA,EAAA,GAAA,EAAA,EAAA,GAAA,EAAA,EAAA,IACA,GAAA,EAAA,GAAA,EAAA,EAAA,IAAA,EAAA,EAAA,GAAA,EAAA,EAAA,IACA,GAAA,EAAA,GAAA,EAAA,EAAA,IAAA,EAAA,EAAA,GAAA,EAAA,EAAA,IACA,EAAA,EAAA,GAAA,EAAA,EAAA,IAAA,EAAA,EAAA,GAAA,EAAA,EAAA,IACA,GAAA,EAAA,EAAA,EAAA,EAAA,GAAA,EAAA,EAAA,GAAA,GAAA,EAAA,IACA,GAAA,EAAA,GAAA,EAAA,EAAA,IAAA,EAAA,EAAA,GAAA,EAAA,EAAA,IACA,GAAA,EAAA,GAAA,EAAA,EAAA,GAAA,EAAA,EAAA,GAAA,EAAA,EAAA,IACA,EAAA,EAAA,EAAA,EAAA,EAAA,IAAA,EAAA,EAAA,GAAA,EAAA,EAAA,IACA,GAAA,EAAA,EAAA,EAAA,EAAA,GAAA,EAAA,EAAA,GAAA,EAAA,EAAA,IACA,GAAA,EAAA,GAAA,EAAA,EAAA,IAAA,EAAA,EAAA,GAAA,EAAA,EAAA,IACA,GAAA,EAAA,GAAA,EAAA,EAAA,IAAA,EAAA,EAAA,GAAA,EAAA,EAAA,IACA,EAAA,EAAA,GAAA,EAAA,EAAA,IAAA,EAAA,EAAA,GAAA,EAAA,EAAA,IACA,GAAA,EAAA,EAAA,EAAA,EAAA,GAAA,EAAA,EAAA,GAAA,IAAA,EAAA,EACA,GAAA,EAAA,GAAA,EAAA,EAAA,IAAA,EAAA,EAAA,GAAA,EAAA,EAAA,IACA,GAAA,EAAA,GAAA,EAAA,EAAA,IAAA,EAAA,EAAA,GAAA,EAAA,EAAA,IACA,EAAA,EAAA,EAAA,EAAA,EAAA,IAAA,EAAA,EAAA,GAAA,EAAA,EAAA,IACA,GAAA,EAAA,EAAA,EAAA,EAAA,GAAA,EAAA,EAAA,GAAA,EAAA,EAAA,IACA,GAAA,EAAA,GAAA,EAAA,EAAA,IAAA,EAAA,EAAA,GAAA,EAAA,EAAA,IACA,GAAA,EAAA,GAAA,EAAA,EAAA,IAAA,EAAA,EAAA,GAAA,EAAA,EAAA,IACA,EAAA,EAAA,GAAA,EAAA,EAAA,IAAA,EAAA,EAAA,GAAA,EAAA,EAAA,KAEAC,IACA,GAAA,EAAA,EAAA,GAAA,EAAA,IAAA,GAAA,EAA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","file":"worker-all.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","/* -*- mode: javascript; c-basic-offset: 4; indent-tabs-mode: nil -*- */\n\n// \n// Dalliance Genome Explorer\n// (c) Thomas Down 2006-2011\n//\n// bam.js: indexed binary alignments\n//\n\n\"use strict\";\n\nif (typeof(require) !== 'undefined') {\n    var spans = require('./spans');\n    var Range = spans.Range;\n    var union = spans.union;\n    var intersection = spans.intersection;\n\n    var bin = require('./bin');\n    var readInt = bin.readInt;\n    var readShort = bin.readShort;\n    var readByte = bin.readByte;\n    var readInt64 = bin.readInt64;\n    var readFloat = bin.readFloat;\n\n    var lh3utils = require('./lh3utils');\n    var readVob = lh3utils.readVob;\n    var unbgzf = lh3utils.unbgzf;\n    var reg2bins = lh3utils.reg2bins;\n    var Chunk = lh3utils.Chunk;\n}\n\n\nvar BAM_MAGIC = 0x14d4142;\nvar BAI_MAGIC = 0x1494142;\n\nvar BamFlags = {\n    MULTIPLE_SEGMENTS:       0x1,\n    ALL_SEGMENTS_ALIGN:      0x2,\n    SEGMENT_UNMAPPED:        0x4,\n    NEXT_SEGMENT_UNMAPPED:   0x8,\n    REVERSE_COMPLEMENT:      0x10,\n    NEXT_REVERSE_COMPLEMENT: 0x20,\n    FIRST_SEGMENT:           0x40,\n    LAST_SEGMENT:            0x80,\n    SECONDARY_ALIGNMENT:     0x100,\n    QC_FAIL:                 0x200,\n    DUPLICATE:               0x400,\n    SUPPLEMENTARY:           0x800\n};\n\nfunction BamFile() {\n}\n\n\n// Calculate the length (in bytes) of the BAI ref starting at offset.\n// Returns {nbin, length, minBlockIndex}\nfunction _getBaiRefLength(uncba, offset) {\n    var p = offset;\n    var nbin = readInt(uncba, p); p += 4;\n    for (var b = 0; b < nbin; ++b) {\n        var bin = readInt(uncba, p);\n        var nchnk = readInt(uncba, p+4);\n        p += 8 + (nchnk * 16);\n    }\n    var nintv = readInt(uncba, p); p += 4;\n\n    var minBlockIndex = 1000000000;\n    var q = p;\n    for (var i = 0; i < nintv; ++i) {\n        var v = readVob(uncba, q); q += 8;\n        if (v) {\n            var bi = v.block;\n            if (v.offset > 0)\n                bi += 65536;\n\n            if (bi < minBlockIndex)\n                minBlockIndex = bi;\n            break;\n        }\n    }\n    p += (nintv * 8);\n\n    return {\n        minBlockIndex: minBlockIndex,\n        nbin: nbin,\n        length: p - offset\n    };\n}\n\n\nfunction makeBam(data, bai, indexChunks, callback, attempted) {\n    // Do an initial probe on the BAM file to catch any mixed-content errors.\n    data.slice(0, 10).fetch(function(header) {\n        if (header) {\n            return makeBam2(data, bai, indexChunks, callback, attempted);\n        } else {\n            return callback(null, \"Couldn't access BAM.\");\n        }\n    }, {timeout: 5000});\n}\n\nfunction makeBam2(data, bai, indexChunks, callback, attempted) {\n    var bam = new BamFile();\n    bam.data = data;\n    bam.bai = bai;\n    bam.indexChunks = indexChunks;\n\n    var minBlockIndex = bam.indexChunks ? bam.indexChunks.minBlockIndex : 1000000000;\n\n    // Fills out bam.chrToIndex and bam.indexToChr based on the first few bytes of the BAM.\n    function parseBamHeader(r) {\n        if (!r) {\n            return callback(null, \"Couldn't access BAM\");\n        }\n\n        var unc = unbgzf(r, r.byteLength);\n        var uncba = new Uint8Array(unc);\n\n        var magic = readInt(uncba, 0);\n        if (magic != BAM_MAGIC) {\n            return callback(null, \"Not a BAM file, magic=0x\" + magic.toString(16));\n        }\n        var headLen = readInt(uncba, 4);\n        var header = '';\n        for (var i = 0; i < headLen; ++i) {\n            header += String.fromCharCode(uncba[i + 8]);\n        }\n\n        var nRef = readInt(uncba, headLen + 8);\n        var p = headLen + 12;\n\n        bam.chrToIndex = {};\n        bam.indexToChr = [];\n        for (var i = 0; i < nRef; ++i) {\n            var lName = readInt(uncba, p);\n            var name = '';\n            for (var j = 0; j < lName-1; ++j) {\n                name += String.fromCharCode(uncba[p + 4 + j]);\n            }\n            var lRef = readInt(uncba, p + lName + 4);\n            bam.chrToIndex[name] = i;\n            if (name.indexOf('chr') == 0) {\n                bam.chrToIndex[name.substring(3)] = i;\n            } else {\n                bam.chrToIndex['chr' + name] = i;\n            }\n            bam.indexToChr.push(name);\n\n            p = p + 8 + lName;\n        }\n\n        if (bam.indices) {\n            return callback(bam);\n        }\n    }\n\n    function parseBai(header) {\n        if (!header) {\n            return \"Couldn't access BAI\";\n        }\n\n        var uncba = new Uint8Array(header);\n        var baiMagic = readInt(uncba, 0);\n        if (baiMagic != BAI_MAGIC) {\n            return callback(null, 'Not a BAI file, magic=0x' + baiMagic.toString(16));\n        }\n\n        var nref = readInt(uncba, 4);\n\n        bam.indices = [];\n\n        var p = 8;\n        for (var ref = 0; ref < nref; ++ref) {\n            var blockStart = p;\n            var o = _getBaiRefLength(uncba, blockStart);\n            p += o.length;\n\n            minBlockIndex = Math.min(o.minBlockIndex, minBlockIndex);\n\n            var nbin = o.nbin;\n\n            if (nbin > 0) {\n                bam.indices[ref] = new Uint8Array(header, blockStart, p - blockStart);\n            }\n        }\n\n        return true;\n    }\n\n    if (!bam.indexChunks) {\n        bam.bai.fetch(function(header) {   // Do we really need to fetch the whole thing? :-(\n            var result = parseBai(header);\n            if (result !== true) {\n                if (bam.bai.url && typeof(attempted) === \"undefined\") {\n                    // Already attempted x.bam.bai not there so now trying x.bai\n                    bam.bai.url = bam.data.url.replace(new RegExp('.bam$'), '.bai');\n                    \n                     // True lets us know we are making a second attempt\n                    makeBam2(data, bam.bai, indexChunks, callback, true);\n                }\n                else {\n                    // We've attempted x.bam.bai & x.bai and nothing worked\n                    callback(null, result);\n                }\n            } else {\n              bam.data.slice(0, minBlockIndex).fetch(parseBamHeader);\n            }\n        });   // Timeout on first request to catch Chrome mixed-content error.\n    } else {\n        var chunks = bam.indexChunks.chunks;\n        bam.indices = []\n        for (var i = 0; i < chunks.length; i++) {\n           bam.indices[i] = null;  // To be filled out lazily as needed\n        }\n        bam.data.slice(0, minBlockIndex).fetch(parseBamHeader);\n    }\n}\n\n\n\nBamFile.prototype.blocksForRange = function(refId, min, max) {\n    var index = this.indices[refId];\n    if (!index) {\n        return [];\n    }\n\n    var intBinsL = reg2bins(min, max);\n    var intBins = [];\n    for (var i = 0; i < intBinsL.length; ++i) {\n        intBins[intBinsL[i]] = true;\n    }\n    var leafChunks = [], otherChunks = [];\n\n    var nbin = readInt(index, 0);\n    var p = 4;\n    for (var b = 0; b < nbin; ++b) {\n        var bin = readInt(index, p);\n        var nchnk = readInt(index, p+4);\n//        dlog('bin=' + bin + '; nchnk=' + nchnk);\n        p += 8;\n        if (intBins[bin]) {\n            for (var c = 0; c < nchnk; ++c) {\n                var cs = readVob(index, p);\n                var ce = readVob(index, p + 8);\n                (bin < 4681 ? otherChunks : leafChunks).push(new Chunk(cs, ce));\n                p += 16;\n            }\n        } else {\n            p +=  (nchnk * 16);\n        }\n    }\n    // console.log('leafChunks = ' + JSON.stringify(leafChunks));\n    // console.log('otherChunks = ' + JSON.stringify(otherChunks));\n\n    var nintv = readInt(index, p);\n    // console.log('nintv=' + nintv);\n    var lowest = null;\n    var minLin = Math.min(min>>14, nintv - 1), maxLin = Math.min(max>>14, nintv - 1);\n    for (var i = minLin; i <= maxLin; ++i) {\n        var lb =  readVob(index, p + 4 + (i * 8));\n        if (!lb) {\n            continue;\n        }\n        if (!lowest || lb.block < lowest.block || (lb.block == lowest.block && lb.offset < lowest.offset)) {\n            lowest = lb;\n        }\n    }\n    // console.log('Lowest LB = ' + lowest);\n\n    var prunedOtherChunks = [];\n    if (lowest != null) {\n        for (var i = 0; i < otherChunks.length; ++i) {\n            var chnk = otherChunks[i];\n            if (chnk.maxv.block > lowest.block || (chnk.maxv.block == lowest.block && chnk.maxv.offset >= lowest.offset)) {\n                prunedOtherChunks.push(chnk);\n            }\n        }\n    }\n    // console.log('prunedOtherChunks = ' + JSON.stringify(prunedOtherChunks));\n    otherChunks = prunedOtherChunks;\n\n    var intChunks = [];\n    for (var i = 0; i < otherChunks.length; ++i) {\n        intChunks.push(otherChunks[i]);\n    }\n    for (var i = 0; i < leafChunks.length; ++i) {\n        intChunks.push(leafChunks[i]);\n    }\n\n    intChunks.sort(function(c0, c1) {\n        var dif = c0.minv.block - c1.minv.block;\n        if (dif != 0) {\n            return dif;\n        } else {\n            return c0.minv.offset - c1.minv.offset;\n        }\n    });\n    var mergedChunks = [];\n    if (intChunks.length > 0) {\n        var cur = intChunks[0];\n        for (var i = 1; i < intChunks.length; ++i) {\n            var nc = intChunks[i];\n            if (nc.minv.block == cur.maxv.block /* && nc.minv.offset == cur.maxv.offset */) { // no point splitting mid-block\n                cur = new Chunk(cur.minv, nc.maxv);\n            } else {\n                mergedChunks.push(cur);\n                cur = nc;\n            }\n        }\n        mergedChunks.push(cur);\n    }\n    // console.log('mergedChunks = ' + JSON.stringify(mergedChunks));\n\n    return mergedChunks;\n}\n\nBamFile.prototype.fetch = function(chr, min, max, callback, opts) {\n    var thisB = this;\n    opts = opts || {};\n\n    var chrId = this.chrToIndex[chr];\n    var chunks;\n    if (chrId === undefined) {\n        chunks = [];\n    } else {\n        // Fetch this portion of the BAI if it hasn't been loaded yet.\n        if (this.indices[chrId] === null && this.indexChunks.chunks[chrId]) {\n            var start_stop = this.indexChunks.chunks[chrId];\n            return this.bai.slice(start_stop[0], start_stop[1]).fetch(function(data) {\n                var buffer = new Uint8Array(data);\n                this.indices[chrId] = buffer;\n                return this.fetch(chr, min, max, callback, opts);\n            }.bind(this));\n        }\n\n        chunks = this.blocksForRange(chrId, min, max);\n        if (!chunks) {\n            callback(null, 'Error in index fetch');\n        }\n    }\n    \n    var records = [];\n    var index = 0;\n    var data;\n\n    function tramp() {\n        if (index >= chunks.length) {\n            return callback(records);\n        } else if (!data) {\n            var c = chunks[index];\n            var fetchMin = c.minv.block;\n            var fetchMax = c.maxv.block + (1<<16); // *sigh*\n            // console.log('fetching ' + fetchMin + ':' + fetchMax);\n            thisB.data.slice(fetchMin, fetchMax - fetchMin).fetch(function(r) {\n                data = unbgzf(r, c.maxv.block - c.minv.block + 1);\n                return tramp();\n            });\n        } else {\n            var ba = new Uint8Array(data);\n            var finished = thisB.readBamRecords(ba, chunks[index].minv.offset, records, min, max, chrId, opts);\n            data = null;\n            ++index;\n            if (finished)\n                return callback(records);\n            else\n                return tramp();\n        }\n    }\n    tramp();\n}\n\nvar SEQRET_DECODER = ['=', 'A', 'C', 'x', 'G', 'x', 'x', 'x', 'T', 'x', 'x', 'x', 'x', 'x', 'x', 'N'];\nvar CIGAR_DECODER = ['M', 'I', 'D', 'N', 'S', 'H', 'P', '=', 'X', '?', '?', '?', '?', '?', '?', '?'];\n\nfunction BamRecord() {\n}\n\nBamFile.prototype.readBamRecords = function(ba, offset, sink, min, max, chrId, opts) {\n    while (true) {\n        var blockSize = readInt(ba, offset);\n        var blockEnd = offset + blockSize + 4;\n        if (blockEnd > ba.length) {\n            return false;\n        }\n\n        var record = new BamRecord();\n\n        var refID = readInt(ba, offset + 4);\n        var pos = readInt(ba, offset + 8);\n        \n        var bmn = readInt(ba, offset + 12);\n        var bin = (bmn & 0xffff0000) >> 16;\n        var mq = (bmn & 0xff00) >> 8;\n        var nl = bmn & 0xff;\n\n        var flag_nc = readInt(ba, offset + 16);\n        var flag = (flag_nc & 0xffff0000) >> 16;\n        var nc = flag_nc & 0xffff;\n    \n        var lseq = readInt(ba, offset + 20);\n        \n        var nextRef  = readInt(ba, offset + 24);\n        var nextPos = readInt(ba, offset + 28);\n        \n        var tlen = readInt(ba, offset + 32);\n    \n        record.segment = this.indexToChr[refID];\n        record.flag = flag;\n        record.pos = pos;\n        record.mq = mq;\n        if (opts.light)\n            record.seqLength = lseq;\n\n        if (!opts.light || opts.includeName) {\n            var readName = '';\n            for (var j = 0; j < nl-1; ++j) {\n                readName += String.fromCharCode(ba[offset + 36 + j]);\n            }\n            record.readName = readName;\n        }\n        \n        if (!opts.light) {\n            if (nextRef >= 0) {\n                record.nextSegment = this.indexToChr[nextRef];\n                record.nextPos = nextPos;\n            }\n        \n            var p = offset + 36 + nl;\n\n            var cigar = '';\n            for (var c = 0; c < nc; ++c) {\n                var cigop = readInt(ba, p);\n                cigar = cigar + (cigop>>4) + CIGAR_DECODER[cigop & 0xf];\n                p += 4;\n            }\n            record.cigar = cigar;\n        \n            var seq = '';\n            var seqBytes = (lseq + 1) >> 1;\n            for (var j = 0; j < seqBytes; ++j) {\n                var sb = ba[p + j];\n                seq += SEQRET_DECODER[(sb & 0xf0) >> 4];\n                if (seq.length < lseq)\n                    seq += SEQRET_DECODER[(sb & 0x0f)];\n            }\n            p += seqBytes;\n            record.seq = seq;\n\n            var qseq = '';\n            for (var j = 0; j < lseq; ++j) {\n                qseq += String.fromCharCode(ba[p + j] + 33);\n            }\n            p += lseq;\n            record.quals = qseq;\n\n            while (p < blockEnd) {\n                var tag = String.fromCharCode(ba[p], ba[p + 1]);\n                var type = String.fromCharCode(ba[p + 2]);\n                var value;\n\n                if (type == 'A') {\n                    value = String.fromCharCode(ba[p + 3]);\n                    p += 4;\n                } else if (type == 'i' || type == 'I') {\n                    value = readInt(ba, p + 3);\n                    p += 7;\n                } else if (type == 'c' || type == 'C') {\n                    value = ba[p + 3];\n                    p += 4;\n                } else if (type == 's' || type == 'S') {\n                    value = readShort(ba, p + 3);\n                    p += 5;\n                } else if (type == 'f') {\n                    value = readFloat(ba, p + 3);\n                    p += 7;\n                } else if (type == 'Z' || type == 'H') {\n                    p += 3;\n                    value = '';\n                    for (;;) {\n                        var cc = ba[p++];\n                        if (cc == 0) {\n                            break;\n                        } else {\n                            value += String.fromCharCode(cc);\n                        }\n                    }\n                } else if (type == 'B') {\n                    var atype = String.fromCharCode(ba[p + 3]);\n                    var alen = readInt(ba, p + 4);\n                    var elen;\n                    var reader;\n                    if (atype == 'i' || atype == 'I' || atype == 'f') {\n                        elen = 4;\n                        if (atype == 'f')\n                            reader = readFloat;\n                        else\n                            reader = readInt;\n                    } else if (atype == 's' || atype == 'S') {\n                        elen = 2;\n                        reader = readShort;\n                    } else if (atype == 'c' || atype == 'C') {\n                        elen = 1;\n                        reader = readByte;\n                    } else {\n                        throw 'Unknown array type ' + atype;\n                    }\n\n                    p += 8;\n                    value = [];\n                    for (var i = 0; i < alen; ++i) {\n                        value.push(reader(ba, p));\n                        p += elen;\n                    }\n                } else {\n                    throw 'Unknown type '+ type;\n                }\n                record[tag] = value;\n            }\n        }\n\n        if (!min || record.pos <= max && record.pos + lseq >= min) {\n            if (chrId === undefined || refID == chrId) {\n                sink.push(record);\n            }\n        }\n        if (record.pos > max) {\n            return true;\n        }\n        offset = blockEnd;\n    }\n\n    // Exits via top of loop.\n};\n\nif (typeof(module) !== 'undefined') {\n    module.exports = {\n        makeBam: makeBam,\n        BAM_MAGIC: BAM_MAGIC,\n        BAI_MAGIC: BAI_MAGIC,\n        BamFlags: BamFlags\n    };\n}\n","(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\n/* -*- mode: javascript; c-basic-offset: 4; indent-tabs-mode: nil -*- */\n\n// \n// Dalliance Genome Explorer\n// (c) Thomas Down 2006-2011\n//\n// bam.js: indexed binary alignments\n//\n\n\"use strict\";\n\nif (typeof require !== 'undefined') {\n    var spans = require('./spans');\n    var Range = spans.Range;\n    var union = spans.union;\n    var intersection = spans.intersection;\n\n    var bin = require('./bin');\n    var readInt = bin.readInt;\n    var readShort = bin.readShort;\n    var readByte = bin.readByte;\n    var readInt64 = bin.readInt64;\n    var readFloat = bin.readFloat;\n\n    var lh3utils = require('./lh3utils');\n    var readVob = lh3utils.readVob;\n    var unbgzf = lh3utils.unbgzf;\n    var reg2bins = lh3utils.reg2bins;\n    var Chunk = lh3utils.Chunk;\n}\n\nvar BAM_MAGIC = 0x14d4142;\nvar BAI_MAGIC = 0x1494142;\n\nvar BamFlags = {\n    MULTIPLE_SEGMENTS: 0x1,\n    ALL_SEGMENTS_ALIGN: 0x2,\n    SEGMENT_UNMAPPED: 0x4,\n    NEXT_SEGMENT_UNMAPPED: 0x8,\n    REVERSE_COMPLEMENT: 0x10,\n    NEXT_REVERSE_COMPLEMENT: 0x20,\n    FIRST_SEGMENT: 0x40,\n    LAST_SEGMENT: 0x80,\n    SECONDARY_ALIGNMENT: 0x100,\n    QC_FAIL: 0x200,\n    DUPLICATE: 0x400,\n    SUPPLEMENTARY: 0x800\n};\n\nfunction BamFile() {}\n\n// Calculate the length (in bytes) of the BAI ref starting at offset.\n// Returns {nbin, length, minBlockIndex}\nfunction _getBaiRefLength(uncba, offset) {\n    var p = offset;\n    var nbin = readInt(uncba, p);p += 4;\n    for (var b = 0; b < nbin; ++b) {\n        var bin = readInt(uncba, p);\n        var nchnk = readInt(uncba, p + 4);\n        p += 8 + nchnk * 16;\n    }\n    var nintv = readInt(uncba, p);p += 4;\n\n    var minBlockIndex = 1000000000;\n    var q = p;\n    for (var i = 0; i < nintv; ++i) {\n        var v = readVob(uncba, q);q += 8;\n        if (v) {\n            var bi = v.block;\n            if (v.offset > 0) bi += 65536;\n\n            if (bi < minBlockIndex) minBlockIndex = bi;\n            break;\n        }\n    }\n    p += nintv * 8;\n\n    return {\n        minBlockIndex: minBlockIndex,\n        nbin: nbin,\n        length: p - offset\n    };\n}\n\nfunction makeBam(data, bai, indexChunks, callback, attempted) {\n    // Do an initial probe on the BAM file to catch any mixed-content errors.\n    data.slice(0, 10).fetch(function (header) {\n        if (header) {\n            return makeBam2(data, bai, indexChunks, callback, attempted);\n        } else {\n            return callback(null, \"Couldn't access BAM.\");\n        }\n    }, { timeout: 5000 });\n}\n\nfunction makeBam2(data, bai, indexChunks, callback, attempted) {\n    var bam = new BamFile();\n    bam.data = data;\n    bam.bai = bai;\n    bam.indexChunks = indexChunks;\n\n    var minBlockIndex = bam.indexChunks ? bam.indexChunks.minBlockIndex : 1000000000;\n\n    // Fills out bam.chrToIndex and bam.indexToChr based on the first few bytes of the BAM.\n    function parseBamHeader(r) {\n        if (!r) {\n            return callback(null, \"Couldn't access BAM\");\n        }\n\n        var unc = unbgzf(r, r.byteLength);\n        var uncba = new Uint8Array(unc);\n\n        var magic = readInt(uncba, 0);\n        if (magic != BAM_MAGIC) {\n            return callback(null, \"Not a BAM file, magic=0x\" + magic.toString(16));\n        }\n        var headLen = readInt(uncba, 4);\n        var header = '';\n        for (var i = 0; i < headLen; ++i) {\n            header += String.fromCharCode(uncba[i + 8]);\n        }\n\n        var nRef = readInt(uncba, headLen + 8);\n        var p = headLen + 12;\n\n        bam.chrToIndex = {};\n        bam.indexToChr = [];\n        for (var i = 0; i < nRef; ++i) {\n            var lName = readInt(uncba, p);\n            var name = '';\n            for (var j = 0; j < lName - 1; ++j) {\n                name += String.fromCharCode(uncba[p + 4 + j]);\n            }\n            var lRef = readInt(uncba, p + lName + 4);\n            bam.chrToIndex[name] = i;\n            if (name.indexOf('chr') == 0) {\n                bam.chrToIndex[name.substring(3)] = i;\n            } else {\n                bam.chrToIndex['chr' + name] = i;\n            }\n            bam.indexToChr.push(name);\n\n            p = p + 8 + lName;\n        }\n\n        if (bam.indices) {\n            return callback(bam);\n        }\n    }\n\n    function parseBai(header) {\n        if (!header) {\n            return \"Couldn't access BAI\";\n        }\n\n        var uncba = new Uint8Array(header);\n        var baiMagic = readInt(uncba, 0);\n        if (baiMagic != BAI_MAGIC) {\n            return callback(null, 'Not a BAI file, magic=0x' + baiMagic.toString(16));\n        }\n\n        var nref = readInt(uncba, 4);\n\n        bam.indices = [];\n\n        var p = 8;\n        for (var ref = 0; ref < nref; ++ref) {\n            var blockStart = p;\n            var o = _getBaiRefLength(uncba, blockStart);\n            p += o.length;\n\n            minBlockIndex = Math.min(o.minBlockIndex, minBlockIndex);\n\n            var nbin = o.nbin;\n\n            if (nbin > 0) {\n                bam.indices[ref] = new Uint8Array(header, blockStart, p - blockStart);\n            }\n        }\n\n        return true;\n    }\n\n    if (!bam.indexChunks) {\n        bam.bai.fetch(function (header) {\n            // Do we really need to fetch the whole thing? :-(\n            var result = parseBai(header);\n            if (result !== true) {\n                if (bam.bai.url && typeof attempted === \"undefined\") {\n                    // Already attempted x.bam.bai not there so now trying x.bai\n                    bam.bai.url = bam.data.url.replace(new RegExp('.bam$'), '.bai');\n\n                    // True lets us know we are making a second attempt\n                    makeBam2(data, bam.bai, indexChunks, callback, true);\n                } else {\n                    // We've attempted x.bam.bai & x.bai and nothing worked\n                    callback(null, result);\n                }\n            } else {\n                bam.data.slice(0, minBlockIndex).fetch(parseBamHeader);\n            }\n        }); // Timeout on first request to catch Chrome mixed-content error.\n    } else {\n        var chunks = bam.indexChunks.chunks;\n        bam.indices = [];\n        for (var i = 0; i < chunks.length; i++) {\n            bam.indices[i] = null; // To be filled out lazily as needed\n        }\n        bam.data.slice(0, minBlockIndex).fetch(parseBamHeader);\n    }\n}\n\nBamFile.prototype.blocksForRange = function (refId, min, max) {\n    var index = this.indices[refId];\n    if (!index) {\n        return [];\n    }\n\n    var intBinsL = reg2bins(min, max);\n    var intBins = [];\n    for (var i = 0; i < intBinsL.length; ++i) {\n        intBins[intBinsL[i]] = true;\n    }\n    var leafChunks = [],\n        otherChunks = [];\n\n    var nbin = readInt(index, 0);\n    var p = 4;\n    for (var b = 0; b < nbin; ++b) {\n        var bin = readInt(index, p);\n        var nchnk = readInt(index, p + 4);\n        //        dlog('bin=' + bin + '; nchnk=' + nchnk);\n        p += 8;\n        if (intBins[bin]) {\n            for (var c = 0; c < nchnk; ++c) {\n                var cs = readVob(index, p);\n                var ce = readVob(index, p + 8);\n                (bin < 4681 ? otherChunks : leafChunks).push(new Chunk(cs, ce));\n                p += 16;\n            }\n        } else {\n            p += nchnk * 16;\n        }\n    }\n    // console.log('leafChunks = ' + JSON.stringify(leafChunks));\n    // console.log('otherChunks = ' + JSON.stringify(otherChunks));\n\n    var nintv = readInt(index, p);\n    // console.log('nintv=' + nintv);\n    var lowest = null;\n    var minLin = Math.min(min >> 14, nintv - 1),\n        maxLin = Math.min(max >> 14, nintv - 1);\n    for (var i = minLin; i <= maxLin; ++i) {\n        var lb = readVob(index, p + 4 + i * 8);\n        if (!lb) {\n            continue;\n        }\n        if (!lowest || lb.block < lowest.block || lb.block == lowest.block && lb.offset < lowest.offset) {\n            lowest = lb;\n        }\n    }\n    // console.log('Lowest LB = ' + lowest);\n\n    var prunedOtherChunks = [];\n    if (lowest != null) {\n        for (var i = 0; i < otherChunks.length; ++i) {\n            var chnk = otherChunks[i];\n            if (chnk.maxv.block > lowest.block || chnk.maxv.block == lowest.block && chnk.maxv.offset >= lowest.offset) {\n                prunedOtherChunks.push(chnk);\n            }\n        }\n    }\n    // console.log('prunedOtherChunks = ' + JSON.stringify(prunedOtherChunks));\n    otherChunks = prunedOtherChunks;\n\n    var intChunks = [];\n    for (var i = 0; i < otherChunks.length; ++i) {\n        intChunks.push(otherChunks[i]);\n    }\n    for (var i = 0; i < leafChunks.length; ++i) {\n        intChunks.push(leafChunks[i]);\n    }\n\n    intChunks.sort(function (c0, c1) {\n        var dif = c0.minv.block - c1.minv.block;\n        if (dif != 0) {\n            return dif;\n        } else {\n            return c0.minv.offset - c1.minv.offset;\n        }\n    });\n    var mergedChunks = [];\n    if (intChunks.length > 0) {\n        var cur = intChunks[0];\n        for (var i = 1; i < intChunks.length; ++i) {\n            var nc = intChunks[i];\n            if (nc.minv.block == cur.maxv.block /* && nc.minv.offset == cur.maxv.offset */) {\n                    // no point splitting mid-block\n                    cur = new Chunk(cur.minv, nc.maxv);\n                } else {\n                mergedChunks.push(cur);\n                cur = nc;\n            }\n        }\n        mergedChunks.push(cur);\n    }\n    // console.log('mergedChunks = ' + JSON.stringify(mergedChunks));\n\n    return mergedChunks;\n};\n\nBamFile.prototype.fetch = function (chr, min, max, callback, opts) {\n    var thisB = this;\n    opts = opts || {};\n\n    var chrId = this.chrToIndex[chr];\n    var chunks;\n    if (chrId === undefined) {\n        chunks = [];\n    } else {\n        // Fetch this portion of the BAI if it hasn't been loaded yet.\n        if (this.indices[chrId] === null && this.indexChunks.chunks[chrId]) {\n            var start_stop = this.indexChunks.chunks[chrId];\n            return this.bai.slice(start_stop[0], start_stop[1]).fetch(function (data) {\n                var buffer = new Uint8Array(data);\n                this.indices[chrId] = buffer;\n                return this.fetch(chr, min, max, callback, opts);\n            }.bind(this));\n        }\n\n        chunks = this.blocksForRange(chrId, min, max);\n        if (!chunks) {\n            callback(null, 'Error in index fetch');\n        }\n    }\n\n    var records = [];\n    var index = 0;\n    var data;\n\n    function tramp() {\n        if (index >= chunks.length) {\n            return callback(records);\n        } else if (!data) {\n            var c = chunks[index];\n            var fetchMin = c.minv.block;\n            var fetchMax = c.maxv.block + (1 << 16); // *sigh*\n            // console.log('fetching ' + fetchMin + ':' + fetchMax);\n            thisB.data.slice(fetchMin, fetchMax - fetchMin).fetch(function (r) {\n                data = unbgzf(r, c.maxv.block - c.minv.block + 1);\n                return tramp();\n            });\n        } else {\n            var ba = new Uint8Array(data);\n            var finished = thisB.readBamRecords(ba, chunks[index].minv.offset, records, min, max, chrId, opts);\n            data = null;\n            ++index;\n            if (finished) return callback(records);else return tramp();\n        }\n    }\n    tramp();\n};\n\nvar SEQRET_DECODER = ['=', 'A', 'C', 'x', 'G', 'x', 'x', 'x', 'T', 'x', 'x', 'x', 'x', 'x', 'x', 'N'];\nvar CIGAR_DECODER = ['M', 'I', 'D', 'N', 'S', 'H', 'P', '=', 'X', '?', '?', '?', '?', '?', '?', '?'];\n\nfunction BamRecord() {}\n\nBamFile.prototype.readBamRecords = function (ba, offset, sink, min, max, chrId, opts) {\n    while (true) {\n        var blockSize = readInt(ba, offset);\n        var blockEnd = offset + blockSize + 4;\n        if (blockEnd > ba.length) {\n            return false;\n        }\n\n        var record = new BamRecord();\n\n        var refID = readInt(ba, offset + 4);\n        var pos = readInt(ba, offset + 8);\n\n        var bmn = readInt(ba, offset + 12);\n        var bin = (bmn & 0xffff0000) >> 16;\n        var mq = (bmn & 0xff00) >> 8;\n        var nl = bmn & 0xff;\n\n        var flag_nc = readInt(ba, offset + 16);\n        var flag = (flag_nc & 0xffff0000) >> 16;\n        var nc = flag_nc & 0xffff;\n\n        var lseq = readInt(ba, offset + 20);\n\n        var nextRef = readInt(ba, offset + 24);\n        var nextPos = readInt(ba, offset + 28);\n\n        var tlen = readInt(ba, offset + 32);\n\n        record.segment = this.indexToChr[refID];\n        record.flag = flag;\n        record.pos = pos;\n        record.mq = mq;\n        if (opts.light) record.seqLength = lseq;\n\n        if (!opts.light || opts.includeName) {\n            var readName = '';\n            for (var j = 0; j < nl - 1; ++j) {\n                readName += String.fromCharCode(ba[offset + 36 + j]);\n            }\n            record.readName = readName;\n        }\n\n        if (!opts.light) {\n            if (nextRef >= 0) {\n                record.nextSegment = this.indexToChr[nextRef];\n                record.nextPos = nextPos;\n            }\n\n            var p = offset + 36 + nl;\n\n            var cigar = '';\n            for (var c = 0; c < nc; ++c) {\n                var cigop = readInt(ba, p);\n                cigar = cigar + (cigop >> 4) + CIGAR_DECODER[cigop & 0xf];\n                p += 4;\n            }\n            record.cigar = cigar;\n\n            var seq = '';\n            var seqBytes = lseq + 1 >> 1;\n            for (var j = 0; j < seqBytes; ++j) {\n                var sb = ba[p + j];\n                seq += SEQRET_DECODER[(sb & 0xf0) >> 4];\n                if (seq.length < lseq) seq += SEQRET_DECODER[sb & 0x0f];\n            }\n            p += seqBytes;\n            record.seq = seq;\n\n            var qseq = '';\n            for (var j = 0; j < lseq; ++j) {\n                qseq += String.fromCharCode(ba[p + j] + 33);\n            }\n            p += lseq;\n            record.quals = qseq;\n\n            while (p < blockEnd) {\n                var tag = String.fromCharCode(ba[p], ba[p + 1]);\n                var type = String.fromCharCode(ba[p + 2]);\n                var value;\n\n                if (type == 'A') {\n                    value = String.fromCharCode(ba[p + 3]);\n                    p += 4;\n                } else if (type == 'i' || type == 'I') {\n                    value = readInt(ba, p + 3);\n                    p += 7;\n                } else if (type == 'c' || type == 'C') {\n                    value = ba[p + 3];\n                    p += 4;\n                } else if (type == 's' || type == 'S') {\n                    value = readShort(ba, p + 3);\n                    p += 5;\n                } else if (type == 'f') {\n                    value = readFloat(ba, p + 3);\n                    p += 7;\n                } else if (type == 'Z' || type == 'H') {\n                    p += 3;\n                    value = '';\n                    for (;;) {\n                        var cc = ba[p++];\n                        if (cc == 0) {\n                            break;\n                        } else {\n                            value += String.fromCharCode(cc);\n                        }\n                    }\n                } else if (type == 'B') {\n                    var atype = String.fromCharCode(ba[p + 3]);\n                    var alen = readInt(ba, p + 4);\n                    var elen;\n                    var reader;\n                    if (atype == 'i' || atype == 'I' || atype == 'f') {\n                        elen = 4;\n                        if (atype == 'f') reader = readFloat;else reader = readInt;\n                    } else if (atype == 's' || atype == 'S') {\n                        elen = 2;\n                        reader = readShort;\n                    } else if (atype == 'c' || atype == 'C') {\n                        elen = 1;\n                        reader = readByte;\n                    } else {\n                        throw 'Unknown array type ' + atype;\n                    }\n\n                    p += 8;\n                    value = [];\n                    for (var i = 0; i < alen; ++i) {\n                        value.push(reader(ba, p));\n                        p += elen;\n                    }\n                } else {\n                    throw 'Unknown type ' + type;\n                }\n                record[tag] = value;\n            }\n        }\n\n        if (!min || record.pos <= max && record.pos + lseq >= min) {\n            if (chrId === undefined || refID == chrId) {\n                sink.push(record);\n            }\n        }\n        if (record.pos > max) {\n            return true;\n        }\n        offset = blockEnd;\n    }\n\n    // Exits via top of loop.\n};\n\nif (typeof module !== 'undefined') {\n    module.exports = {\n        makeBam: makeBam,\n        BAM_MAGIC: BAM_MAGIC,\n        BAI_MAGIC: BAI_MAGIC,\n        BamFlags: BamFlags\n    };\n}\n\n},{\"./bin\":3,\"./lh3utils\":9,\"./spans\":11}],2:[function(require,module,exports){\n/* -*- mode: javascript; c-basic-offset: 4; indent-tabs-mode: nil -*- */\n\n// \n// Dalliance Genome Explorer\n// (c) Thomas Down 2006-2010\n//\n// bigwig.js: indexed binary WIG (and BED) files\n//\n\n\"use strict\";\n\nif (typeof require !== 'undefined') {\n    var spans = require('./spans');\n    var Range = spans.Range;\n    var union = spans.union;\n    var intersection = spans.intersection;\n\n    var das = require('./das');\n    var DASFeature = das.DASFeature;\n    var DASGroup = das.DASGroup;\n\n    var utils = require('./utils');\n    var shallowCopy = utils.shallowCopy;\n\n    var bin = require('./bin');\n    var readInt = bin.readInt;\n\n    var jszlib = require('jszlib');\n    var jszlib_inflate_buffer = jszlib.inflateBuffer;\n    var arrayCopy = jszlib.arrayCopy;\n}\n\nvar BIG_WIG_MAGIC = 0x888FFC26;\nvar BIG_WIG_MAGIC_BE = 0x26FC8F88;\nvar BIG_BED_MAGIC = 0x8789F2EB;\nvar BIG_BED_MAGIC_BE = 0xEBF28987;\n\nvar BIG_WIG_TYPE_GRAPH = 1;\nvar BIG_WIG_TYPE_VSTEP = 2;\nvar BIG_WIG_TYPE_FSTEP = 3;\n\nvar M1 = 256;\nvar M2 = 256 * 256;\nvar M3 = 256 * 256 * 256;\nvar M4 = 256 * 256 * 256 * 256;\n\nvar BED_COLOR_REGEXP = new RegExp(\"^[0-9]+,[0-9]+,[0-9]+\");\n\nfunction bwg_readOffset(ba, o) {\n    var offset = ba[o] + ba[o + 1] * M1 + ba[o + 2] * M2 + ba[o + 3] * M3 + ba[o + 4] * M4;\n    return offset;\n}\n\nfunction BigWig() {}\n\nBigWig.prototype.readChromTree = function (callback) {\n    var thisB = this;\n    this.chromsToIDs = {};\n    this.idsToChroms = {};\n    this.maxID = 0;\n\n    var udo = this.unzoomedDataOffset;\n    var eb = udo - this.chromTreeOffset & 3;\n    udo = udo + 4 - eb;\n\n    this.data.slice(this.chromTreeOffset, udo - this.chromTreeOffset).fetch(function (bpt) {\n        var ba = new Uint8Array(bpt);\n        var sa = new Int16Array(bpt);\n        var la = new Int32Array(bpt);\n        var bptMagic = la[0];\n        var blockSize = la[1];\n        var keySize = la[2];\n        var valSize = la[3];\n        var itemCount = bwg_readOffset(ba, 16);\n        var rootNodeOffset = 32;\n\n        var bptReadNode = function bptReadNode(offset) {\n            var nodeType = ba[offset];\n            var cnt = sa[offset / 2 + 1];\n            offset += 4;\n            for (var n = 0; n < cnt; ++n) {\n                if (nodeType == 0) {\n                    offset += keySize;\n                    var childOffset = bwg_readOffset(ba, offset);\n                    offset += 8;\n                    childOffset -= thisB.chromTreeOffset;\n                    bptReadNode(childOffset);\n                } else {\n                    var key = '';\n                    for (var ki = 0; ki < keySize; ++ki) {\n                        var charCode = ba[offset++];\n                        if (charCode != 0) {\n                            key += String.fromCharCode(charCode);\n                        }\n                    }\n                    var chromId = ba[offset + 3] << 24 | ba[offset + 2] << 16 | ba[offset + 1] << 8 | ba[offset + 0];\n                    var chromSize = ba[offset + 7] << 24 | ba[offset + 6] << 16 | ba[offset + 5] << 8 | ba[offset + 4];\n                    offset += 8;\n\n                    thisB.chromsToIDs[key] = chromId;\n                    if (key.indexOf('chr') == 0) {\n                        thisB.chromsToIDs[key.substr(3)] = chromId;\n                    }\n                    thisB.idsToChroms[chromId] = key;\n                    thisB.maxID = Math.max(thisB.maxID, chromId);\n                }\n            }\n        };\n        bptReadNode(rootNodeOffset);\n\n        callback(thisB);\n    });\n};\n\nfunction BigWigView(bwg, cirTreeOffset, cirTreeLength, isSummary) {\n    this.bwg = bwg;\n    this.cirTreeOffset = cirTreeOffset;\n    this.cirTreeLength = cirTreeLength;\n    this.isSummary = isSummary;\n}\n\nBigWigView.prototype.readWigData = function (chrName, min, max, callback) {\n    var chr = this.bwg.chromsToIDs[chrName];\n    if (chr === undefined) {\n        // Not an error because some .bwgs won't have data for all chromosomes.\n        return callback([]);\n    } else {\n        this.readWigDataById(chr, min, max, callback);\n    }\n};\n\nBigWigView.prototype.readWigDataById = function (chr, min, max, callback) {\n    var thisB = this;\n    if (!this.cirHeader) {\n        this.bwg.data.slice(this.cirTreeOffset, 48).fetch(function (result) {\n            thisB.cirHeader = result;\n            var la = new Int32Array(thisB.cirHeader);\n            thisB.cirBlockSize = la[1];\n            thisB.readWigDataById(chr, min, max, callback);\n        });\n        return;\n    }\n\n    var blocksToFetch = [];\n    var outstanding = 0;\n\n    var beforeBWG = Date.now();\n\n    var filter = function filter(chromId, fmin, fmax, toks) {\n        return (chr < 0 || chromId == chr) && fmin <= max && fmax >= min;\n    };\n\n    var cirFobRecur = function cirFobRecur(offset, level) {\n        if (thisB.bwg.instrument) console.log('level=' + level + '; offset=' + offset + '; time=' + (Date.now() | 0));\n\n        outstanding += offset.length;\n\n        if (offset.length == 1 && offset[0] - thisB.cirTreeOffset == 48 && thisB.cachedCirRoot) {\n            cirFobRecur2(thisB.cachedCirRoot, 0, level);\n            --outstanding;\n            if (outstanding == 0) {\n                thisB.fetchFeatures(filter, blocksToFetch, callback);\n            }\n            return;\n        }\n\n        var maxCirBlockSpan = 4 + thisB.cirBlockSize * 32; // Upper bound on size, based on a completely full leaf node.\n        var spans;\n        for (var i = 0; i < offset.length; ++i) {\n            var blockSpan = new Range(offset[i], offset[i] + maxCirBlockSpan);\n            spans = spans ? union(spans, blockSpan) : blockSpan;\n        }\n\n        var fetchRanges = spans.ranges();\n        for (var r = 0; r < fetchRanges.length; ++r) {\n            var fr = fetchRanges[r];\n            cirFobStartFetch(offset, fr, level);\n        }\n    };\n\n    var cirFobStartFetch = function cirFobStartFetch(offset, fr, level, attempts) {\n        var length = fr.max() - fr.min();\n        thisB.bwg.data.slice(fr.min(), fr.max() - fr.min()).fetch(function (resultBuffer) {\n            for (var i = 0; i < offset.length; ++i) {\n                if (fr.contains(offset[i])) {\n                    cirFobRecur2(resultBuffer, offset[i] - fr.min(), level);\n\n                    if (offset[i] - thisB.cirTreeOffset == 48 && offset[i] - fr.min() == 0) thisB.cachedCirRoot = resultBuffer;\n\n                    --outstanding;\n                    if (outstanding == 0) {\n                        thisB.fetchFeatures(filter, blocksToFetch, callback);\n                    }\n                }\n            }\n        });\n    };\n\n    var cirFobRecur2 = function cirFobRecur2(cirBlockData, offset, level) {\n        var ba = new Uint8Array(cirBlockData);\n        var sa = new Int16Array(cirBlockData);\n        var la = new Int32Array(cirBlockData);\n\n        var isLeaf = ba[offset];\n        var cnt = sa[offset / 2 + 1];\n        offset += 4;\n\n        if (isLeaf != 0) {\n            for (var i = 0; i < cnt; ++i) {\n                var lo = offset / 4;\n                var startChrom = la[lo];\n                var startBase = la[lo + 1];\n                var endChrom = la[lo + 2];\n                var endBase = la[lo + 3];\n                var blockOffset = bwg_readOffset(ba, offset + 16);\n                var blockSize = bwg_readOffset(ba, offset + 24);\n                if ((chr < 0 || startChrom < chr || startChrom == chr && startBase <= max) && (chr < 0 || endChrom > chr || endChrom == chr && endBase >= min)) {\n                    blocksToFetch.push({ offset: blockOffset, size: blockSize });\n                }\n                offset += 32;\n            }\n        } else {\n            var recurOffsets = [];\n            for (var i = 0; i < cnt; ++i) {\n                var lo = offset / 4;\n                var startChrom = la[lo];\n                var startBase = la[lo + 1];\n                var endChrom = la[lo + 2];\n                var endBase = la[lo + 3];\n                var blockOffset = bwg_readOffset(ba, offset + 16);\n                if ((chr < 0 || startChrom < chr || startChrom == chr && startBase <= max) && (chr < 0 || endChrom > chr || endChrom == chr && endBase >= min)) {\n                    recurOffsets.push(blockOffset);\n                }\n                offset += 24;\n            }\n            if (recurOffsets.length > 0) {\n                cirFobRecur(recurOffsets, level + 1);\n            }\n        }\n    };\n\n    cirFobRecur([thisB.cirTreeOffset + 48], 1);\n};\n\nBigWigView.prototype.fetchFeatures = function (filter, blocksToFetch, callback) {\n    var thisB = this;\n\n    blocksToFetch.sort(function (b0, b1) {\n        return (b0.offset | 0) - (b1.offset | 0);\n    });\n\n    if (blocksToFetch.length == 0) {\n        callback([]);\n    } else {\n        var features = [];\n        var createFeature = function createFeature(chr, fmin, fmax, opts) {\n            if (!opts) {\n                opts = {};\n            }\n\n            var f = new DASFeature();\n            f._chromId = chr;\n            f.segment = thisB.bwg.idsToChroms[chr];\n            f.min = fmin;\n            f.max = fmax;\n            f.type = thisB.bwg.type;\n\n            for (var k in opts) {\n                f[k] = opts[k];\n            }\n\n            features.push(f);\n        };\n\n        var tramp = function tramp() {\n            if (blocksToFetch.length == 0) {\n                var afterBWG = Date.now();\n                // dlog('BWG fetch took ' + (afterBWG - beforeBWG) + 'ms');\n                callback(features);\n                return; // just in case...\n            } else {\n                var block = blocksToFetch[0];\n                if (block.data) {\n                    thisB.parseFeatures(block.data, createFeature, filter);\n                    blocksToFetch.splice(0, 1);\n                    tramp();\n                } else {\n                    var fetchStart = block.offset;\n                    var fetchSize = block.size;\n                    var bi = 1;\n                    while (bi < blocksToFetch.length && blocksToFetch[bi].offset == fetchStart + fetchSize) {\n                        fetchSize += blocksToFetch[bi].size;\n                        ++bi;\n                    }\n\n                    thisB.bwg.data.slice(fetchStart, fetchSize).fetch(function (result) {\n                        var offset = 0;\n                        var bi = 0;\n                        while (offset < fetchSize) {\n                            var fb = blocksToFetch[bi];\n\n                            var data;\n                            if (thisB.bwg.uncompressBufSize > 0) {\n                                data = jszlib_inflate_buffer(result, offset + 2, fb.size - 2);\n                            } else {\n                                var tmp = new Uint8Array(fb.size); // FIXME is this really the best we can do?\n                                arrayCopy(new Uint8Array(result, offset, fb.size), 0, tmp, 0, fb.size);\n                                data = tmp.buffer;\n                            }\n                            fb.data = data;\n\n                            offset += fb.size;\n                            ++bi;\n                        }\n                        tramp();\n                    });\n                }\n            }\n        };\n        tramp();\n    }\n};\n\nBigWigView.prototype.parseFeatures = function (data, createFeature, filter) {\n    var ba = new Uint8Array(data);\n\n    if (this.isSummary) {\n        var sa = new Int16Array(data);\n        var la = new Int32Array(data);\n        var fa = new Float32Array(data);\n\n        var itemCount = data.byteLength / 32;\n        for (var i = 0; i < itemCount; ++i) {\n            var chromId = la[i * 8];\n            var start = la[i * 8 + 1];\n            var end = la[i * 8 + 2];\n            var validCnt = la[i * 8 + 3];\n            var minVal = fa[i * 8 + 4];\n            var maxVal = fa[i * 8 + 5];\n            var sumData = fa[i * 8 + 6];\n            var sumSqData = fa[i * 8 + 7];\n\n            if (filter(chromId, start + 1, end)) {\n                var summaryOpts = { type: 'bigwig', score: sumData / validCnt, maxScore: maxVal };\n                if (this.bwg.type == 'bigbed') {\n                    summaryOpts.type = 'density';\n                }\n                createFeature(chromId, start + 1, end, summaryOpts);\n            }\n        }\n    } else if (this.bwg.type == 'bigwig') {\n        var sa = new Int16Array(data);\n        var la = new Int32Array(data);\n        var fa = new Float32Array(data);\n\n        var chromId = la[0];\n        var blockStart = la[1];\n        var blockEnd = la[2];\n        var itemStep = la[3];\n        var itemSpan = la[4];\n        var blockType = ba[20];\n        var itemCount = sa[11];\n\n        if (blockType == BIG_WIG_TYPE_FSTEP) {\n            for (var i = 0; i < itemCount; ++i) {\n                var score = fa[i + 6];\n                var fmin = blockStart + i * itemStep + 1,\n                    fmax = blockStart + i * itemStep + itemSpan;\n                if (filter(chromId, fmin, fmax)) createFeature(chromId, fmin, fmax, { score: score });\n            }\n        } else if (blockType == BIG_WIG_TYPE_VSTEP) {\n            for (var i = 0; i < itemCount; ++i) {\n                var start = la[i * 2 + 6] + 1;\n                var end = start + itemSpan - 1;\n                var score = fa[i * 2 + 7];\n                if (filter(chromId, start, end)) createFeature(chromId, start, end, { score: score });\n            }\n        } else if (blockType == BIG_WIG_TYPE_GRAPH) {\n            for (var i = 0; i < itemCount; ++i) {\n                var start = la[i * 3 + 6] + 1;\n                var end = la[i * 3 + 7];\n                var score = fa[i * 3 + 8];\n                if (start > end) {\n                    start = end;\n                }\n                if (filter(chromId, start, end)) createFeature(chromId, start, end, { score: score });\n            }\n        } else {\n            console.log('Currently not handling bwgType=' + blockType);\n        }\n    } else if (this.bwg.type == 'bigbed') {\n        var offset = 0;\n        var dfc = this.bwg.definedFieldCount;\n        var schema = this.bwg.schema;\n\n        while (offset < ba.length) {\n            var chromId = ba[offset + 3] << 24 | ba[offset + 2] << 16 | ba[offset + 1] << 8 | ba[offset + 0];\n            var start = ba[offset + 7] << 24 | ba[offset + 6] << 16 | ba[offset + 5] << 8 | ba[offset + 4];\n            var end = ba[offset + 11] << 24 | ba[offset + 10] << 16 | ba[offset + 9] << 8 | ba[offset + 8];\n            offset += 12;\n            var rest = '';\n            while (true) {\n                var ch = ba[offset++];\n                if (ch != 0) {\n                    rest += String.fromCharCode(ch);\n                } else {\n                    break;\n                }\n            }\n\n            var featureOpts = {};\n\n            var bedColumns;\n            if (rest.length > 0) {\n                bedColumns = rest.split('\\t');\n            } else {\n                bedColumns = [];\n            }\n            if (bedColumns.length > 0 && dfc > 3) {\n                featureOpts.label = bedColumns[0];\n            }\n            if (bedColumns.length > 1 && dfc > 4) {\n                var score = parseInt(bedColumns[1]);\n                if (!isNaN(score)) featureOpts.score = score;\n            }\n            if (bedColumns.length > 2 && dfc > 5) {\n                featureOpts.orientation = bedColumns[2];\n            }\n            if (bedColumns.length > 5 && dfc > 8) {\n                var color = bedColumns[5];\n                if (BED_COLOR_REGEXP.test(color)) {\n                    featureOpts.itemRgb = 'rgb(' + color + ')';\n                }\n            }\n\n            if (bedColumns.length > dfc - 3 && schema) {\n                for (var col = dfc - 3; col < bedColumns.length; ++col) {\n                    featureOpts[schema.fields[col + 3].name] = bedColumns[col];\n                }\n            }\n\n            if (filter(chromId, start + 1, end, bedColumns)) {\n                if (dfc < 12) {\n                    createFeature(chromId, start + 1, end, featureOpts);\n                } else {\n                    var thickStart = bedColumns[3] | 0;\n                    var thickEnd = bedColumns[4] | 0;\n                    var blockCount = bedColumns[6] | 0;\n                    var blockSizes = bedColumns[7].split(',');\n                    var blockStarts = bedColumns[8].split(',');\n\n                    if (featureOpts.exonFrames) {\n                        var exonFrames = featureOpts.exonFrames.split(',');\n                        featureOpts.exonFrames = undefined;\n                    }\n\n                    featureOpts.type = 'transcript';\n                    var grp = new DASGroup();\n                    for (var k in featureOpts) {\n                        grp[k] = featureOpts[k];\n                    }\n                    grp.id = bedColumns[0];\n                    grp.segment = this.bwg.idsToChroms[chromId];\n                    grp.min = start + 1;\n                    grp.max = end;\n                    grp.notes = [];\n                    featureOpts.groups = [grp];\n\n                    // Moving towards using bigGenePred model, but will\n                    // still support old Dalliance-style BED12+gene-name for the\n                    // foreseeable future.\n                    if (bedColumns.length > 9) {\n                        var geneId = featureOpts.geneName || bedColumns[9];\n                        var geneName = geneId;\n                        if (bedColumns.length > 10) {\n                            geneName = bedColumns[10];\n                        }\n                        if (featureOpts.geneName2) geneName = featureOpts.geneName2;\n\n                        var gg = shallowCopy(grp);\n                        gg.id = geneId;\n                        gg.label = geneName;\n                        gg.type = 'gene';\n                        featureOpts.groups.push(gg);\n                    }\n\n                    var spanList = [];\n                    for (var b = 0; b < blockCount; ++b) {\n                        var bmin = (blockStarts[b] | 0) + start;\n                        var bmax = bmin + (blockSizes[b] | 0);\n                        var span = new Range(bmin, bmax);\n                        spanList.push(span);\n                    }\n                    var spans = union(spanList);\n\n                    var tsList = spans.ranges();\n                    for (var s = 0; s < tsList.length; ++s) {\n                        var ts = tsList[s];\n                        createFeature(chromId, ts.min() + 1, ts.max(), featureOpts);\n                    }\n\n                    if (thickEnd > thickStart) {\n                        var codingRegion = featureOpts.orientation == '+' ? new Range(thickStart, thickEnd + 3) : new Range(thickStart - 3, thickEnd);\n                        // +/- 3 to account for stop codon\n\n                        var tl = intersection(spans, codingRegion);\n                        if (tl) {\n                            featureOpts.type = 'translation';\n                            var tlList = tl.ranges();\n                            var readingFrame = 0;\n\n                            var tlOffset = 0;\n                            while (tlList[0].min() > tsList[tlOffset].max()) {\n                                tlOffset++;\n                            }for (var s = 0; s < tlList.length; ++s) {\n                                // Record reading frame for every exon\n                                var index = s;\n                                if (featureOpts.orientation == '-') index = tlList.length - s - 1;\n                                var ts = tlList[index];\n                                featureOpts.readframe = readingFrame;\n                                if (exonFrames) {\n                                    var brf = parseInt(exonFrames[index + tlOffset]);\n                                    if (typeof brf === 'number' && brf >= 0 && brf <= 2) {\n                                        featureOpts.readframe = brf;\n                                        featureOpts.readframeExplicit = true;\n                                    }\n                                }\n                                var length = ts.max() - ts.min();\n                                readingFrame = (readingFrame + length) % 3;\n                                createFeature(chromId, ts.min() + 1, ts.max(), featureOpts);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    } else {\n        throw Error(\"Don't know what to do with \" + this.bwg.type);\n    }\n};\n\n//\n// nasty cut/paste, should roll back in!\n//\n\nBigWigView.prototype.getFirstAdjacent = function (chrName, pos, dir, callback) {\n    var chr = this.bwg.chromsToIDs[chrName];\n    if (chr === undefined) {\n        // Not an error because some .bwgs won't have data for all chromosomes.\n        return callback([]);\n    } else {\n        this.getFirstAdjacentById(chr, pos, dir, callback);\n    }\n};\n\nBigWigView.prototype.getFirstAdjacentById = function (chr, pos, dir, callback) {\n    var thisB = this;\n    if (!this.cirHeader) {\n        this.bwg.data.slice(this.cirTreeOffset, 48).fetch(function (result) {\n            thisB.cirHeader = result;\n            var la = new Int32Array(thisB.cirHeader);\n            thisB.cirBlockSize = la[1];\n            thisB.getFirstAdjacentById(chr, pos, dir, callback);\n        });\n        return;\n    }\n\n    var blockToFetch = null;\n    var bestBlockChr = -1;\n    var bestBlockOffset = -1;\n\n    var outstanding = 0;\n\n    var beforeBWG = Date.now();\n\n    var cirFobRecur = function cirFobRecur(offset, level) {\n        outstanding += offset.length;\n\n        var maxCirBlockSpan = 4 + thisB.cirBlockSize * 32; // Upper bound on size, based on a completely full leaf node.\n        var spans;\n        for (var i = 0; i < offset.length; ++i) {\n            var blockSpan = new Range(offset[i], offset[i] + maxCirBlockSpan);\n            spans = spans ? union(spans, blockSpan) : blockSpan;\n        }\n\n        var fetchRanges = spans.ranges();\n        for (var r = 0; r < fetchRanges.length; ++r) {\n            var fr = fetchRanges[r];\n            cirFobStartFetch(offset, fr, level);\n        }\n    };\n\n    var cirFobStartFetch = function cirFobStartFetch(offset, fr, level, attempts) {\n        var length = fr.max() - fr.min();\n        thisB.bwg.data.slice(fr.min(), fr.max() - fr.min()).fetch(function (resultBuffer) {\n            for (var i = 0; i < offset.length; ++i) {\n                if (fr.contains(offset[i])) {\n                    cirFobRecur2(resultBuffer, offset[i] - fr.min(), level);\n                    --outstanding;\n                    if (outstanding == 0) {\n                        if (!blockToFetch) {\n                            if (dir > 0 && (chr != 0 || pos > 0)) {\n                                return thisB.getFirstAdjacentById(0, 0, dir, callback);\n                            } else if (dir < 0 && (chr != thisB.bwg.maxID || pos < 1000000000)) {\n                                return thisB.getFirstAdjacentById(thisB.bwg.maxID, 1000000000, dir, callback);\n                            }\n                            return callback([]);\n                        }\n\n                        thisB.fetchFeatures(function (chrx, fmin, fmax, toks) {\n                            return dir < 0 && (chrx < chr || fmax < pos) || dir > 0 && (chrx > chr || fmin > pos);\n                        }, [blockToFetch], function (features) {\n                            var bestFeature = null;\n                            var bestChr = -1;\n                            var bestPos = -1;\n                            for (var fi = 0; fi < features.length; ++fi) {\n                                var f = features[fi];\n                                var chrx = f._chromId,\n                                    fmin = f.min,\n                                    fmax = f.max;\n                                if (bestFeature == null || dir < 0 && (chrx > bestChr || fmax > bestPos) || dir > 0 && (chrx < bestChr || fmin < bestPos)) {\n                                    bestFeature = f;\n                                    bestPos = dir < 0 ? fmax : fmin;\n                                    bestChr = chrx;\n                                }\n                            }\n\n                            if (bestFeature != null) return callback([bestFeature]);else return callback([]);\n                        });\n                    }\n                }\n            }\n        });\n    };\n\n    var cirFobRecur2 = function cirFobRecur2(cirBlockData, offset, level) {\n        var ba = new Uint8Array(cirBlockData);\n        var sa = new Int16Array(cirBlockData);\n        var la = new Int32Array(cirBlockData);\n\n        var isLeaf = ba[offset];\n        var cnt = sa[offset / 2 + 1];\n        offset += 4;\n\n        if (isLeaf != 0) {\n            for (var i = 0; i < cnt; ++i) {\n                var lo = offset / 4;\n                var startChrom = la[lo];\n                var startBase = la[lo + 1];\n                var endChrom = la[lo + 2];\n                var endBase = la[lo + 3];\n                var blockOffset = bwg_readOffset(ba, offset + 16);\n                var blockSize = bwg_readOffset(ba, offset + 24);\n                if (dir < 0 && (startChrom < chr || startChrom == chr && startBase <= pos) || dir > 0 && (endChrom > chr || endChrom == chr && endBase >= pos)) {\n                    // console.log('Got an interesting block: startBase=' + startChrom + ':' + startBase + '; endBase=' + endChrom + ':' + endBase + '; offset=' + blockOffset + '; size=' + blockSize);\n                    if (/_random/.exec(thisB.bwg.idsToChroms[startChrom])) {\n                        // dlog('skipping random: ' + thisB.bwg.idsToChroms[startChrom]);\n                    } else if (blockToFetch == null || dir < 0 && (endChrom > bestBlockChr || endChrom == bestBlockChr && endBase > bestBlockOffset) || dir > 0 && (startChrom < bestBlockChr || startChrom == bestBlockChr && startBase < bestBlockOffset)) {\n                        //                        dlog('best is: startBase=' + startChrom + ':' + startBase + '; endBase=' + endChrom + ':' + endBase + '; offset=' + blockOffset + '; size=' + blockSize);\n                        blockToFetch = { offset: blockOffset, size: blockSize };\n                        bestBlockOffset = dir < 0 ? endBase : startBase;\n                        bestBlockChr = dir < 0 ? endChrom : startChrom;\n                    }\n                }\n                offset += 32;\n            }\n        } else {\n            var bestRecur = -1;\n            var bestPos = -1;\n            var bestChr = -1;\n            for (var i = 0; i < cnt; ++i) {\n                var lo = offset / 4;\n                var startChrom = la[lo];\n                var startBase = la[lo + 1];\n                var endChrom = la[lo + 2];\n                var endBase = la[lo + 3];\n                var blockOffset = la[lo + 4] << 32 | la[lo + 5];\n                if (dir < 0 && (startChrom < chr || startChrom == chr && startBase <= pos) && endChrom >= chr || dir > 0 && (endChrom > chr || endChrom == chr && endBase >= pos) && startChrom <= chr) {\n                    if (bestRecur < 0 || endBase > bestPos) {\n                        bestRecur = blockOffset;\n                        bestPos = dir < 0 ? endBase : startBase;\n                        bestChr = dir < 0 ? endChrom : startChrom;\n                    }\n                }\n                offset += 24;\n            }\n            if (bestRecur >= 0) {\n                cirFobRecur([bestRecur], level + 1);\n            }\n        }\n    };\n\n    cirFobRecur([thisB.cirTreeOffset + 48], 1);\n};\n\nBigWig.prototype.readWigData = function (chrName, min, max, callback) {\n    this.getUnzoomedView().readWigData(chrName, min, max, callback);\n};\n\nBigWig.prototype.getUnzoomedView = function () {\n    if (!this.unzoomedView) {\n        var cirLen = 4000;\n        var nzl = this.zoomLevels[0];\n        if (nzl) {\n            cirLen = this.zoomLevels[0].dataOffset - this.unzoomedIndexOffset;\n        }\n        this.unzoomedView = new BigWigView(this, this.unzoomedIndexOffset, cirLen, false);\n    }\n    return this.unzoomedView;\n};\n\nBigWig.prototype.getZoomedView = function (z) {\n    var zh = this.zoomLevels[z];\n    if (!zh.view) {\n        zh.view = new BigWigView(this, zh.indexOffset, /* this.zoomLevels[z + 1].dataOffset - zh.indexOffset */4000, true);\n    }\n    return zh.view;\n};\n\nfunction makeBwg(data, callback, name) {\n    var bwg = new BigWig();\n    bwg.data = data;\n    bwg.name = name;\n    bwg.data.slice(0, 512).salted().fetch(function (result) {\n        if (!result) {\n            return callback(null, \"Couldn't fetch file\");\n        }\n\n        var header = result;\n        var ba = new Uint8Array(header);\n        var sa = new Int16Array(header);\n        var la = new Int32Array(header);\n        var magic = ba[0] + M1 * ba[1] + M2 * ba[2] + M3 * ba[3];\n        if (magic == BIG_WIG_MAGIC) {\n            bwg.type = 'bigwig';\n        } else if (magic == BIG_BED_MAGIC) {\n            bwg.type = 'bigbed';\n        } else if (magic == BIG_WIG_MAGIC_BE || magic == BIG_BED_MAGIC_BE) {\n            return callback(null, \"Currently don't support big-endian BBI files\");\n        } else {\n            return callback(null, \"Not a supported format, magic=0x\" + magic.toString(16));\n        }\n\n        bwg.version = sa[2]; // 4\n        bwg.numZoomLevels = sa[3]; // 6\n        bwg.chromTreeOffset = bwg_readOffset(ba, 8);\n        bwg.unzoomedDataOffset = bwg_readOffset(ba, 16);\n        bwg.unzoomedIndexOffset = bwg_readOffset(ba, 24);\n        bwg.fieldCount = sa[16]; // 32\n        bwg.definedFieldCount = sa[17]; // 34\n        bwg.asOffset = bwg_readOffset(ba, 36);\n        bwg.totalSummaryOffset = bwg_readOffset(ba, 44);\n        bwg.uncompressBufSize = la[13]; // 52\n        bwg.extHeaderOffset = bwg_readOffset(ba, 56);\n\n        bwg.zoomLevels = [];\n        for (var zl = 0; zl < bwg.numZoomLevels; ++zl) {\n            var zlReduction = la[zl * 6 + 16];\n            var zlData = bwg_readOffset(ba, zl * 24 + 72);\n            var zlIndex = bwg_readOffset(ba, zl * 24 + 80);\n            bwg.zoomLevels.push({ reduction: zlReduction, dataOffset: zlData, indexOffset: zlIndex });\n        }\n\n        bwg.readChromTree(function () {\n            bwg.getAutoSQL(function (as) {\n                bwg.schema = as;\n                return callback(bwg);\n            });\n        });\n    }, { timeout: 5000 }); // Potential timeout on first request to catch mixed-content errors on\n    // Chromium.\n}\n\nBigWig.prototype._tsFetch = function (zoom, chr, min, max, callback) {\n    var bwg = this;\n    if (zoom >= this.zoomLevels.length - 1) {\n        if (!this.topLevelReductionCache) {\n            this.getZoomedView(this.zoomLevels.length - 1).readWigDataById(-1, 0, 300000000, function (feats) {\n                bwg.topLevelReductionCache = feats;\n                return bwg._tsFetch(zoom, chr, min, max, callback);\n            });\n        } else {\n            var f = [];\n            var c = this.topLevelReductionCache;\n            for (var fi = 0; fi < c.length; ++fi) {\n                if (c[fi]._chromId == chr) {\n                    f.push(c[fi]);\n                }\n            }\n            return callback(f);\n        }\n    } else {\n        var view;\n        if (zoom < 0) {\n            view = this.getUnzoomedView();\n        } else {\n            view = this.getZoomedView(zoom);\n        }\n        return view.readWigDataById(chr, min, max, callback);\n    }\n};\n\nBigWig.prototype.thresholdSearch = function (chrName, referencePoint, dir, threshold, callback) {\n    dir = dir < 0 ? -1 : 1;\n    var bwg = this;\n    var initialChr = this.chromsToIDs[chrName];\n    var candidates = [{ chrOrd: 0, chr: initialChr, zoom: bwg.zoomLevels.length - 4, min: 0, max: 300000000, fromRef: true }];\n    for (var i = 1; i <= this.maxID + 1; ++i) {\n        var chrId = (initialChr + dir * i) % (this.maxID + 1);\n        if (chrId < 0) chrId += this.maxID + 1;\n        candidates.push({ chrOrd: i, chr: chrId, zoom: bwg.zoomLevels.length - 1, min: 0, max: 300000000 });\n    }\n\n    function fbThresholdSearchRecur() {\n        if (candidates.length == 0) {\n            return callback(null);\n        }\n        candidates.sort(function (c1, c2) {\n            var d = c1.zoom - c2.zoom;\n            if (d != 0) return d;\n\n            d = c1.chrOrd - c2.chrOrd;\n            if (d != 0) return d;else return c1.min - c2.min * dir;\n        });\n\n        var candidate = candidates.splice(0, 1)[0];\n        bwg._tsFetch(candidate.zoom, candidate.chr, candidate.min, candidate.max, function (feats) {\n            var rp = dir > 0 ? 0 : 300000000;\n            if (candidate.fromRef) rp = referencePoint;\n\n            for (var fi = 0; fi < feats.length; ++fi) {\n                var f = feats[fi];\n                var score;\n                if (f.maxScore != undefined) score = f.maxScore;else score = f.score;\n\n                if (dir > 0) {\n                    if (score > threshold) {\n                        if (candidate.zoom < 0) {\n                            if (f.min > rp) return callback(f);\n                        } else if (f.max > rp) {\n                            candidates.push({ chr: candidate.chr, chrOrd: candidate.chrOrd, zoom: candidate.zoom - 2, min: f.min, max: f.max, fromRef: candidate.fromRef });\n                        }\n                    }\n                } else {\n                    if (score > threshold) {\n                        if (candidate.zoom < 0) {\n                            if (f.max < rp) return callback(f);\n                        } else if (f.min < rp) {\n                            candidates.push({ chr: candidate.chr, chrOrd: candidate.chrOrd, zoom: candidate.zoom - 2, min: f.min, max: f.max, fromRef: candidate.fromRef });\n                        }\n                    }\n                }\n            }\n            fbThresholdSearchRecur();\n        });\n    }\n\n    fbThresholdSearchRecur();\n};\n\nBigWig.prototype.getAutoSQL = function (callback) {\n    var thisB = this;\n    if (!this.asOffset) return callback(null);\n\n    this.data.slice(this.asOffset, 2048).fetch(function (result) {\n        var ba = new Uint8Array(result);\n        var s = '';\n        for (var i = 0; i < ba.length; ++i) {\n            if (ba[i] == 0) break;\n            s += String.fromCharCode(ba[i]);\n        }\n\n        /* \n         * Quick'n'dirty attempt to parse autoSql format.\n         * See: http://www.linuxjournal.com/files/linuxjournal.com/linuxjournal/articles/059/5949/5949l2.html\n         */\n\n        var header_re = /(\\w+)\\s+(\\w+)\\s+(\"([^\"]+)\")?\\s+\\(\\s*/;\n        var field_re = /([\\w\\[\\]]+)\\s+(\\w+)\\s*;\\s*(\"([^\"]+)\")?\\s*/g;\n\n        var headerMatch = header_re.exec(s);\n        if (headerMatch) {\n            var as = {\n                declType: headerMatch[1],\n                name: headerMatch[2],\n                comment: headerMatch[4],\n\n                fields: []\n            };\n\n            s = s.substring(headerMatch[0]);\n            for (var m = field_re.exec(s); m != null; m = field_re.exec(s)) {\n                as.fields.push({ type: m[1],\n                    name: m[2],\n                    comment: m[4] });\n            }\n\n            return callback(as);\n        }\n    });\n};\n\nBigWig.prototype.getExtraIndices = function (callback) {\n    var thisB = this;\n    if (this.version < 4 || this.extHeaderOffset == 0 || this.type != 'bigbed') {\n        return callback(null);\n    } else {\n        this.data.slice(this.extHeaderOffset, 64).fetch(function (result) {\n            if (!result) {\n                return callback(null, \"Couldn't fetch extension header\");\n            }\n\n            var ba = new Uint8Array(result);\n            var sa = new Int16Array(result);\n            var la = new Int32Array(result);\n\n            var extHeaderSize = sa[0];\n            var extraIndexCount = sa[1];\n            var extraIndexListOffset = bwg_readOffset(ba, 4);\n\n            if (extraIndexCount == 0) {\n                return callback(null);\n            }\n\n            // FIXME 20byte records only make sense for single-field indices.\n            // Right now, these seem to be the only things around, but the format\n            // is actually more general.\n            thisB.data.slice(extraIndexListOffset, extraIndexCount * 20).fetch(function (eil) {\n                if (!eil) {\n                    return callback(null, \"Couldn't fetch index info\");\n                }\n\n                var ba = new Uint8Array(eil);\n                var sa = new Int16Array(eil);\n                var la = new Int32Array(eil);\n\n                var indices = [];\n                for (var ii = 0; ii < extraIndexCount; ++ii) {\n                    var eiType = sa[ii * 10];\n                    var eiFieldCount = sa[ii * 10 + 1];\n                    var eiOffset = bwg_readOffset(ba, ii * 20 + 4);\n                    var eiField = sa[ii * 10 + 8];\n                    var index = new BBIExtraIndex(thisB, eiType, eiFieldCount, eiOffset, eiField);\n                    indices.push(index);\n                }\n                callback(indices);\n            });\n        });\n    }\n};\n\nfunction BBIExtraIndex(bbi, type, fieldCount, offset, field) {\n    this.bbi = bbi;\n    this.type = type;\n    this.fieldCount = fieldCount;\n    this.offset = offset;\n    this.field = field;\n}\n\nBBIExtraIndex.prototype.lookup = function (name, callback) {\n    var thisB = this;\n\n    this.bbi.data.slice(this.offset, 32).fetch(function (bpt) {\n        var ba = new Uint8Array(bpt);\n        var sa = new Int16Array(bpt);\n        var la = new Int32Array(bpt);\n        var bptMagic = la[0];\n        var blockSize = la[1];\n        var keySize = la[2];\n        var valSize = la[3];\n        var itemCount = bwg_readOffset(ba, 16);\n        var rootNodeOffset = 32;\n\n        function bptReadNode(nodeOffset) {\n            thisB.bbi.data.slice(nodeOffset, 4 + blockSize * (keySize + valSize)).fetch(function (node) {\n                var ba = new Uint8Array(node);\n                var sa = new Uint16Array(node);\n                var la = new Uint32Array(node);\n\n                var nodeType = ba[0];\n                var cnt = sa[1];\n\n                var offset = 4;\n                if (nodeType == 0) {\n                    var lastChildOffset = null;\n                    for (var n = 0; n < cnt; ++n) {\n                        var key = '';\n                        for (var ki = 0; ki < keySize; ++ki) {\n                            var charCode = ba[offset++];\n                            if (charCode != 0) {\n                                key += String.fromCharCode(charCode);\n                            }\n                        }\n\n                        var childOffset = bwg_readOffset(ba, offset);\n                        offset += 8;\n\n                        if (name.localeCompare(key) < 0 && lastChildOffset) {\n                            bptReadNode(lastChildOffset);\n                            return;\n                        }\n                        lastChildOffset = childOffset;\n                    }\n                    bptReadNode(lastChildOffset);\n                } else {\n                    for (var n = 0; n < cnt; ++n) {\n                        var key = '';\n                        for (var ki = 0; ki < keySize; ++ki) {\n                            var charCode = ba[offset++];\n                            if (charCode != 0) {\n                                key += String.fromCharCode(charCode);\n                            }\n                        }\n\n                        // Specific for EI case.\n                        if (key == name) {\n                            var start = bwg_readOffset(ba, offset);\n                            var length = readInt(ba, offset + 8);\n\n                            return thisB.bbi.getUnzoomedView().fetchFeatures(function (chr, min, max, toks) {\n                                if (toks && toks.length > thisB.field - 3) return toks[thisB.field - 3] == name;\n                            }, [{ offset: start, size: length }], callback);\n                        }\n                        offset += valSize;\n                    }\n                    return callback([]);\n                }\n            });\n        }\n\n        bptReadNode(thisB.offset + rootNodeOffset);\n    });\n};\n\nif (typeof module !== 'undefined') {\n    module.exports = {\n        makeBwg: makeBwg,\n        BIG_BED_MAGIC: BIG_BED_MAGIC,\n        BIG_WIG_MAGIC: BIG_WIG_MAGIC\n    };\n}\n\n},{\"./bin\":3,\"./das\":6,\"./spans\":11,\"./utils\":12,\"jszlib\":24}],3:[function(require,module,exports){\n/* -*- mode: javascript; c-basic-offset: 4; indent-tabs-mode: nil -*- */\n\n// \n// Dalliance Genome Explorer\n// (c) Thomas Down 2006-2011\n//\n// bin.js general binary data support\n//\n\n\"use strict\";\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nif (typeof require !== 'undefined') {\n    var utils = require('./utils');\n    var shallowCopy = utils.shallowCopy;\n\n    var sha1 = require('./sha1');\n    var b64_sha1 = sha1.b64_sha1;\n\n    var Promise = require('es6-promise').Promise;\n}\n\nfunction BlobFetchable(b) {\n    this.blob = b;\n}\n\nBlobFetchable.prototype.slice = function (start, length) {\n    var b;\n\n    if (this.blob.slice) {\n        if (length) {\n            b = this.blob.slice(start, start + length);\n        } else {\n            b = this.blob.slice(start);\n        }\n    } else {\n        if (length) {\n            b = this.blob.webkitSlice(start, start + length);\n        } else {\n            b = this.blob.webkitSlice(start);\n        }\n    }\n    return new BlobFetchable(b);\n};\n\nBlobFetchable.prototype.salted = function () {\n    return this;\n};\n\nif (typeof FileReader !== 'undefined') {\n    // console.log('defining async BlobFetchable.fetch');\n\n    BlobFetchable.prototype.fetch = function (callback) {\n        var reader = new FileReader();\n        reader.onloadend = function (ev) {\n            callback(bstringToBuffer(reader.result));\n        };\n        reader.readAsBinaryString(this.blob);\n    };\n} else {\n    // if (console && console.log)\n    //    console.log('defining sync BlobFetchable.fetch');\n\n    BlobFetchable.prototype.fetch = function (callback) {\n        var reader = new FileReaderSync();\n        try {\n            var res = reader.readAsArrayBuffer(this.blob);\n            callback(res);\n        } catch (e) {\n            callback(null, e);\n        }\n    };\n}\n\nfunction URLFetchable(url, start, end, opts) {\n    if (!opts) {\n        if ((typeof start === 'undefined' ? 'undefined' : _typeof(start)) === 'object') {\n            opts = start;\n            start = undefined;\n        } else {\n            opts = {};\n        }\n    }\n\n    this.url = url;\n    this.start = start || 0;\n    if (end) {\n        this.end = end;\n    }\n    this.opts = opts;\n}\n\nURLFetchable.prototype.slice = function (s, l) {\n    if (s < 0) {\n        throw 'Bad slice ' + s;\n    }\n\n    var ns = this.start,\n        ne = this.end;\n    if (ns && s) {\n        ns = ns + s;\n    } else {\n        ns = s || ns;\n    }\n    if (l && ns) {\n        ne = ns + l - 1;\n    } else {\n        ne = ne || l - 1;\n    }\n    return new URLFetchable(this.url, ns, ne, this.opts);\n};\n\nvar seed = 0;\nvar isSafari = typeof navigator !== 'undefined' && navigator.userAgent.indexOf('Safari') >= 0 && navigator.userAgent.indexOf('Chrome') < 0;\n\nURLFetchable.prototype.fetchAsText = function (callback) {\n    var thisB = this;\n\n    this.getURL().then(function (url) {\n        try {\n            var req = new XMLHttpRequest();\n            var length;\n            if ((isSafari || thisB.opts.salt) && url.indexOf('?') < 0) {\n                url = url + '?salt=' + b64_sha1('' + Date.now() + ',' + ++seed);\n            }\n            req.open('GET', url, true);\n\n            if (thisB.end) {\n                if (thisB.end - thisB.start > 100000000) {\n                    throw 'Monster fetch!';\n                }\n                req.setRequestHeader('Range', 'bytes=' + thisB.start + '-' + thisB.end);\n                length = thisB.end - thisB.start + 1;\n            }\n\n            req.onreadystatechange = function () {\n                if (req.readyState == 4) {\n                    if (req.status == 200 || req.status == 206) {\n                        return callback(req.responseText);\n                    } else {\n                        return callback(null);\n                    }\n                }\n            };\n            if (thisB.opts.credentials) {\n                req.withCredentials = true;\n            }\n            req.send();\n        } catch (e) {\n            return callback(null);\n        }\n    }).catch(function (err) {\n        console.log(err);\n        return callback(null, err);\n    });\n};\n\nURLFetchable.prototype.salted = function () {\n    var o = shallowCopy(this.opts);\n    o.salt = true;\n    return new URLFetchable(this.url, this.start, this.end, o);\n};\n\nURLFetchable.prototype.getURL = function () {\n    if (this.opts.resolver) {\n        return this.opts.resolver(this.url).then(function (urlOrObj) {\n            if (typeof urlOrObj === 'string') {\n                return urlOrObj;\n            } else {\n                return urlOrObj.url;\n            }\n        });\n    } else {\n        return Promise.resolve(this.url);\n    }\n};\n\nURLFetchable.prototype.fetch = function (callback, opts) {\n    var thisB = this;\n\n    opts = opts || {};\n    var attempt = opts.attempt || 1;\n    var truncatedLength = opts.truncatedLength;\n    if (attempt > 3) {\n        return callback(null);\n    }\n\n    this.getURL().then(function (url) {\n        try {\n            var timeout;\n            if (opts.timeout && !thisB.opts.credentials) {\n                timeout = setTimeout(function () {\n                    console.log('timing out ' + url);\n                    req.abort();\n                    return callback(null, 'Timeout');\n                }, opts.timeout);\n            }\n\n            var req = new XMLHttpRequest();\n            var length;\n            if ((isSafari || thisB.opts.salt) && url.indexOf('?') < 0) {\n                url = url + '?salt=' + b64_sha1('' + Date.now() + ',' + ++seed);\n            }\n            req.open('GET', url, true);\n            req.overrideMimeType('text/plain; charset=x-user-defined');\n            if (thisB.end) {\n                if (thisB.end - thisB.start > 100000000) {\n                    throw 'Monster fetch!';\n                }\n                req.setRequestHeader('Range', 'bytes=' + thisB.start + '-' + thisB.end);\n                length = thisB.end - thisB.start + 1;\n            }\n            req.responseType = 'arraybuffer';\n            req.onreadystatechange = function () {\n                if (req.readyState == 4) {\n                    if (timeout) clearTimeout(timeout);\n                    if (req.status == 200 || req.status == 206) {\n                        if (req.response) {\n                            var bl = req.response.byteLength;\n                            if (length && length != bl && (!truncatedLength || bl != truncatedLength)) {\n                                return thisB.fetch(callback, { attempt: attempt + 1, truncatedLength: bl });\n                            } else {\n                                return callback(req.response);\n                            }\n                        } else if (req.mozResponseArrayBuffer) {\n                            return callback(req.mozResponseArrayBuffer);\n                        } else {\n                            var r = req.responseText;\n                            if (length && length != r.length && (!truncatedLength || r.length != truncatedLength)) {\n                                return thisB.fetch(callback, { attempt: attempt + 1, truncatedLength: r.length });\n                            } else {\n                                return callback(bstringToBuffer(req.responseText));\n                            }\n                        }\n                    } else {\n                        return thisB.fetch(callback, { attempt: attempt + 1 });\n                    }\n                }\n            };\n            if (thisB.opts.credentials) {\n                req.withCredentials = true;\n            }\n            req.send();\n        } catch (e) {\n            return callback(null);\n        }\n    }).catch(function (err) {\n        console.log(err);\n        return callback(null, err);\n    });\n};\n\nfunction bstringToBuffer(result) {\n    if (!result) {\n        return null;\n    }\n\n    var ba = new Uint8Array(result.length);\n    for (var i = 0; i < ba.length; ++i) {\n        ba[i] = result.charCodeAt(i);\n    }\n    return ba.buffer;\n}\n\n// Read from Uint8Array\n\nvar convertBuffer = new ArrayBuffer(8);\nvar ba = new Uint8Array(convertBuffer);\nvar fa = new Float32Array(convertBuffer);\n\nfunction readFloat(buf, offset) {\n    ba[0] = buf[offset];\n    ba[1] = buf[offset + 1];\n    ba[2] = buf[offset + 2];\n    ba[3] = buf[offset + 3];\n    return fa[0];\n}\n\nfunction readInt64(ba, offset) {\n    return ba[offset + 7] << 24 | ba[offset + 6] << 16 | ba[offset + 5] << 8 | ba[offset + 4];\n}\n\nfunction readInt(ba, offset) {\n    return ba[offset + 3] << 24 | ba[offset + 2] << 16 | ba[offset + 1] << 8 | ba[offset];\n}\n\nfunction readShort(ba, offset) {\n    return ba[offset + 1] << 8 | ba[offset];\n}\n\nfunction readByte(ba, offset) {\n    return ba[offset];\n}\n\nfunction readIntBE(ba, offset) {\n    return ba[offset] << 24 | ba[offset + 1] << 16 | ba[offset + 2] << 8 | ba[offset + 3];\n}\n\n// Exports if we are being used as a module\n\nif (typeof module !== 'undefined') {\n    module.exports = {\n        BlobFetchable: BlobFetchable,\n        URLFetchable: URLFetchable,\n\n        readInt: readInt,\n        readIntBE: readIntBE,\n        readInt64: readInt64,\n        readShort: readShort,\n        readByte: readByte,\n        readFloat: readFloat\n    };\n}\n\n},{\"./sha1\":10,\"./utils\":12,\"es6-promise\":13}],4:[function(require,module,exports){\n/* -*- mode: javascript; c-basic-offset: 4; indent-tabs-mode: nil -*- */\n\n// \n// Dalliance Genome Explorer\n// (c) Thomas Down 2006-2010\n//\n// color.js\n//\n\n\"use strict\";\n\nfunction DColour(red, green, blue, name) {\n    this.red = red | 0;\n    this.green = green | 0;\n    this.blue = blue | 0;\n    if (name) {\n        this.name = name;\n    }\n}\n\nDColour.prototype.toSvgString = function () {\n    if (!this.name) {\n        this.name = \"rgb(\" + this.red + \",\" + this.green + \",\" + this.blue + \")\";\n    }\n\n    return this.name;\n};\n\nfunction hex2(x) {\n    var y = '00' + x.toString(16);\n    return y.substring(y.length - 2);\n}\n\nDColour.prototype.toHexString = function () {\n    return '#' + hex2(this.red) + hex2(this.green) + hex2(this.blue);\n};\n\nvar palette = {\n    red: new DColour(255, 0, 0, 'red'),\n    green: new DColour(0, 255, 0, 'green'),\n    blue: new DColour(0, 0, 255, 'blue'),\n    yellow: new DColour(255, 255, 0, 'yellow'),\n    white: new DColour(255, 255, 255, 'white'),\n    black: new DColour(0, 0, 0, 'black'),\n    gray: new DColour(180, 180, 180, 'gray'),\n    grey: new DColour(180, 180, 180, 'grey'),\n    lightskyblue: new DColour(135, 206, 250, 'lightskyblue'),\n    lightsalmon: new DColour(255, 160, 122, 'lightsalmon'),\n    hotpink: new DColour(255, 105, 180, 'hotpink')\n};\n\nvar COLOR_RE = new RegExp('^#([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})$');\nvar CSS_COLOR_RE = /rgb\\(([0-9]+),([0-9]+),([0-9]+)\\)/;\n\nfunction dasColourForName(name) {\n    var c = palette[name];\n    if (!c) {\n        var match = COLOR_RE.exec(name);\n        if (match) {\n            c = new DColour('0x' + match[1] | 0, '0x' + match[2] | 0, '0x' + match[3] | 0, name);\n            palette[name] = c;\n        } else {\n            match = CSS_COLOR_RE.exec(name);\n            if (match) {\n                c = new DColour(match[1] | 0, match[2] | 0, match[3] | 0, name);\n                palette[name] = c;\n            } else {\n                console.log(\"couldn't handle color: \" + name);\n                c = palette.black;\n                palette[name] = c;\n            }\n        }\n    }\n    return c;\n}\n\nfunction makeColourSteps(steps, stops, colours) {\n    var dcolours = [];\n    for (var ci = 0; ci < colours.length; ++ci) {\n        dcolours.push(dasColourForName(colours[ci]));\n    }\n\n    var grad = [];\n    STEP_LOOP: for (var si = 0; si < steps; ++si) {\n        var rs = 1.0 * si / (steps - 1);\n        var score = stops[0] + (stops[stops.length - 1] - stops[0]) * rs;\n        for (var i = 0; i < stops.length - 1; ++i) {\n            if (score >= stops[i] && score <= stops[i + 1]) {\n                var frac = (score - stops[i]) / (stops[i + 1] - stops[i]);\n                var ca = dcolours[i];\n                var cb = dcolours[i + 1];\n\n                var fill = new DColour(ca.red * (1.0 - frac) + cb.red * frac | 0, ca.green * (1.0 - frac) + cb.green * frac | 0, ca.blue * (1.0 - frac) + cb.blue * frac | 0).toSvgString();\n                grad.push(fill);\n\n                continue STEP_LOOP;\n            }\n        }\n        throw 'Bad step';\n    }\n\n    return grad;\n}\n\nfunction makeGradient(steps, color1, color2, color3) {\n    if (color3) {\n        return makeColourSteps(steps, [0, 0.5, 1], [color1, color2, color3]);\n    } else {\n        return makeColourSteps(steps, [0, 1], [color1, color2]);\n    }\n}\n\nif (typeof module !== 'undefined') {\n    module.exports = {\n        makeColourSteps: makeColourSteps,\n        makeGradient: makeGradient,\n        dasColourForName: dasColourForName\n    };\n}\n\n},{}],5:[function(require,module,exports){\n/* -*- mode: javascript; c-basic-offset: 4; indent-tabs-mode: nil -*- */\n\n// \n// Dalliance Genome Explorer\n// (c) Thomas Down 2006-2011\n//\n// cram.js: indexed binary alignments\n//\n\n\"use strict\";\n\nif (typeof require !== 'undefined') {\n    var spans = require('./spans');\n    var Range = spans.Range;\n    var union = spans.union;\n    var intersection = spans.intersection;\n\n    var bin = require('./bin');\n    var readInt = bin.readInt;\n    var readShort = bin.readShort;\n    var readByte = bin.readByte;\n    var readInt64 = bin.readInt64;\n    var readFloat = bin.readFloat;\n\n    var lh3utils = require('./lh3utils');\n    var readVob = lh3utils.readVob;\n    var unbgzf = lh3utils.unbgzf;\n    var reg2bins = lh3utils.reg2bins;\n    var Chunk = lh3utils.Chunk;\n\n    var jszlib = require('jszlib');\n}\n\nvar CRAM_MAGIC = 0x14d4142;\nvar CRAI_MAGIC = 0x88B1F;\n\nvar CramFlags = {\n    MULTIPLE_SEGMENTS: 0x1,\n    ALL_SEGMENTS_ALIGN: 0x2,\n    SEGMENT_UNMAPPED: 0x4,\n    NEXT_SEGMENT_UNMAPPED: 0x8,\n    REVERSE_COMPLEMENT: 0x10,\n    NEXT_REVERSE_COMPLEMENT: 0x20,\n    FIRST_SEGMENT: 0x40,\n    LAST_SEGMENT: 0x80,\n    SECONDARY_ALIGNMENT: 0x100,\n    QC_FAIL: 0x200,\n    DUPLICATE: 0x400,\n    SUPPLEMENTARY: 0x800\n};\n\nfunction CramFile() {}\n\n// Calculate the length (in bytes) of the CRAI ref starting at offset.\n// Returns {nbin, length, minBlockIndex}\nfunction _getCraiRefLength(uncba, offset) {\n    var p = offset;\n    var nbin = readInt(uncba, p);p += 4;\n    for (var b = 0; b < nbin; ++b) {\n        var bin = readInt(uncba, p);\n        var nchnk = readInt(uncba, p + 4);\n        p += 8 + nchnk * 16;\n    }\n    var nintv = readInt(uncba, p);p += 4;\n\n    var minBlockIndex = 1000000000;\n    var q = p;\n    for (var i = 0; i < nintv; ++i) {\n        var v = readVob(uncba, q);q += 8;\n        if (v) {\n            var bi = v.block;\n            if (v.offset > 0) bi += 65536;\n\n            if (bi < minBlockIndex) minBlockIndex = bi;\n            break;\n        }\n    }\n    p += nintv * 8;\n\n    return {\n        minBlockIndex: minBlockIndex,\n        nbin: nbin,\n        length: p - offset\n    };\n}\n\nfunction makeCram(data, crai, indexChunks, callback, attempted) {\n    // Do an initial probe on the CRAM file to catch any mixed-content errors.\n    data.slice(0, 10).fetch(function (header) {\n        if (header) {\n            return makeCram2(data, crai, indexChunks, callback, attempted);\n        } else {\n            return callback(null, \"Couldn't access CRAM.\");\n        }\n    }, { timeout: 5000 });\n}\n\nfunction makeCram2(data, crai, indexChunks, callback, attempted) {\n    var cram = new CramFile();\n    cram.data = data;\n    cram.crai = crai;\n    cram.indexChunks = indexChunks;\n\n    var minBlockIndex = cram.indexChunks ? cram.indexChunks.minBlockIndex : 1000000000;\n\n    // Fills out cram.chrToIndex and cram.indexToChr based on the first few bytes of the CRAM.\n    function parseCramHeader(r) {\n        if (!r) {\n            return callback(null, \"Couldn't access CRAM\");\n        }\n\n        var unc = unbgzf(r, r.byteLength);\n        var uncba = new Uint8Array(unc);\n\n        var magic = readInt(uncba, 0);\n        if (magic != CRAM_MAGIC) {\n            return callback(null, \"Not a CRAM file, magic=0x\" + magic.toString(16));\n        }\n        var headLen = readInt(uncba, 4);\n        var header = '';\n        for (var i = 0; i < headLen; ++i) {\n            header += String.fromCharCode(uncba[i + 8]);\n        }\n\n        var nRef = readInt(uncba, headLen + 8);\n        var p = headLen + 12;\n\n        cram.chrToIndex = {};\n        cram.indexToChr = [];\n        for (var i = 0; i < nRef; ++i) {\n            var lName = readInt(uncba, p);\n            var name = '';\n            for (var j = 0; j < lName - 1; ++j) {\n                name += String.fromCharCode(uncba[p + 4 + j]);\n            }\n            var lRef = readInt(uncba, p + lName + 4);\n            cram.chrToIndex[name] = i;\n            if (name.indexOf('chr') == 0) {\n                cram.chrToIndex[name.substring(3)] = i;\n            } else {\n                cram.chrToIndex['chr' + name] = i;\n            }\n            cram.indexToChr.push(name);\n\n            p = p + 8 + lName;\n        }\n\n        if (cram.indices) {\n            return callback(cram);\n        }\n    }\n\n    function parseCrai(header) {\n        if (!header) {\n            return \"Couldn't access CRAI\";\n        }\n\n        var uncba = new Uint8Array(header);\n\n        var craiMagic = readInt(uncba, 0);\n        if (craiMagic != CRAI_MAGIC) {\n            return callback(null, 'Not a CRAI file, magic=0x' + craiMagic.toString(16));\n        }\n\n        var offset = 10;\n        var unc = jszlib.inflateBuffer(header, offset, header.byteLength - offset);\n        var s = '';\n        var resultBB = new Uint8Array(unc);\n        for (var i = 0; i < resultBB.length; ++i) {\n            s += String.fromCharCode(resultBB[i]);\n        }\n        console.log(s);\n\n        cram.indices = [];\n\n        var p = 8;\n        for (var ref = 0; ref < nref; ++ref) {\n            var blockStart = p;\n            var o = _getCraiRefLength(uncba, blockStart);\n            p += o.length;\n\n            minBlockIndex = Math.min(o.minBlockIndex, minBlockIndex);\n\n            var nbin = o.nbin;\n\n            if (nbin > 0) {\n                cram.indices[ref] = new Uint8Array(header, blockStart, p - blockStart);\n            }\n        }\n\n        return true;\n    }\n\n    if (!cram.indexChunks) {\n        cram.crai.fetch(function (header) {\n            // Do we really need to fetch the whole thing? :-(\n            var result = parseCrai(header);\n            if (result !== true) {\n                if (cram.crai.url && typeof attempted === \"undefined\") {\n                    // Already attempted x.cram.crai not there so now trying x.crai\n                    cram.crai.url = cram.data.url.replace(new RegExp('.cram$'), '.crai');\n\n                    // True lets us know we are making a second attempt\n                    makeCram2(data, cram.crai, indexChunks, callback, true);\n                } else {\n                    // We've attempted x.cram.crai & x.crai and nothing worked\n                    callback(null, result);\n                }\n            } else {\n                cram.data.slice(0, minBlockIndex).fetch(parseCramHeader);\n            }\n        }); // Timeout on first request to catch Chrome mixed-content error.\n    } else {\n        var chunks = cram.indexChunks.chunks;\n        cram.indices = [];\n        for (var i = 0; i < chunks.length; i++) {\n            cram.indices[i] = null; // To be filled out lazily as needed\n        }\n        cram.data.slice(0, minBlockIndex).fetch(parseCramHeader);\n    }\n}\n\nCramFile.prototype.blocksForRange = function (refId, min, max) {\n    var index = this.indices[refId];\n    if (!index) {\n        return [];\n    }\n\n    var intBinsL = reg2bins(min, max);\n    var intBins = [];\n    for (var i = 0; i < intBinsL.length; ++i) {\n        intBins[intBinsL[i]] = true;\n    }\n    var leafChunks = [],\n        otherChunks = [];\n\n    var nbin = readInt(index, 0);\n    var p = 4;\n    for (var b = 0; b < nbin; ++b) {\n        var bin = readInt(index, p);\n        var nchnk = readInt(index, p + 4);\n        //        dlog('bin=' + bin + '; nchnk=' + nchnk);\n        p += 8;\n        if (intBins[bin]) {\n            for (var c = 0; c < nchnk; ++c) {\n                var cs = readVob(index, p);\n                var ce = readVob(index, p + 8);\n                (bin < 4681 ? otherChunks : leafChunks).push(new Chunk(cs, ce));\n                p += 16;\n            }\n        } else {\n            p += nchnk * 16;\n        }\n    }\n    // console.log('leafChunks = ' + JSON.stringify(leafChunks));\n    // console.log('otherChunks = ' + JSON.stringify(otherChunks));\n\n    var nintv = readInt(index, p);\n    // console.log('nintv=' + nintv);\n    var lowest = null;\n    var minLin = Math.min(min >> 14, nintv - 1),\n        maxLin = Math.min(max >> 14, nintv - 1);\n    for (var i = minLin; i <= maxLin; ++i) {\n        var lb = readVob(index, p + 4 + i * 8);\n        if (!lb) {\n            continue;\n        }\n        if (!lowest || lb.block < lowest.block || lb.block == lowest.block && lb.offset < lowest.offset) {\n            lowest = lb;\n        }\n    }\n    // console.log('Lowest LB = ' + lowest);\n\n    var prunedOtherChunks = [];\n    if (lowest != null) {\n        for (var i = 0; i < otherChunks.length; ++i) {\n            var chnk = otherChunks[i];\n            if (chnk.maxv.block > lowest.block || chnk.maxv.block == lowest.block && chnk.maxv.offset >= lowest.offset) {\n                prunedOtherChunks.push(chnk);\n            }\n        }\n    }\n    // console.log('prunedOtherChunks = ' + JSON.stringify(prunedOtherChunks));\n    otherChunks = prunedOtherChunks;\n\n    var intChunks = [];\n    for (var i = 0; i < otherChunks.length; ++i) {\n        intChunks.push(otherChunks[i]);\n    }\n    for (var i = 0; i < leafChunks.length; ++i) {\n        intChunks.push(leafChunks[i]);\n    }\n\n    intChunks.sort(function (c0, c1) {\n        var dif = c0.minv.block - c1.minv.block;\n        if (dif != 0) {\n            return dif;\n        } else {\n            return c0.minv.offset - c1.minv.offset;\n        }\n    });\n    var mergedChunks = [];\n    if (intChunks.length > 0) {\n        var cur = intChunks[0];\n        for (var i = 1; i < intChunks.length; ++i) {\n            var nc = intChunks[i];\n            if (nc.minv.block == cur.maxv.block /* && nc.minv.offset == cur.maxv.offset */) {\n                    // no point splitting mid-block\n                    cur = new Chunk(cur.minv, nc.maxv);\n                } else {\n                mergedChunks.push(cur);\n                cur = nc;\n            }\n        }\n        mergedChunks.push(cur);\n    }\n    // console.log('mergedChunks = ' + JSON.stringify(mergedChunks));\n\n    return mergedChunks;\n};\n\nCramFile.prototype.fetch = function (chr, min, max, callback, opts) {\n    var thisB = this;\n    opts = opts || {};\n\n    var chrId = this.chrToIndex[chr];\n    var chunks;\n    if (chrId === undefined) {\n        chunks = [];\n    } else {\n        // Fetch this portion of the CRAI if it hasn't been loaded yet.\n        if (this.indices[chrId] === null && this.indexChunks.chunks[chrId]) {\n            var start_stop = this.indexChunks.chunks[chrId];\n            return this.crai.slice(start_stop[0], start_stop[1]).fetch(function (data) {\n                var buffer = new Uint8Array(data);\n                this.indices[chrId] = buffer;\n                return this.fetch(chr, min, max, callback, opts);\n            }.bind(this));\n        }\n\n        chunks = this.blocksForRange(chrId, min, max);\n        if (!chunks) {\n            callback(null, 'Error in index fetch');\n        }\n    }\n\n    var records = [];\n    var index = 0;\n    var data;\n\n    function tramp() {\n        if (index >= chunks.length) {\n            return callback(records);\n        } else if (!data) {\n            var c = chunks[index];\n            var fetchMin = c.minv.block;\n            var fetchMax = c.maxv.block + (1 << 16); // *sigh*\n            // console.log('fetching ' + fetchMin + ':' + fetchMax);\n            thisB.data.slice(fetchMin, fetchMax - fetchMin).fetch(function (r) {\n                data = unbgzf(r, c.maxv.block - c.minv.block + 1);\n                return tramp();\n            });\n        } else {\n            var ba = new Uint8Array(data);\n            var finished = thisB.readCramRecords(ba, chunks[index].minv.offset, records, min, max, chrId, opts);\n            data = null;\n            ++index;\n            if (finished) return callback(records);else return tramp();\n        }\n    }\n    tramp();\n};\n\nvar SEQRET_DECODER = ['=', 'A', 'C', 'x', 'G', 'x', 'x', 'x', 'T', 'x', 'x', 'x', 'x', 'x', 'x', 'N'];\nvar CIGAR_DECODER = ['M', 'I', 'D', 'N', 'S', 'H', 'P', '=', 'X', '?', '?', '?', '?', '?', '?', '?'];\n\nfunction CramRecord() {}\n\nCramFile.prototype.readCramRecords = function (ba, offset, sink, min, max, chrId, opts) {\n    while (true) {\n        var blockSize = readInt(ba, offset);\n        var blockEnd = offset + blockSize + 4;\n        if (blockEnd > ba.length) {\n            return false;\n        }\n\n        var record = new CramRecord();\n\n        var refID = readInt(ba, offset + 4);\n        var pos = readInt(ba, offset + 8);\n\n        var bmn = readInt(ba, offset + 12);\n        var bin = (bmn & 0xffff0000) >> 16;\n        var mq = (bmn & 0xff00) >> 8;\n        var nl = bmn & 0xff;\n\n        var flag_nc = readInt(ba, offset + 16);\n        var flag = (flag_nc & 0xffff0000) >> 16;\n        var nc = flag_nc & 0xffff;\n\n        var lseq = readInt(ba, offset + 20);\n\n        var nextRef = readInt(ba, offset + 24);\n        var nextPos = readInt(ba, offset + 28);\n\n        var tlen = readInt(ba, offset + 32);\n\n        record.segment = this.indexToChr[refID];\n        record.flag = flag;\n        record.pos = pos;\n        record.mq = mq;\n        if (opts.light) record.seqLength = lseq;\n\n        if (!opts.light || opts.includeName) {\n            var readName = '';\n            for (var j = 0; j < nl - 1; ++j) {\n                readName += String.fromCharCode(ba[offset + 36 + j]);\n            }\n            record.readName = readName;\n        }\n\n        if (!opts.light) {\n            if (nextRef >= 0) {\n                record.nextSegment = this.indexToChr[nextRef];\n                record.nextPos = nextPos;\n            }\n\n            var p = offset + 36 + nl;\n\n            var cigar = '';\n            for (var c = 0; c < nc; ++c) {\n                var cigop = readInt(ba, p);\n                cigar = cigar + (cigop >> 4) + CIGAR_DECODER[cigop & 0xf];\n                p += 4;\n            }\n            record.cigar = cigar;\n\n            var seq = '';\n            var seqBytes = lseq + 1 >> 1;\n            for (var j = 0; j < seqBytes; ++j) {\n                var sb = ba[p + j];\n                seq += SEQRET_DECODER[(sb & 0xf0) >> 4];\n                if (seq.length < lseq) seq += SEQRET_DECODER[sb & 0x0f];\n            }\n            p += seqBytes;\n            record.seq = seq;\n\n            var qseq = '';\n            for (var j = 0; j < lseq; ++j) {\n                qseq += String.fromCharCode(ba[p + j] + 33);\n            }\n            p += lseq;\n            record.quals = qseq;\n\n            while (p < blockEnd) {\n                var tag = String.fromCharCode(ba[p], ba[p + 1]);\n                var type = String.fromCharCode(ba[p + 2]);\n                var value;\n\n                if (type == 'A') {\n                    value = String.fromCharCode(ba[p + 3]);\n                    p += 4;\n                } else if (type == 'i' || type == 'I') {\n                    value = readInt(ba, p + 3);\n                    p += 7;\n                } else if (type == 'c' || type == 'C') {\n                    value = ba[p + 3];\n                    p += 4;\n                } else if (type == 's' || type == 'S') {\n                    value = readShort(ba, p + 3);\n                    p += 5;\n                } else if (type == 'f') {\n                    value = readFloat(ba, p + 3);\n                    p += 7;\n                } else if (type == 'Z' || type == 'H') {\n                    p += 3;\n                    value = '';\n                    for (;;) {\n                        var cc = ba[p++];\n                        if (cc == 0) {\n                            break;\n                        } else {\n                            value += String.fromCharCode(cc);\n                        }\n                    }\n                } else if (type == 'B') {\n                    var atype = String.fromCharCode(ba[p + 3]);\n                    var alen = readInt(ba, p + 4);\n                    var elen;\n                    var reader;\n                    if (atype == 'i' || atype == 'I' || atype == 'f') {\n                        elen = 4;\n                        if (atype == 'f') reader = readFloat;else reader = readInt;\n                    } else if (atype == 's' || atype == 'S') {\n                        elen = 2;\n                        reader = readShort;\n                    } else if (atype == 'c' || atype == 'C') {\n                        elen = 1;\n                        reader = readByte;\n                    } else {\n                        throw 'Unknown array type ' + atype;\n                    }\n\n                    p += 8;\n                    value = [];\n                    for (var i = 0; i < alen; ++i) {\n                        value.push(reader(ba, p));\n                        p += elen;\n                    }\n                } else {\n                    throw 'Unknown type ' + type;\n                }\n                record[tag] = value;\n            }\n        }\n\n        if (!min || record.pos <= max && record.pos + lseq >= min) {\n            if (chrId === undefined || refID == chrId) {\n                sink.push(record);\n            }\n        }\n        if (record.pos > max) {\n            return true;\n        }\n        offset = blockEnd;\n    }\n\n    // Exits via top of loop.\n};\n\nif (typeof module !== 'undefined') {\n    module.exports = {\n        makeCram: makeCram,\n        CRAM_MAGIC: CRAM_MAGIC,\n        CRAI_MAGIC: CRAI_MAGIC,\n        CramFlags: CramFlags\n    };\n}\n\n},{\"./bin\":3,\"./lh3utils\":9,\"./spans\":11,\"jszlib\":24}],6:[function(require,module,exports){\n/* -*- mode: javascript; c-basic-offset: 4; indent-tabs-mode: nil -*- */\n\n// \n// Dalliance Genome Explorer\n// (c) Thomas Down 2006-2010\n//\n// das.js: queries and low-level data model.\n//\n\n\"use strict\";\n\nif (typeof require !== 'undefined') {\n    var utils = require('./utils');\n    var shallowCopy = utils.shallowCopy;\n    var pusho = utils.pusho;\n\n    var color = require('./color');\n    var makeColourSteps = color.makeColourSteps;\n}\n\nvar dasLibErrorHandler = function dasLibErrorHandler(errMsg) {\n    alert(errMsg);\n};\nvar dasLibRequestQueue = new Array();\n\nfunction DASSegment(name, start, end, description) {\n    this.name = name;\n    this.start = start;\n    this.end = end;\n    this.description = description;\n}\nDASSegment.prototype.toString = function () {\n    return this.name + ':' + this.start + '..' + this.end;\n};\nDASSegment.prototype.isBounded = function () {\n    return this.start && this.end;\n};\nDASSegment.prototype.toDASQuery = function () {\n    var q = 'segment=' + this.name;\n    if (this.start && this.end) {\n        q += ':' + this.start + ',' + this.end;\n    }\n    return q;\n};\n\nfunction DASSource(a1, a2) {\n    var options;\n    if (typeof a1 == 'string') {\n        this.uri = a1;\n        options = a2 || {};\n    } else {\n        options = a1 || {};\n    }\n    for (var k in options) {\n        this[k] = options[k];\n    }\n\n    if (!this.coords) {\n        this.coords = [];\n    }\n    if (!this.props) {\n        this.props = {};\n    }\n\n    this.dasBaseURI = this.uri;\n    if (this.dasBaseURI && this.dasBaseURI.substr(this.uri.length - 1) != '/') {\n        this.dasBaseURI = this.dasBaseURI + '/';\n    }\n}\n\nDASSource.prototype.getURI = function (uri) {\n    if (this.resolver) {\n        return this.resolver(uri).then(function (urlOrObj) {\n            if (typeof urlOrObj === 'string') {\n                return urlOrObj;\n            } else {\n                return urlOrObj.url;\n            }\n        });\n    } else {\n        return Promise.resolve(uri);\n    }\n};\n\nfunction DASCoords() {}\n\nfunction coordsMatch(c1, c2) {\n    return c1.taxon == c2.taxon && c1.auth == c2.auth && c1.version == c2.version;\n}\n\n//\n// DAS 1.6 entry_points command\n//\n\nDASSource.prototype.entryPoints = function (callback) {\n    var dasURI = this.dasBaseURI + 'entry_points';\n    this.doCrossDomainRequest(dasURI, function (responseXML) {\n        if (!responseXML) {\n            return callback([]);\n        }\n\n        var entryPoints = new Array();\n\n        var segs = responseXML.getElementsByTagName('SEGMENT');\n        for (var i = 0; i < segs.length; ++i) {\n            var seg = segs[i];\n            var segId = seg.getAttribute('id');\n\n            var segSize = seg.getAttribute('size');\n            var segMin, segMax;\n            if (segSize) {\n                segMin = 1;segMax = segSize | 0;\n            } else {\n                segMin = seg.getAttribute('start');\n                if (segMin) {\n                    segMin |= 0;\n                }\n                segMax = seg.getAttribute('stop');\n                if (segMax) {\n                    segMax |= 0;\n                }\n            }\n            var segDesc = null;\n            if (seg.firstChild) {\n                segDesc = seg.firstChild.nodeValue;\n            }\n            entryPoints.push(new DASSegment(segId, segMin, segMax, segDesc));\n        }\n        callback(entryPoints);\n    });\n};\n\n//\n// DAS 1.6 sequence command\n// Do we need an option to fall back to the dna command?\n//\n\nfunction DASSequence(name, start, end, alpha, seq) {\n    this.name = name;\n    this.start = start;\n    this.end = end;\n    this.alphabet = alpha;\n    this.seq = seq;\n}\n\nDASSource.prototype.sequence = function (segment, callback) {\n    var dasURI = this.dasBaseURI + 'sequence?' + segment.toDASQuery();\n    this.doCrossDomainRequest(dasURI, function (responseXML) {\n        if (!responseXML) {\n            callback([]);\n            return;\n        } else {\n            var seqs = new Array();\n\n            var segs = responseXML.getElementsByTagName('SEQUENCE');\n            for (var i = 0; i < segs.length; ++i) {\n                var seg = segs[i];\n                var segId = seg.getAttribute('id');\n                var segMin = seg.getAttribute('start');\n                var segMax = seg.getAttribute('stop');\n                var segAlpha = 'DNA';\n                var segSeq = null;\n                if (seg.firstChild) {\n                    var rawSeq = seg.firstChild.nodeValue;\n                    segSeq = '';\n                    var idx = 0;\n                    while (true) {\n                        var space = rawSeq.indexOf('\\n', idx);\n                        if (space >= 0) {\n                            segSeq += rawSeq.substring(idx, space).toUpperCase();\n                            idx = space + 1;\n                        } else {\n                            segSeq += rawSeq.substring(idx).toUpperCase();\n                            break;\n                        }\n                    }\n                }\n                seqs.push(new DASSequence(segId, segMin, segMax, segAlpha, segSeq));\n            }\n\n            callback(seqs);\n        }\n    });\n};\n\n//\n// DAS 1.6 features command\n//\n\nfunction DASFeature() {}\n\nfunction DASGroup(id) {\n    if (id) this.id = id;\n}\n\nfunction DASLink(desc, uri) {\n    this.desc = desc;\n    this.uri = uri;\n}\n\nDASSource.prototype.features = function (segment, options, callback) {\n    options = options || {};\n    var thisB = this;\n\n    var dasURI;\n    if (this.features_uri) {\n        dasURI = this.features_uri;\n    } else {\n        var filters = [];\n\n        if (segment) {\n            filters.push(segment.toDASQuery());\n        } else if (options.group) {\n            var g = options.group;\n            if (typeof g == 'string') {\n                filters.push('group_id=' + g);\n            } else {\n                for (var gi = 0; gi < g.length; ++gi) {\n                    filters.push('group_id=' + g[gi]);\n                }\n            }\n        }\n\n        if (options.adjacent) {\n            var adj = options.adjacent;\n            if (typeof adj == 'string') {\n                adj = [adj];\n            }\n            for (var ai = 0; ai < adj.length; ++ai) {\n                filters.push('adjacent=' + adj[ai]);\n            }\n        }\n\n        if (options.type) {\n            if (typeof options.type == 'string') {\n                filters.push('type=' + options.type);\n            } else {\n                for (var ti = 0; ti < options.type.length; ++ti) {\n                    filters.push('type=' + options.type[ti]);\n                }\n            }\n        }\n\n        if (options.maxbins) {\n            filters.push('maxbins=' + options.maxbins);\n        }\n\n        if (filters.length > 0) {\n            dasURI = this.dasBaseURI + 'features?' + filters.join(';');\n        } else {\n            callback([], 'No filters specified');\n        }\n    }\n\n    this.doCrossDomainRequest(dasURI, function (responseXML, req) {\n        if (!responseXML) {\n            var msg;\n            if (req.status == 0) {\n                msg = 'server may not support CORS';\n            } else {\n                msg = 'status=' + req.status;\n            }\n            callback([], 'Failed request: ' + msg);\n            return;\n        }\n        /*      if (req) {\n                    var caps = req.getResponseHeader('X-DAS-Capabilties');\n                    if (caps) {\n                        alert(caps);\n                    }\n                } */\n\n        var features = new Array();\n        var segmentMap = {};\n\n        var segs = responseXML.getElementsByTagName('SEGMENT');\n        for (var si = 0; si < segs.length; ++si) {\n            var segmentXML = segs[si];\n            var segmentID = segmentXML.getAttribute('id');\n            segmentMap[segmentID] = {\n                min: segmentXML.getAttribute('start'),\n                max: segmentXML.getAttribute('stop')\n            };\n\n            var featureXMLs = segmentXML.getElementsByTagName('FEATURE');\n            for (var i = 0; i < featureXMLs.length; ++i) {\n                var feature = featureXMLs[i];\n                var dasFeature = new DASFeature();\n\n                dasFeature.segment = segmentID;\n                dasFeature.id = feature.getAttribute('id');\n                dasFeature.label = feature.getAttribute('label');\n\n                /*\n                                var childNodes = feature.childNodes;\n                                for (var c = 0; c < childNodes.length; ++c) {\n                                    var cn = childNodes[c];\n                                    if (cn.nodeType == Node.ELEMENT_NODE) {\n                                        var key = cn.tagName;\n                                        //var val = null;\n                                        //if (cn.firstChild) {\n                                        //   val = cn.firstChild.nodeValue;\n                                        //}\n                                        dasFeature[key] = 'x';\n                                    }\n                                } */\n\n                var spos = elementValue(feature, \"START\");\n                var epos = elementValue(feature, \"END\");\n                if ((spos | 0) > (epos | 0)) {\n                    dasFeature.min = epos | 0;\n                    dasFeature.max = spos | 0;\n                } else {\n                    dasFeature.min = spos | 0;\n                    dasFeature.max = epos | 0;\n                }\n                {\n                    var tec = feature.getElementsByTagName('TYPE');\n                    if (tec.length > 0) {\n                        var te = tec[0];\n                        if (te.firstChild) {\n                            dasFeature.type = te.firstChild.nodeValue;\n                        }\n                        dasFeature.typeId = te.getAttribute('id');\n                        dasFeature.typeCv = te.getAttribute('cvId');\n                    }\n                }\n                dasFeature.type = elementValue(feature, \"TYPE\");\n                if (!dasFeature.type && dasFeature.typeId) {\n                    dasFeature.type = dasFeature.typeId; // FIXME?\n                }\n\n                dasFeature.method = elementValue(feature, \"METHOD\");\n                {\n                    var ori = elementValue(feature, \"ORIENTATION\");\n                    if (!ori) {\n                        ori = '0';\n                    }\n                    dasFeature.orientation = ori;\n                }\n                dasFeature.score = elementValue(feature, \"SCORE\");\n                dasFeature.links = dasLinksOf(feature);\n                dasFeature.notes = dasNotesOf(feature);\n\n                var groups = feature.getElementsByTagName(\"GROUP\");\n                for (var gi = 0; gi < groups.length; ++gi) {\n                    var groupXML = groups[gi];\n                    var dasGroup = new DASGroup();\n                    dasGroup.type = groupXML.getAttribute('type');\n                    dasGroup.id = groupXML.getAttribute('id');\n                    dasGroup.links = dasLinksOf(groupXML);\n                    dasGroup.notes = dasNotesOf(groupXML);\n                    if (!dasFeature.groups) {\n                        dasFeature.groups = new Array(dasGroup);\n                    } else {\n                        dasFeature.groups.push(dasGroup);\n                    }\n                }\n\n                // Magic notes.  Check with TAD before changing this.\n                if (dasFeature.notes) {\n                    for (var ni = 0; ni < dasFeature.notes.length; ++ni) {\n                        var n = dasFeature.notes[ni];\n                        if (n.indexOf('Genename=') == 0) {\n                            var gg = new DASGroup();\n                            gg.type = 'gene';\n                            gg.id = n.substring(9);\n                            if (!dasFeature.groups) {\n                                dasFeature.groups = new Array(gg);\n                            } else {\n                                dasFeature.groups.push(gg);\n                            }\n                        }\n                    }\n                }\n\n                {\n                    var pec = feature.getElementsByTagName('PART');\n                    if (pec.length > 0) {\n                        var parts = [];\n                        for (var pi = 0; pi < pec.length; ++pi) {\n                            parts.push(pec[pi].getAttribute('id'));\n                        }\n                        dasFeature.parts = parts;\n                    }\n                }\n                {\n                    var pec = feature.getElementsByTagName('PARENT');\n                    if (pec.length > 0) {\n                        var parents = [];\n                        for (var pi = 0; pi < pec.length; ++pi) {\n                            parents.push(pec[pi].getAttribute('id'));\n                        }\n                        dasFeature.parents = parents;\n                    }\n                }\n\n                features.push(dasFeature);\n            }\n        }\n\n        callback(features, undefined, segmentMap);\n    }, function (err) {\n        callback([], err);\n    });\n};\n\nfunction DASAlignment(type) {\n    this.type = type;\n    this.objects = {};\n    this.blocks = [];\n}\n\nDASSource.prototype.alignments = function (segment, options, callback) {\n    var dasURI = this.dasBaseURI + 'alignment?query=' + segment;\n    this.doCrossDomainRequest(dasURI, function (responseXML) {\n        if (!responseXML) {\n            callback([], 'Failed request ' + dasURI);\n            return;\n        }\n\n        var alignments = [];\n        var aliXMLs = responseXML.getElementsByTagName('alignment');\n        for (var ai = 0; ai < aliXMLs.length; ++ai) {\n            var aliXML = aliXMLs[ai];\n            var ali = new DASAlignment(aliXML.getAttribute('alignType'));\n            var objXMLs = aliXML.getElementsByTagName('alignObject');\n            for (var oi = 0; oi < objXMLs.length; ++oi) {\n                var objXML = objXMLs[oi];\n                var obj = {\n                    id: objXML.getAttribute('intObjectId'),\n                    accession: objXML.getAttribute('dbAccessionId'),\n                    version: objXML.getAttribute('objectVersion'),\n                    dbSource: objXML.getAttribute('dbSource'),\n                    dbVersion: objXML.getAttribute('dbVersion')\n                };\n                ali.objects[obj.id] = obj;\n            }\n\n            var blockXMLs = aliXML.getElementsByTagName('block');\n            for (var bi = 0; bi < blockXMLs.length; ++bi) {\n                var blockXML = blockXMLs[bi];\n                var block = {\n                    order: blockXML.getAttribute('blockOrder'),\n                    segments: []\n                };\n                var segXMLs = blockXML.getElementsByTagName('segment');\n                for (var si = 0; si < segXMLs.length; ++si) {\n                    var segXML = segXMLs[si];\n                    var seg = {\n                        object: segXML.getAttribute('intObjectId'),\n                        min: segXML.getAttribute('start'),\n                        max: segXML.getAttribute('end'),\n                        strand: segXML.getAttribute('strand'),\n                        cigar: elementValue(segXML, 'cigar')\n                    };\n                    block.segments.push(seg);\n                }\n                ali.blocks.push(block);\n            }\n\n            alignments.push(ali);\n        }\n        callback(alignments);\n    });\n};\n\nfunction DASStylesheet() {\n    this.styles = [];\n}\n\nDASStylesheet.prototype.pushStyle = function (filters, zoom, style) {\n    if (!filters) {\n        filters = { type: 'default' };\n    }\n    var styleHolder = shallowCopy(filters);\n    if (zoom) {\n        styleHolder.zoom = zoom;\n    }\n    styleHolder.style = style;\n    this.styles.push(styleHolder);\n};\n\nfunction DASStyle() {}\n\nfunction parseGradient(grad) {\n    var steps = grad.getAttribute('steps');\n    if (steps) {\n        steps = steps | 0;\n    } else {\n        steps = 50;\n    }\n\n    var stops = [];\n    var colors = [];\n    var se = grad.getElementsByTagName('STOP');\n    for (var si = 0; si < se.length; ++si) {\n        var stop = se[si];\n        stops.push(1.0 * stop.getAttribute('score'));\n        colors.push(stop.firstChild.nodeValue);\n    }\n\n    return makeColourSteps(steps, stops, colors);\n}\n\nDASSource.prototype.stylesheet = function (successCB, failureCB) {\n    var dasURI,\n        creds = this.credentials;\n    if (this.stylesheet_uri) {\n        dasURI = this.stylesheet_uri;\n        creds = false;\n    } else {\n        dasURI = this.dasBaseURI + 'stylesheet';\n    }\n\n    this.getURI(dasURI).then(function (dasURI) {\n        doCrossDomainRequest(dasURI, function (responseXML) {\n            if (!responseXML) {\n                if (failureCB) {\n                    failureCB();\n                }\n                return;\n            }\n            var stylesheet = new DASStylesheet();\n            var typeXMLs = responseXML.getElementsByTagName('TYPE');\n            for (var i = 0; i < typeXMLs.length; ++i) {\n                var typeStyle = typeXMLs[i];\n\n                var filter = {};\n                filter.type = typeStyle.getAttribute('id'); // Am I right in thinking that this makes DASSTYLE XML invalid?  Ugh.\n                filter.label = typeStyle.getAttribute('label');\n                filter.method = typeStyle.getAttribute('method');\n                var glyphXMLs = typeStyle.getElementsByTagName('GLYPH');\n                for (var gi = 0; gi < glyphXMLs.length; ++gi) {\n                    var glyphXML = glyphXMLs[gi];\n                    var zoom = glyphXML.getAttribute('zoom');\n                    var glyph = childElementOf(glyphXML);\n                    var style = new DASStyle();\n                    style.glyph = glyph.localName;\n                    var child = glyph.firstChild;\n\n                    while (child) {\n                        if (child.nodeType == Node.ELEMENT_NODE) {\n                            if (child.localName == 'BGGRAD') {\n                                style[child.localName] = parseGradient(child);\n                            } else {\n                                style[child.localName] = child.firstChild.nodeValue;\n                            }\n                        }\n                        child = child.nextSibling;\n                    }\n                    stylesheet.pushStyle(filter, zoom, style);\n                }\n            }\n            successCB(stylesheet);\n        }, creds);\n    }).catch(function (err) {\n        console.log(err);\n        failureCB();\n    });\n};\n\n//\n// sources command\n// \n\nfunction DASRegistry(uri, opts) {\n    opts = opts || {};\n    this.uri = uri;\n    this.opts = opts;\n}\n\nDASRegistry.prototype.sources = function (callback, failure, opts) {\n    if (!opts) {\n        opts = {};\n    }\n\n    var filters = [];\n    if (opts.taxon) {\n        filters.push('organism=' + opts.taxon);\n    }\n    if (opts.auth) {\n        filters.push('authority=' + opts.auth);\n    }\n    if (opts.version) {\n        filters.push('version=' + opts.version);\n    }\n    var quri = this.uri;\n    if (filters.length > 0) {\n        quri = quri + '?' + filters.join('&'); // '&' as a separator to hack around dasregistry.org bug.\n    }\n\n    doCrossDomainRequest(quri, function (responseXML) {\n        if (!responseXML && failure) {\n            failure();\n            return;\n        }\n\n        var sources = [];\n        var sourceXMLs = responseXML.getElementsByTagName('SOURCE');\n        for (var si = 0; si < sourceXMLs.length; ++si) {\n            var sourceXML = sourceXMLs[si];\n            var versionXMLs = sourceXML.getElementsByTagName('VERSION');\n            if (versionXMLs.length < 1) {\n                continue;\n            }\n            var versionXML = versionXMLs[0];\n\n            var coordXMLs = versionXML.getElementsByTagName('COORDINATES');\n            var coords = [];\n            for (var ci = 0; ci < coordXMLs.length; ++ci) {\n                var coordXML = coordXMLs[ci];\n                var coord = new DASCoords();\n                coord.auth = coordXML.getAttribute('authority');\n                coord.taxon = coordXML.getAttribute('taxid');\n                coord.version = coordXML.getAttribute('version');\n                coords.push(coord);\n            }\n\n            var caps = [];\n            var capXMLs = versionXML.getElementsByTagName('CAPABILITY');\n            var uri;\n            for (var ci = 0; ci < capXMLs.length; ++ci) {\n                var capXML = capXMLs[ci];\n\n                caps.push(capXML.getAttribute('type'));\n\n                if (capXML.getAttribute('type') == 'das1:features') {\n                    var fep = capXML.getAttribute('query_uri');\n                    uri = fep.substring(0, fep.length - 'features'.length);\n                }\n            }\n\n            var props = {};\n            var propXMLs = versionXML.getElementsByTagName('PROP');\n            for (var pi = 0; pi < propXMLs.length; ++pi) {\n                pusho(props, propXMLs[pi].getAttribute('name'), propXMLs[pi].getAttribute('value'));\n            }\n\n            if (uri) {\n                var source = new DASSource(uri, {\n                    source_uri: sourceXML.getAttribute('uri'),\n                    name: sourceXML.getAttribute('title'),\n                    desc: sourceXML.getAttribute('description'),\n                    coords: coords,\n                    props: props,\n                    capabilities: caps\n                });\n                sources.push(source);\n            }\n        }\n\n        callback(sources);\n    });\n};\n\n//\n// Utility functions\n//\n\nfunction elementValue(element, tag) {\n    var children = element.getElementsByTagName(tag);\n    if (children.length > 0 && children[0].firstChild) {\n        var c = children[0];\n        if (c.childNodes.length == 1) {\n            return c.firstChild.nodeValue;\n        } else {\n            var s = '';\n            for (var ni = 0; ni < c.childNodes.length; ++ni) {\n                s += c.childNodes[ni].nodeValue;\n            }\n            return s;\n        }\n    } else {\n        return null;\n    }\n}\n\nfunction childElementOf(element) {\n    if (element.hasChildNodes()) {\n        var child = element.firstChild;\n        do {\n            if (child.nodeType == Node.ELEMENT_NODE) {\n                return child;\n            }\n            child = child.nextSibling;\n        } while (child != null);\n    }\n    return null;\n}\n\nfunction dasLinksOf(element) {\n    var links = new Array();\n    var maybeLinkChilden = element.getElementsByTagName('LINK');\n    for (var ci = 0; ci < maybeLinkChilden.length; ++ci) {\n        var linkXML = maybeLinkChilden[ci];\n        if (linkXML.parentNode == element) {\n            links.push(new DASLink(linkXML.firstChild ? linkXML.firstChild.nodeValue : 'Unknown', linkXML.getAttribute('href')));\n        }\n    }\n\n    return links;\n}\n\nfunction dasNotesOf(element) {\n    var notes = [];\n    var maybeNotes = element.getElementsByTagName('NOTE');\n    for (var ni = 0; ni < maybeNotes.length; ++ni) {\n        if (maybeNotes[ni].firstChild) {\n            notes.push(maybeNotes[ni].firstChild.nodeValue);\n        }\n    }\n    return notes;\n}\n\nfunction doCrossDomainRequest(url, handler, credentials, custAuth) {\n    // TODO: explicit error handlers?\n\n    if (window.XDomainRequest) {\n        var req = new XDomainRequest();\n        req.onload = function () {\n            var dom = new ActiveXObject(\"Microsoft.XMLDOM\");\n            dom.async = false;\n            dom.loadXML(req.responseText);\n            handler(dom);\n        };\n        req.open(\"get\", url);\n        req.send();\n    } else {\n        try {\n            var req = new XMLHttpRequest();\n            var timeout = setTimeout(function () {\n                console.log('timing out ' + url);\n                req.abort();\n                handler(null, req);\n            }, 5000);\n\n            req.ontimeout = function () {\n                console.log('timeout on ' + url);\n            };\n\n            req.onreadystatechange = function () {\n                if (req.readyState == 4) {\n                    clearTimeout(timeout);\n                    if (req.status >= 200 || req.status == 0) {\n                        handler(req.responseXML, req);\n                    }\n                }\n            };\n            req.open(\"get\", url, true);\n            // IE10/11 fix: The timeout property may be set only in the time interval between a call to the open method\n            //              and the first call to the send method.\n            req.timeout = 5000;\n            if (credentials) {\n                req.withCredentials = true;\n            }\n            if (custAuth) {\n                req.setRequestHeader('X-DAS-Authorisation', custAuth);\n            }\n            req.overrideMimeType('text/xml');\n            req.setRequestHeader('Accept', 'application/xml,*/*');\n            req.send();\n        } catch (e) {\n            handler(null, req, e);\n        }\n    }\n}\n\nDASSource.prototype.doCrossDomainRequest = function (url, handler, errHandler) {\n    var custAuth;\n    if (this.xUser) {\n        custAuth = 'Basic ' + btoa(this.xUser + ':' + this.xPass);\n    }\n\n    try {\n        return doCrossDomainRequest(url, handler, this.credentials, custAuth);\n    } catch (err) {\n        if (errHandler) {\n            errHandler(err);\n        } else {\n            throw err;\n        }\n    }\n};\n\nfunction isDasBooleanTrue(s) {\n    s = ('' + s).toLowerCase();\n    return s === 'yes' || s === 'true';\n}\n\nfunction isDasBooleanNotFalse(s) {\n    if (!s) return false;\n\n    s = ('' + s).toLowerCase();\n    return s !== 'no' || s !== 'false';\n}\n\nfunction copyStylesheet(ss) {\n    var nss = shallowCopy(ss);\n    nss.styles = [];\n    for (var si = 0; si < ss.styles.length; ++si) {\n        var sh = nss.styles[si] = shallowCopy(ss.styles[si]);\n        sh._methodRE = sh._labelRE = sh._typeRE = undefined;\n        sh.style = shallowCopy(sh.style);\n        sh.style.id = undefined;\n        sh.style._gradient = undefined;\n    }\n    return nss;\n}\n\nif (typeof module !== 'undefined') {\n    module.exports = {\n        DASGroup: DASGroup,\n        DASFeature: DASFeature,\n        DASStylesheet: DASStylesheet,\n        DASStyle: DASStyle,\n        DASSource: DASSource,\n        DASSegment: DASSegment,\n        DASRegistry: DASRegistry,\n        DASSequence: DASSequence,\n        DASLink: DASLink,\n\n        isDasBooleanTrue: isDasBooleanTrue,\n        isDasBooleanNotFalse: isDasBooleanNotFalse,\n        copyStylesheet: copyStylesheet,\n        coordsMatch: coordsMatch\n    };\n}\n\n},{\"./color\":4,\"./utils\":12}],7:[function(require,module,exports){\n/* -*- mode: javascript; c-basic-offset: 4; indent-tabs-mode: nil -*- */\n\n// \n// Dalliance Genome Explorer\n// (c) Thomas Down 2006-2014\n//\n// encode.js: interface for ENCODE DCC services\n//\n\n\"use strict\";\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nif (typeof require !== 'undefined') {\n    var Promise = require('es6-promise').Promise;\n}\n\nfunction lookupEncodeURI(uri, json) {\n    if (uri.indexOf('?') < 0) uri = uri + '?soft=true';\n\n    return new Promise(function (accept, reject) {\n        var req = new XMLHttpRequest();\n        req.onreadystatechange = function () {\n            if (req.readyState == 4) {\n                if (req.status >= 300) {\n                    reject('Error code ' + req.status);\n                } else {\n                    var resp = JSON.parse(req.response);\n                    accept(json ? resp : resp.location);\n                }\n            }\n        };\n\n        req.open('GET', uri, true);\n        req.setRequestHeader('Accept', 'application/json');\n        req.responseType = 'text';\n        req.send();\n    });\n}\n\nfunction EncodeURLHolder(url) {\n    this.rawurl = url;\n}\n\nEncodeURLHolder.prototype.getURLPromise = function () {\n    if (this.urlPromise && this.urlPromiseValidity > Date.now()) {\n        return this.urlPromise;\n    } else {\n        this.urlPromise = lookupEncodeURI(this.rawurl, true).then(function (resp) {\n            return resp.location;\n        });\n        this.urlPromiseValidity = Date.now() + 12 * 3600 * 1000;\n        return this.urlPromise;\n    }\n};\n\nfunction EncodeFetchable(url, start, end, opts) {\n    if (!opts) {\n        if ((typeof start === 'undefined' ? 'undefined' : _typeof(start)) === 'object') {\n            opts = start;\n            start = undefined;\n        } else {\n            opts = {};\n        }\n    }\n\n    this.url = typeof url === 'string' ? new EncodeURLHolder(url) : url;\n    this.start = start || 0;\n    if (end) {\n        this.end = end;\n    }\n    this.opts = opts;\n}\n\nEncodeFetchable.prototype.slice = function (s, l) {\n    if (s < 0) {\n        throw 'Bad slice ' + s;\n    }\n\n    var ns = this.start,\n        ne = this.end;\n    if (ns && s) {\n        ns = ns + s;\n    } else {\n        ns = s || ns;\n    }\n    if (l && ns) {\n        ne = ns + l - 1;\n    } else {\n        ne = ne || l - 1;\n    }\n    return new EncodeFetchable(this.url, ns, ne, this.opts);\n};\n\nEncodeFetchable.prototype.fetchAsText = function (callback) {\n    var self = this;\n    var req = new XMLHttpRequest();\n    var length;\n    self.url.getURLPromise().then(function (url) {\n        req.open('GET', url, true);\n\n        if (self.end) {\n            if (self.end - self.start > 100000000) {\n                throw 'Monster fetch!';\n            }\n            req.setRequestHeader('Range', 'bytes=' + self.start + '-' + self.end);\n            length = self.end - self.start + 1;\n        }\n\n        req.onreadystatechange = function () {\n            if (req.readyState == 4) {\n                if (req.status == 200 || req.status == 206) {\n                    return callback(req.responseText);\n                } else {\n                    return callback(null);\n                }\n            }\n        };\n        if (self.opts.credentials) {\n            req.withCredentials = true;\n        }\n        req.send();\n    }).catch(function (err) {\n        console.log(err);\n        return callback(null);\n    });\n};\n\nEncodeFetchable.prototype.salted = function () {\n    return this;\n};\n\nEncodeFetchable.prototype.fetch = function (callback, attempt, truncatedLength) {\n    var self = this;\n\n    attempt = attempt || 1;\n    if (attempt > 3) {\n        return callback(null);\n    }\n\n    self.url.getURLPromise().then(function (url) {\n        var req = new XMLHttpRequest();\n        var length;\n        req.open('GET', url, true);\n        req.overrideMimeType('text/plain; charset=x-user-defined');\n        if (self.end) {\n            if (self.end - self.start > 100000000) {\n                throw 'Monster fetch!';\n            }\n            req.setRequestHeader('Range', 'bytes=' + self.start + '-' + self.end);\n            length = self.end - self.start + 1;\n        }\n        req.responseType = 'arraybuffer';\n        req.onreadystatechange = function () {\n            if (req.readyState == 4) {\n                if (req.status == 200 || req.status == 206) {\n                    if (req.response) {\n                        var bl = req.response.byteLength;\n                        if (length && length != bl && (!truncatedLength || bl != truncatedLength)) {\n                            return self.fetch(callback, attempt + 1, bl);\n                        } else {\n                            return callback(req.response);\n                        }\n                    } else if (req.mozResponseArrayBuffer) {\n                        return callback(req.mozResponseArrayBuffer);\n                    } else {\n                        var r = req.responseText;\n                        if (length && length != r.length && (!truncatedLength || r.length != truncatedLength)) {\n                            return self.fetch(callback, attempt + 1, r.length);\n                        } else {\n                            return callback(bstringToBuffer(req.responseText));\n                        }\n                    }\n                } else {\n                    return self.fetch(callback, attempt + 1);\n                }\n            }\n        };\n        if (self.opts.credentials) {\n            req.withCredentials = true;\n        }\n        req.send();\n    }).catch(function (err) {\n        console.log(err);\n    });\n};\n\nfunction bstringToBuffer(result) {\n    if (!result) {\n        return null;\n    }\n\n    var ba = new Uint8Array(result.length);\n    for (var i = 0; i < ba.length; ++i) {\n        ba[i] = result.charCodeAt(i);\n    }\n    return ba.buffer;\n}\n\nif (typeof module !== 'undefined') {\n    module.exports = {\n        lookupEncodeURI: lookupEncodeURI,\n        EncodeFetchable: EncodeFetchable\n    };\n}\n\n},{\"es6-promise\":13}],8:[function(require,module,exports){\n(function (global){\n/* -*- mode: javascript; c-basic-offset: 4; indent-tabs-mode: nil -*- */\n\n// \n// Dalliance Genome Explorer\n// (c) Thomas Down 2006-2014\n//\n// fetchworker.js\n//\n\n\"use strict\";\n\nvar bin = require('./bin');\nvar bam = require('./bam');\nvar cram = require('./cram');\nvar bigwig = require('./bigwig');\nvar encode = require('./encode');\nvar utils = require('./utils');\n\nvar Promise = require('es6-promise').Promise;\n\nvar connections = {};\nvar resolveResolvers = {};\n\nvar idSeed = 0;\n\nglobal.newID = function () {\n    return 'cn' + ++idSeed;\n};\n\npostMessage({ tag: 'init' });\n\nself.onmessage = function (event) {\n    var d = event.data;\n    var command = event.data.command;\n    var tag = event.data.tag;\n\n    if (!command) {\n        var rr = resolveResolvers[tag];\n        if (rr) {\n            if (d.err) {\n                rr.reject(d.err);\n            } else {\n                rr.resolve(d.url);\n            }\n\n            delete resolveResolvers[tag];\n        }\n    } else if (command === 'connectBAM') {\n        var id = newID();\n        var resolver;\n        if (d.resolver) {\n            resolver = proxyResolver(d.resolver);\n        }\n        var bamF, baiF, indexChunks;\n        if (d.blob) {\n            bamF = new bin.BlobFetchable(d.blob);\n            baiF = new bin.BlobFetchable(d.indexBlob);\n        } else {\n            bamF = new bin.URLFetchable(d.uri, { credentials: d.credentials, resolver: resolver });\n            baiF = new bin.URLFetchable(d.indexUri, { credentials: d.credentials, resolver: resolver });\n            indexChunks = d.indexChunks;\n        }\n\n        bam.makeBam(bamF, baiF, indexChunks, function (bamObj, err) {\n            if (bamObj) {\n                connections[id] = new BAMWorkerFetcher(bamObj);\n                postMessage({ tag: tag, result: id });\n            } else {\n                postMessage({ tag: tag, error: err || \"Couldn't fetch BAM\" });\n            }\n        });\n    } else if (command === 'connectCRAM') {\n        var id = newID();\n        var resolver;\n        if (d.resolver) {\n            resolver = proxyResolver(d.resolver);\n        }\n        var cramF, craiF, indexChunks;\n        if (d.blob) {\n            cramF = new bin.BlobFetchable(d.blob);\n            craiF = new bin.BlobFetchable(d.indexBlob);\n        } else {\n            cramF = new bin.URLFetchable(d.uri, { credentials: d.credentials, resolver: resolver });\n            craiF = new bin.URLFetchable(d.indexUri, { credentials: d.credentials, resolver: resolver });\n            indexChunks = d.indexChunks;\n        }\n\n        cram.makeCram(cramF, craiF, indexChunks, function (cramObj, err) {\n            if (cramObj) {\n                connections[id] = new CRAMWorkerFetcher(bamObj);\n                postMessage({ tag: tag, result: id });\n            } else {\n                postMessage({ tag: tag, error: err || \"Couldn't fetch CRAM\" });\n            }\n        });\n    } else if (command === 'connectBBI') {\n        var id = newID();\n        var resolver;\n        if (d.resolver) {\n            resolver = proxyResolver(d.resolver);\n        }\n        var bbi;\n        if (d.blob) {\n            bbi = new bin.BlobFetchable(d.blob);\n        } else if (d.transport == 'encode') {\n            bbi = new encode.EncodeFetchable(d.uri, { credentials: d.credentials });\n        } else {\n            bbi = new bin.URLFetchable(d.uri, { credentials: d.credentials, resolver: resolver });\n        }\n\n        bigwig.makeBwg(bbi, function (bwg, err) {\n            if (bwg) {\n                connections[id] = new BBIWorkerFetcher(bwg);\n                postMessage({ tag: tag, result: id });\n            } else {\n                postMessage({ tag: tag, error: err || \"Couldn't fetch BBI\" });\n            }\n        }, d.uri);\n    } else if (command === 'textxhr') {\n        utils.textXHR(d.uri, function (resp, err) {\n            if (resp) {\n                postMessage({ tag: tag, result: resp });\n            } else {\n                postMessage({ tag: tag, err: err || \"Couldn't fetch resource\" });\n            }\n        });\n    } else if (command === 'fetch') {\n        var con = connections[event.data.connection];\n        if (!con) {\n            return postMessage({ tag: tag, error: 'No such connection: ' + event.data.connection });\n        }\n\n        con.fetch(d.tag, d.chr, d.min, d.max, d.zoom, d.opts);\n    } else if (command === 'leap') {\n        var con = connections[event.data.connection];\n        if (!con) {\n            return postMessage({ tag: tag, error: 'No such connection: ' + event.data.connection });\n        }\n\n        con.leap(d.tag, d.chr, d.pos, d.dir);\n    } else if (command === 'quantLeap') {\n        var con = connections[event.data.connection];\n        if (!con) {\n            return postMessage({ tag: tag, error: 'No such connection: ' + event.data.connection });\n        }\n\n        con.quantLeap(d.tag, d.chr, d.pos, d.dir, d.threshold, d.under);\n    } else if (command === 'meta') {\n        var con = connections[event.data.connection];\n        if (!con) {\n            return postMessage({ tag: tag, error: 'No such connection: ' + event.data.connection });\n        }\n\n        con.meta(d.tag);\n    } else if (command === 'search') {\n        var con = connections[event.data.connection];\n        if (!con) {\n            return postMessage({ tag: tag, error: 'No such connection: ' + event.data.connection });\n        }\n\n        con.search(d.tag, d.query, d.index);\n    } else if (command === 'date') {\n        return postMessage({ tag: tag, result: Date.now() | 0 });\n    } else {\n        postMessage({ tag: tag, error: 'Bad command ' + command });\n    }\n};\n\nfunction BAMWorkerFetcher(bam) {\n    this.bam = bam;\n}\n\nBAMWorkerFetcher.prototype.fetch = function (tag, chr, min, max, zoom, opts) {\n    opts = opts || {};\n    this.bam.fetch(chr, min, max, function (records, err) {\n        if (records) {\n            postMessage({ tag: tag, result: records, time: Date.now() | 0 });\n        } else {\n            postMessage({ tag: tag, error: err });\n        }\n    }, opts);\n};\n\nfunction BBIWorkerFetcher(bbi) {\n    this.bbi = bbi;\n}\n\nBBIWorkerFetcher.prototype.fetch = function (tag, chr, min, max, zoom) {\n    if (typeof zoom !== 'number') zoom = -1;\n\n    var data;\n    if (zoom < 0) {\n        data = this.bbi.getUnzoomedView();\n    } else {\n        data = this.bbi.getZoomedView(zoom);\n    }\n\n    data.readWigData(chr, min, max, function (features) {\n        postMessage({ tag: tag, result: features });\n    });\n};\n\nBBIWorkerFetcher.prototype.meta = function (tag) {\n    var scales = [1];\n    for (var z = 0; z < this.bbi.zoomLevels.length; ++z) {\n        scales.push(this.bbi.zoomLevels[z].reduction);\n    }\n\n    var thisB = this;\n    var meta = { type: this.bbi.type,\n        zoomLevels: scales,\n        fieldCount: this.bbi.fieldCount,\n        definedFieldCount: this.bbi.definedFieldCount,\n        schema: this.bbi.schema };\n    if (this.bbi.type === 'bigbed') {\n        this.bbi.getExtraIndices(function (ei) {\n            if (ei) {\n                thisB.extraIndices = ei;\n                meta.extraIndices = ei.map(function (i) {\n                    return i.field;\n                });\n            }\n            postMessage({ tag: tag, result: meta });\n        });\n    } else {\n        postMessage({ tag: tag, result: meta });\n    }\n};\n\nBBIWorkerFetcher.prototype.leap = function (tag, chr, pos, dir) {\n    this.bbi.getUnzoomedView().getFirstAdjacent(chr, pos, dir, function (result, err) {\n        postMessage({ tag: tag, result: result, error: err });\n    });\n};\n\nBBIWorkerFetcher.prototype.quantLeap = function (tag, chr, pos, dir, threshold, under) {\n    this.bbi.thresholdSearch(chr, pos, dir, threshold, function (result, err) {\n        postMessage({ tag: tag, result: result, error: err });\n    });\n};\n\nBBIWorkerFetcher.prototype.search = function (tag, query, index) {\n    var is = this.extraIndices[0];\n    is.lookup(query, function (result, err) {\n        postMessage({ tag: tag, result: result, error: err });\n    });\n};\n\nfunction proxyResolver(tag) {\n    return function (url) {\n        var lid = newID();\n        return new Promise(function (resolve, reject) {\n            resolveResolvers[lid] = { resolve: resolve, reject: reject };\n            postMessage({ tag: lid,\n                cmd: 'resolve',\n                resolver: tag,\n                url: url });\n        });\n    };\n}\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{\"./bam\":1,\"./bigwig\":2,\"./bin\":3,\"./cram\":5,\"./encode\":7,\"./utils\":12,\"es6-promise\":13}],9:[function(require,module,exports){\n'use strict';\n\n/* -*- mode: javascript; c-basic-offset: 4; indent-tabs-mode: nil -*- */\n\n// \n// Dalliance Genome Explorer\n// (c) Thomas Down 2006-2011\n//\n// lh3utils.js: common support for lh3's file formats\n//\n\nif (typeof require !== 'undefined') {\n    var jszlib = require('jszlib');\n    var jszlib_inflate_buffer = jszlib.inflateBuffer;\n    var arrayCopy = jszlib.arrayCopy;\n}\n\nfunction Vob(b, o) {\n    this.block = b;\n    this.offset = o;\n}\n\nVob.prototype.toString = function () {\n    return '' + this.block + ':' + this.offset;\n};\n\nfunction readVob(ba, offset, allowZero) {\n    var block = (ba[offset + 6] & 0xff) * 0x100000000 + (ba[offset + 5] & 0xff) * 0x1000000 + (ba[offset + 4] & 0xff) * 0x10000 + (ba[offset + 3] & 0xff) * 0x100 + (ba[offset + 2] & 0xff);\n    var bint = ba[offset + 1] << 8 | ba[offset];\n    if (block == 0 && bint == 0 && !allowZero) {\n        return null; // Should only happen in the linear index?\n    } else {\n        return new Vob(block, bint);\n    }\n}\n\nfunction unbgzf(data, lim) {\n    lim = Math.min(lim || 1, data.byteLength - 50);\n    var oBlockList = [];\n    var ptr = [0];\n    var totalSize = 0;\n\n    while (ptr[0] < lim) {\n        var ba = new Uint8Array(data, ptr[0], 12); // FIXME is this enough for all credible BGZF block headers?\n        var xlen = ba[11] << 8 | ba[10];\n        // dlog('xlen[' + (ptr[0]) +']=' + xlen);\n        var unc = jszlib_inflate_buffer(data, 12 + xlen + ptr[0], Math.min(65536, data.byteLength - 12 - xlen - ptr[0]), ptr);\n        ptr[0] += 8;\n        totalSize += unc.byteLength;\n        oBlockList.push(unc);\n    }\n\n    if (oBlockList.length == 1) {\n        return oBlockList[0];\n    } else {\n        var out = new Uint8Array(totalSize);\n        var cursor = 0;\n        for (var i = 0; i < oBlockList.length; ++i) {\n            var b = new Uint8Array(oBlockList[i]);\n            arrayCopy(b, 0, out, cursor, b.length);\n            cursor += b.length;\n        }\n        return out.buffer;\n    }\n}\n\nfunction Chunk(minv, maxv) {\n    this.minv = minv;this.maxv = maxv;\n}\n\n//\n// Binning (transliterated from SAM1.3 spec)\n//\n\n/* calculate bin given an alignment covering [beg,end) (zero-based, half-close-half-open) */\nfunction reg2bin(beg, end) {\n    --end;\n    if (beg >> 14 == end >> 14) return ((1 << 15) - 1) / 7 + (beg >> 14);\n    if (beg >> 17 == end >> 17) return ((1 << 12) - 1) / 7 + (beg >> 17);\n    if (beg >> 20 == end >> 20) return ((1 << 9) - 1) / 7 + (beg >> 20);\n    if (beg >> 23 == end >> 23) return ((1 << 6) - 1) / 7 + (beg >> 23);\n    if (beg >> 26 == end >> 26) return ((1 << 3) - 1) / 7 + (beg >> 26);\n    return 0;\n}\n\n/* calculate the list of bins that may overlap with region [beg,end) (zero-based) */\nvar MAX_BIN = ((1 << 18) - 1) / 7;\nfunction reg2bins(beg, end) {\n    var i = 0,\n        k,\n        list = [];\n    --end;\n    list.push(0);\n    for (k = 1 + (beg >> 26); k <= 1 + (end >> 26); ++k) {\n        list.push(k);\n    }for (k = 9 + (beg >> 23); k <= 9 + (end >> 23); ++k) {\n        list.push(k);\n    }for (k = 73 + (beg >> 20); k <= 73 + (end >> 20); ++k) {\n        list.push(k);\n    }for (k = 585 + (beg >> 17); k <= 585 + (end >> 17); ++k) {\n        list.push(k);\n    }for (k = 4681 + (beg >> 14); k <= 4681 + (end >> 14); ++k) {\n        list.push(k);\n    }return list;\n}\n\nif (typeof module !== 'undefined') {\n    module.exports = {\n        unbgzf: unbgzf,\n        readVob: readVob,\n        reg2bin: reg2bin,\n        reg2bins: reg2bins,\n        Chunk: Chunk\n    };\n}\n\n},{\"jszlib\":24}],10:[function(require,module,exports){\n/*\r\n * A JavaScript implementation of the Secure Hash Algorithm, SHA-1, as defined\r\n * in FIPS 180-1\r\n * Version 2.2 Copyright Paul Johnston 2000 - 2009.\r\n * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet\r\n * Distributed under the BSD License\r\n * See http://pajhome.org.uk/crypt/md5 for details.\r\n */\n\n\"use strict\";\n\n/*\r\n * Configurable variables. You may need to tweak these to be compatible with\r\n * the server-side, but the defaults work in most cases.\r\n */\n\nvar hexcase = 0; /* hex output format. 0 - lowercase; 1 - uppercase        */\nvar b64pad = \"\"; /* base-64 pad character. \"=\" for strict RFC compliance   */\n\n/*\r\n * These are the functions you'll usually want to call\r\n * They take string arguments and return either hex or base-64 encoded strings\r\n */\nfunction hex_sha1(s) {\n  return rstr2hex(rstr_sha1(str2rstr_utf8(s)));\n}\nfunction b64_sha1(s) {\n  return rstr2b64(rstr_sha1(str2rstr_utf8(s)));\n}\nfunction any_sha1(s, e) {\n  return rstr2any(rstr_sha1(str2rstr_utf8(s)), e);\n}\nfunction hex_hmac_sha1(k, d) {\n  return rstr2hex(rstr_hmac_sha1(str2rstr_utf8(k), str2rstr_utf8(d)));\n}\nfunction b64_hmac_sha1(k, d) {\n  return rstr2b64(rstr_hmac_sha1(str2rstr_utf8(k), str2rstr_utf8(d)));\n}\nfunction any_hmac_sha1(k, d, e) {\n  return rstr2any(rstr_hmac_sha1(str2rstr_utf8(k), str2rstr_utf8(d)), e);\n}\n\n/*\r\n * Perform a simple self-test to see if the VM is working\r\n */\nfunction sha1_vm_test() {\n  return hex_sha1(\"abc\").toLowerCase() == \"a9993e364706816aba3e25717850c26c9cd0d89d\";\n}\n\n/*\r\n * Calculate the SHA1 of a raw string\r\n */\nfunction rstr_sha1(s) {\n  return binb2rstr(binb_sha1(rstr2binb(s), s.length * 8));\n}\n\n/*\r\n * Calculate the HMAC-SHA1 of a key and some data (raw strings)\r\n */\nfunction rstr_hmac_sha1(key, data) {\n  var bkey = rstr2binb(key);\n  if (bkey.length > 16) bkey = binb_sha1(bkey, key.length * 8);\n\n  var ipad = Array(16),\n      opad = Array(16);\n  for (var i = 0; i < 16; i++) {\n    ipad[i] = bkey[i] ^ 0x36363636;\n    opad[i] = bkey[i] ^ 0x5C5C5C5C;\n  }\n\n  var hash = binb_sha1(ipad.concat(rstr2binb(data)), 512 + data.length * 8);\n  return binb2rstr(binb_sha1(opad.concat(hash), 512 + 160));\n}\n\n/*\r\n * Convert a raw string to a hex string\r\n */\nfunction rstr2hex(input) {\n  // try { hexcase } catch(e) { hexcase=0; }\n  var hex_tab = hexcase ? \"0123456789ABCDEF\" : \"0123456789abcdef\";\n  var output = \"\";\n  var x;\n  for (var i = 0; i < input.length; i++) {\n    x = input.charCodeAt(i);\n    output += hex_tab.charAt(x >>> 4 & 0x0F) + hex_tab.charAt(x & 0x0F);\n  }\n  return output;\n}\n\n/*\r\n * Convert a raw string to a base-64 string\r\n */\nfunction rstr2b64(input) {\n  // try { b64pad } catch(e) { b64pad=''; }\n  var tab = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n  var output = \"\";\n  var len = input.length;\n  for (var i = 0; i < len; i += 3) {\n    var triplet = input.charCodeAt(i) << 16 | (i + 1 < len ? input.charCodeAt(i + 1) << 8 : 0) | (i + 2 < len ? input.charCodeAt(i + 2) : 0);\n    for (var j = 0; j < 4; j++) {\n      if (i * 8 + j * 6 > input.length * 8) output += b64pad;else output += tab.charAt(triplet >>> 6 * (3 - j) & 0x3F);\n    }\n  }\n  return output;\n}\n\n/*\r\n * Convert a raw string to an arbitrary string encoding\r\n */\nfunction rstr2any(input, encoding) {\n  var divisor = encoding.length;\n  var remainders = Array();\n  var i, q, x, quotient;\n\n  /* Convert to an array of 16-bit big-endian values, forming the dividend */\n  var dividend = Array(Math.ceil(input.length / 2));\n  for (i = 0; i < dividend.length; i++) {\n    dividend[i] = input.charCodeAt(i * 2) << 8 | input.charCodeAt(i * 2 + 1);\n  }\n\n  /*\r\n   * Repeatedly perform a long division. The binary array forms the dividend,\r\n   * the length of the encoding is the divisor. Once computed, the quotient\r\n   * forms the dividend for the next step. We stop when the dividend is zero.\r\n   * All remainders are stored for later use.\r\n   */\n  while (dividend.length > 0) {\n    quotient = Array();\n    x = 0;\n    for (i = 0; i < dividend.length; i++) {\n      x = (x << 16) + dividend[i];\n      q = Math.floor(x / divisor);\n      x -= q * divisor;\n      if (quotient.length > 0 || q > 0) quotient[quotient.length] = q;\n    }\n    remainders[remainders.length] = x;\n    dividend = quotient;\n  }\n\n  /* Convert the remainders to the output string */\n  var output = \"\";\n  for (i = remainders.length - 1; i >= 0; i--) {\n    output += encoding.charAt(remainders[i]);\n  } /* Append leading zero equivalents */\n  var full_length = Math.ceil(input.length * 8 / (Math.log(encoding.length) / Math.log(2)));\n  for (i = output.length; i < full_length; i++) {\n    output = encoding[0] + output;\n  }return output;\n}\n\n/*\r\n * Encode a string as utf-8.\r\n * For efficiency, this assumes the input is valid utf-16.\r\n */\nfunction str2rstr_utf8(input) {\n  var output = \"\";\n  var i = -1;\n  var x, y;\n\n  while (++i < input.length) {\n    /* Decode utf-16 surrogate pairs */\n    x = input.charCodeAt(i);\n    y = i + 1 < input.length ? input.charCodeAt(i + 1) : 0;\n    if (0xD800 <= x && x <= 0xDBFF && 0xDC00 <= y && y <= 0xDFFF) {\n      x = 0x10000 + ((x & 0x03FF) << 10) + (y & 0x03FF);\n      i++;\n    }\n\n    /* Encode output as utf-8 */\n    if (x <= 0x7F) output += String.fromCharCode(x);else if (x <= 0x7FF) output += String.fromCharCode(0xC0 | x >>> 6 & 0x1F, 0x80 | x & 0x3F);else if (x <= 0xFFFF) output += String.fromCharCode(0xE0 | x >>> 12 & 0x0F, 0x80 | x >>> 6 & 0x3F, 0x80 | x & 0x3F);else if (x <= 0x1FFFFF) output += String.fromCharCode(0xF0 | x >>> 18 & 0x07, 0x80 | x >>> 12 & 0x3F, 0x80 | x >>> 6 & 0x3F, 0x80 | x & 0x3F);\n  }\n  return output;\n}\n\n/*\r\n * Encode a string as utf-16\r\n */\nfunction str2rstr_utf16le(input) {\n  var output = \"\";\n  for (var i = 0; i < input.length; i++) {\n    output += String.fromCharCode(input.charCodeAt(i) & 0xFF, input.charCodeAt(i) >>> 8 & 0xFF);\n  }return output;\n}\n\nfunction str2rstr_utf16be(input) {\n  var output = \"\";\n  for (var i = 0; i < input.length; i++) {\n    output += String.fromCharCode(input.charCodeAt(i) >>> 8 & 0xFF, input.charCodeAt(i) & 0xFF);\n  }return output;\n}\n\n/*\r\n * Convert a raw string to an array of big-endian words\r\n * Characters >255 have their high-byte silently ignored.\r\n */\nfunction rstr2binb(input) {\n  var output = Array(input.length >> 2);\n  for (var i = 0; i < output.length; i++) {\n    output[i] = 0;\n  }for (var i = 0; i < input.length * 8; i += 8) {\n    output[i >> 5] |= (input.charCodeAt(i / 8) & 0xFF) << 24 - i % 32;\n  }return output;\n}\n\n/*\r\n * Convert an array of big-endian words to a string\r\n */\nfunction binb2rstr(input) {\n  var output = \"\";\n  for (var i = 0; i < input.length * 32; i += 8) {\n    output += String.fromCharCode(input[i >> 5] >>> 24 - i % 32 & 0xFF);\n  }return output;\n}\n\n/*\r\n * Calculate the SHA-1 of an array of big-endian words, and a bit length\r\n */\nfunction binb_sha1(x, len) {\n  /* append padding */\n  x[len >> 5] |= 0x80 << 24 - len % 32;\n  x[(len + 64 >> 9 << 4) + 15] = len;\n\n  var w = Array(80);\n  var a = 1732584193;\n  var b = -271733879;\n  var c = -1732584194;\n  var d = 271733878;\n  var e = -1009589776;\n\n  for (var i = 0; i < x.length; i += 16) {\n    var olda = a;\n    var oldb = b;\n    var oldc = c;\n    var oldd = d;\n    var olde = e;\n\n    for (var j = 0; j < 80; j++) {\n      if (j < 16) w[j] = x[i + j];else w[j] = bit_rol(w[j - 3] ^ w[j - 8] ^ w[j - 14] ^ w[j - 16], 1);\n      var t = safe_add(safe_add(bit_rol(a, 5), sha1_ft(j, b, c, d)), safe_add(safe_add(e, w[j]), sha1_kt(j)));\n      e = d;\n      d = c;\n      c = bit_rol(b, 30);\n      b = a;\n      a = t;\n    }\n\n    a = safe_add(a, olda);\n    b = safe_add(b, oldb);\n    c = safe_add(c, oldc);\n    d = safe_add(d, oldd);\n    e = safe_add(e, olde);\n  }\n  return Array(a, b, c, d, e);\n}\n\n/*\r\n * Perform the appropriate triplet combination function for the current\r\n * iteration\r\n */\nfunction sha1_ft(t, b, c, d) {\n  if (t < 20) return b & c | ~b & d;\n  if (t < 40) return b ^ c ^ d;\n  if (t < 60) return b & c | b & d | c & d;\n  return b ^ c ^ d;\n}\n\n/*\r\n * Determine the appropriate additive constant for the current iteration\r\n */\nfunction sha1_kt(t) {\n  return t < 20 ? 1518500249 : t < 40 ? 1859775393 : t < 60 ? -1894007588 : -899497514;\n}\n\n/*\r\n * Add integers, wrapping at 2^32. This uses 16-bit operations internally\r\n * to work around bugs in some JS interpreters.\r\n */\nfunction safe_add(x, y) {\n  var lsw = (x & 0xFFFF) + (y & 0xFFFF);\n  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);\n  return msw << 16 | lsw & 0xFFFF;\n}\n\n/*\r\n * Bitwise rotate a 32-bit number to the left.\r\n */\nfunction bit_rol(num, cnt) {\n  return num << cnt | num >>> 32 - cnt;\n}\n\nif (typeof module !== 'undefined') {\n  module.exports = {\n    b64_sha1: b64_sha1,\n    hex_sha1: hex_sha1\n  };\n}\n\n},{}],11:[function(require,module,exports){\n/* -*- mode: javascript; c-basic-offset: 4; indent-tabs-mode: nil -*- */\n\n// \n// Dalliance Genome Explorer\n// (c) Thomas Down 2006-2010\n//\n// spans.js: JavaScript Intset/Location port.\n//\n\n\"use strict\";\n\nfunction Range(min, max) {\n    if (typeof min != 'number' || typeof max != 'number') throw 'Bad range ' + min + ',' + max;\n    this._min = min;\n    this._max = max;\n}\n\nRange.prototype.min = function () {\n    return this._min;\n};\n\nRange.prototype.max = function () {\n    return this._max;\n};\n\nRange.prototype.contains = function (pos) {\n    return pos >= this._min && pos <= this._max;\n};\n\nRange.prototype.isContiguous = function () {\n    return true;\n};\n\nRange.prototype.ranges = function () {\n    return [this];\n};\n\nRange.prototype._pushRanges = function (ranges) {\n    ranges.push(this);\n};\n\nRange.prototype.toString = function () {\n    return '[' + this._min + '-' + this._max + ']';\n};\n\nfunction _Compound(ranges) {\n    // given: a set of unsorted possibly overlapping ranges\n    // sort the input ranges\n    var sorted = ranges.sort(_rangeOrder);\n    // merge overlaps between adjacent ranges\n    var merged = [];\n    var current = sorted.shift();\n    sorted.forEach(function (range) {\n        if (range._min <= current._max) {\n            if (range._max > current._max) {\n                current._max = range._max;\n            }\n        } else {\n            merged.push(current);\n            current = range;\n        }\n    });\n    merged.push(current);\n    this._ranges = merged;\n}\n\n_Compound.prototype.min = function () {\n    return this._ranges[0].min();\n};\n\n_Compound.prototype.max = function () {\n    return this._ranges[this._ranges.length - 1].max();\n};\n\n// returns the index of the first range that is not less than pos\n_Compound.prototype.lower_bound = function (pos) {\n    // first check if pos is out of range\n    var r = this.ranges();\n    if (pos > this.max()) return r.length;\n    if (pos < this.min()) return 0;\n    // do a binary search\n    var a = 0,\n        b = r.length - 1;\n    while (a <= b) {\n        var m = Math.floor((a + b) / 2);\n        if (pos > r[m]._max) {\n            a = m + 1;\n        } else if (pos < r[m]._min) {\n            b = m - 1;\n        } else {\n            return m;\n        }\n    }\n    return a;\n};\n\n_Compound.prototype.contains = function (pos) {\n    var lb = this.lower_bound(pos);\n    if (lb < this._ranges.length && this._ranges[lb].contains(pos)) {\n        return true;\n    }\n    return false;\n};\n\n_Compound.prototype.insertRange = function (range) {\n    var lb = this.lower_bound(range._min);\n    if (lb === this._ranges.length) {\n        // range follows this\n        this._ranges.push(range);\n        return;\n    }\n\n    var r = this.ranges();\n    if (range._max < r[lb]._min) {\n        // range preceeds lb\n        this._ranges.splice(lb, 0, range);\n        return;\n    }\n\n    // range overlaps lb (at least)\n    if (r[lb]._min < range._min) range._min = r[lb]._min;\n    var ub = lb + 1;\n    while (ub < r.length && r[ub]._min <= range._max) {\n        ub++;\n    }\n    ub--;\n    // ub is the upper bound of the new range\n    if (r[ub]._max > range._max) range._max = r[ub]._max;\n\n    // splice range into this._ranges\n    this._ranges.splice(lb, ub - lb + 1, range);\n    return;\n};\n\n_Compound.prototype.isContiguous = function () {\n    return this._ranges.length > 1;\n};\n\n_Compound.prototype.ranges = function () {\n    return this._ranges;\n};\n\n_Compound.prototype._pushRanges = function (ranges) {\n    for (var ri = 0; ri < this._ranges.length; ++ri) {\n        ranges.push(this._ranges[ri]);\n    }\n};\n\n_Compound.prototype.toString = function () {\n    var s = '';\n    for (var r = 0; r < this._ranges.length; ++r) {\n        if (r > 0) {\n            s = s + ',';\n        }\n        s = s + this._ranges[r].toString();\n    }\n    return s;\n};\n\nfunction union(s0, s1) {\n    if (!(s0 instanceof _Compound)) {\n        if (!(s0 instanceof Array)) s0 = [s0];\n        s0 = new _Compound(s0);\n    }\n\n    if (s1) s0.insertRange(s1);\n\n    return s0;\n}\n\nfunction intersection(s0, s1) {\n    var r0 = s0.ranges();\n    var r1 = s1.ranges();\n    var l0 = r0.length,\n        l1 = r1.length;\n    var i0 = 0,\n        i1 = 0;\n    var or = [];\n\n    while (i0 < l0 && i1 < l1) {\n        var s0 = r0[i0],\n            s1 = r1[i1];\n        var lapMin = Math.max(s0.min(), s1.min());\n        var lapMax = Math.min(s0.max(), s1.max());\n        if (lapMax >= lapMin) {\n            or.push(new Range(lapMin, lapMax));\n        }\n        if (s0.max() > s1.max()) {\n            ++i1;\n        } else {\n            ++i0;\n        }\n    }\n\n    if (or.length == 0) {\n        return null; // FIXME\n    } else if (or.length == 1) {\n        return or[0];\n    } else {\n        return new _Compound(or);\n    }\n}\n\nfunction coverage(s) {\n    var tot = 0;\n    var rl = s.ranges();\n    for (var ri = 0; ri < rl.length; ++ri) {\n        var r = rl[ri];\n        tot += r.max() - r.min() + 1;\n    }\n    return tot;\n}\n\nfunction rangeOrder(a, b) {\n    if (a.min() < b.min()) {\n        return -1;\n    } else if (a.min() > b.min()) {\n        return 1;\n    } else if (a.max() < b.max()) {\n        return -1;\n    } else if (b.max() > a.max()) {\n        return 1;\n    } else {\n        return 0;\n    }\n}\n\nfunction _rangeOrder(a, b) {\n    if (a._min < b._min) {\n        return -1;\n    } else if (a._min > b._min) {\n        return 1;\n    } else if (a._max < b._max) {\n        return -1;\n    } else if (b._max > a._max) {\n        return 1;\n    } else {\n        return 0;\n    }\n}\n\nif (typeof module !== 'undefined') {\n    module.exports = {\n        Range: Range,\n        union: union,\n        intersection: intersection,\n        coverage: coverage,\n        rangeOver: rangeOrder,\n        _rangeOrder: _rangeOrder\n    };\n}\n\n},{}],12:[function(require,module,exports){\n/* -*- mode: javascript; c-basic-offset: 4; indent-tabs-mode: nil -*- */\n\n// \n// Dalliance Genome Explorer\n// (c) Thomas Down 2006-2010\n//\n// utils.js: odds, sods, and ends.\n//\n\n\"use strict\";\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nif (typeof require !== 'undefined') {\n    var sha1 = require('./sha1');\n    var b64_sha1 = sha1.b64_sha1;\n}\n\nvar NUM_REGEXP = new RegExp('[0-9]+');\n\nfunction stringToNumbersArray(str) {\n    var nums = new Array();\n    var m;\n    while (m = NUM_REGEXP.exec(str)) {\n        nums.push(m[0]);\n        str = str.substring(m.index + m[0].length);\n    }\n    return nums;\n}\n\nvar STRICT_NUM_REGEXP = new RegExp('^[0-9]+$');\n\nfunction stringToInt(str) {\n    str = str.replace(new RegExp(',', 'g'), '');\n    if (!STRICT_NUM_REGEXP.test(str)) {\n        return null;\n    }\n    return str | 0;\n}\n\nfunction pushnew(a, v) {\n    for (var i = 0; i < a.length; ++i) {\n        if (a[i] == v) {\n            return;\n        }\n    }\n    a.push(v);\n}\n\nfunction pusho(obj, k, v) {\n    if (obj[k]) {\n        obj[k].push(v);\n    } else {\n        obj[k] = [v];\n    }\n}\n\nfunction pushnewo(obj, k, v) {\n    var a = obj[k];\n    if (a) {\n        for (var i = 0; i < a.length; ++i) {\n            // indexOf requires JS16 :-(.\n            if (a[i] == v) {\n                return;\n            }\n        }\n        a.push(v);\n    } else {\n        obj[k] = [v];\n    }\n}\n\nfunction pick(a, b, c, d) {\n    if (a) {\n        return a;\n    } else if (b) {\n        return b;\n    } else if (c) {\n        return c;\n    } else if (d) {\n        return d;\n    }\n}\n\nfunction pushnew(l, o) {\n    for (var i = 0; i < l.length; ++i) {\n        if (l[i] == o) {\n            return;\n        }\n    }\n    l.push(o);\n}\n\nfunction arrayIndexOf(a, x) {\n    if (!a) {\n        return -1;\n    }\n\n    for (var i = 0; i < a.length; ++i) {\n        if (a[i] === x) {\n            return i;\n        }\n    }\n    return -1;\n}\n\nfunction arrayRemove(a, x) {\n    var i = arrayIndexOf(a, x);\n    if (i >= 0) {\n        a.splice(i, 1);\n        return true;\n    }\n    return false;\n}\n\n//\n// DOM utilities\n//\n\n\nfunction makeElement(tag, children, attribs, styles) {\n    var ele = document.createElement(tag);\n    if (children) {\n        if (!(children instanceof Array)) {\n            children = [children];\n        }\n        for (var i = 0; i < children.length; ++i) {\n            var c = children[i];\n            if (c) {\n                if (typeof c == 'string') {\n                    c = document.createTextNode(c);\n                } else if (typeof c == 'number') {\n                    c = document.createTextNode('' + c);\n                }\n                ele.appendChild(c);\n            }\n        }\n    }\n\n    if (attribs) {\n        for (var l in attribs) {\n            try {\n                ele[l] = attribs[l];\n            } catch (e) {\n                console.log('error setting ' + l);\n                throw e;\n            }\n        }\n    }\n    if (styles) {\n        for (var l in styles) {\n            ele.style[l] = styles[l];\n        }\n    }\n    return ele;\n}\n\nfunction makeElementNS(namespace, tag, children, attribs) {\n    var ele = document.createElementNS(namespace, tag);\n    if (children) {\n        if (!(children instanceof Array)) {\n            children = [children];\n        }\n        for (var i = 0; i < children.length; ++i) {\n            var c = children[i];\n            if (typeof c == 'string') {\n                c = document.createTextNode(c);\n            }\n            ele.appendChild(c);\n        }\n    }\n\n    setAttrs(ele, attribs);\n    return ele;\n}\n\nvar attr_name_cache = {};\n\nfunction setAttr(node, key, value) {\n    var attr = attr_name_cache[key];\n    if (!attr) {\n        var _attr = '';\n        for (var c = 0; c < key.length; ++c) {\n            var cc = key.substring(c, c + 1);\n            var lcc = cc.toLowerCase();\n            if (lcc != cc) {\n                _attr = _attr + '-' + lcc;\n            } else {\n                _attr = _attr + cc;\n            }\n        }\n        attr_name_cache[key] = _attr;\n        attr = _attr;\n    }\n    node.setAttribute(attr, value);\n}\n\nfunction setAttrs(node, attribs) {\n    if (attribs) {\n        for (var l in attribs) {\n            setAttr(node, l, attribs[l]);\n        }\n    }\n}\n\nfunction removeChildren(node) {\n    if (!node || !node.childNodes) {\n        return;\n    }\n\n    while (node.childNodes.length > 0) {\n        node.removeChild(node.firstChild);\n    }\n}\n\n//\n// WARNING: not for general use!\n//\n\nfunction miniJSONify(o, exc) {\n    if (typeof o === 'undefined') {\n        return 'undefined';\n    } else if (o == null) {\n        return 'null';\n    } else if (typeof o == 'string') {\n        return \"'\" + o + \"'\";\n    } else if (typeof o == 'number') {\n        return \"\" + o;\n    } else if (typeof o == 'boolean') {\n        return \"\" + o;\n    } else if ((typeof o === 'undefined' ? 'undefined' : _typeof(o)) == 'object') {\n        if (o instanceof Array) {\n            var s = null;\n            for (var i = 0; i < o.length; ++i) {\n                s = (s == null ? '' : s + ', ') + miniJSONify(o[i], exc);\n            }\n            return '[' + (s ? s : '') + ']';\n        } else {\n            exc = exc || {};\n            var s = null;\n            for (var k in o) {\n                if (exc[k]) continue;\n                if (k != undefined && typeof o[k] != 'function') {\n                    s = (s == null ? '' : s + ', ') + k + ': ' + miniJSONify(o[k], exc);\n                }\n            }\n            return '{' + (s ? s : '') + '}';\n        }\n    } else {\n        return typeof o === 'undefined' ? 'undefined' : _typeof(o);\n    }\n}\n\nfunction shallowCopy(o) {\n    var n = {};\n    for (var k in o) {\n        n[k] = o[k];\n    }\n    return n;\n}\n\nfunction Observed(x) {\n    this.value = x;\n    this.listeners = [];\n}\n\nObserved.prototype.addListener = function (f) {\n    this.listeners.push(f);\n};\n\nObserved.prototype.addListenerAndFire = function (f) {\n    this.listeners.push(f);\n    f(this.value);\n};\n\nObserved.prototype.removeListener = function (f) {\n    arrayRemove(this.listeners, f);\n};\n\nObserved.prototype.get = function () {\n    return this.value;\n};\n\nObserved.prototype.set = function (x) {\n    this.value = x;\n    for (var i = 0; i < this.listeners.length; ++i) {\n        this.listeners[i](x);\n    }\n};\n\nfunction Awaited() {\n    this.queue = [];\n}\n\nAwaited.prototype.provide = function (x) {\n    if (this.res !== undefined) {\n        throw \"Resource has already been provided.\";\n    }\n\n    this.res = x;\n    for (var i = 0; i < this.queue.length; ++i) {\n        this.queue[i](x);\n    }\n    this.queue = null; // avoid leaking closures.\n};\n\nAwaited.prototype.await = function (f) {\n    if (this.res !== undefined) {\n        f(this.res);\n        return this.res;\n    } else {\n        this.queue.push(f);\n    }\n};\n\nvar __dalliance_saltSeed = 0;\n\nfunction saltURL(url) {\n    return url + '?salt=' + b64_sha1('' + Date.now() + ',' + ++__dalliance_saltSeed);\n}\n\nfunction textXHR(url, callback, opts) {\n    if (opts && opts.salt) url = saltURL(url);\n\n    try {\n        var timeout;\n        if (opts && opts.timeout) {\n            timeout = setTimeout(function () {\n                console.log('timing out ' + url);\n                req.abort();\n                return callback(null, 'Timeout');\n            }, opts.timeout);\n        }\n\n        var req = new XMLHttpRequest();\n        req.onreadystatechange = function () {\n            if (req.readyState == 4) {\n                if (timeout) clearTimeout(timeout);\n                if (req.status < 200 || req.status >= 300) {\n                    callback(null, 'Error code ' + req.status);\n                } else {\n                    callback(req.responseText);\n                }\n            }\n        };\n\n        req.open('GET', url, true);\n        req.responseType = 'text';\n\n        if (opts && opts.credentials) {\n            req.withCredentials = true;\n        }\n        req.send();\n    } catch (e) {\n        callback(null, 'Exception ' + e);\n    }\n}\n\nfunction relativeURL(base, rel) {\n    // FIXME quite naive -- good enough for trackhubs?\n\n    if (rel.indexOf('http:') == 0 || rel.indexOf('https:') == 0) {\n        return rel;\n    }\n\n    var li = base.lastIndexOf('/');\n    if (li >= 0) {\n        return base.substr(0, li + 1) + rel;\n    } else {\n        return rel;\n    }\n}\n\nvar AMINO_ACID_TRANSLATION = {\n    'TTT': 'F',\n    'TTC': 'F',\n    'TTA': 'L',\n    'TTG': 'L',\n    'CTT': 'L',\n    'CTC': 'L',\n    'CTA': 'L',\n    'CTG': 'L',\n    'ATT': 'I',\n    'ATC': 'I',\n    'ATA': 'I',\n    'ATG': 'M',\n    'GTT': 'V',\n    'GTC': 'V',\n    'GTA': 'V',\n    'GTG': 'V',\n    'TCT': 'S',\n    'TCC': 'S',\n    'TCA': 'S',\n    'TCG': 'S',\n    'CCT': 'P',\n    'CCC': 'P',\n    'CCA': 'P',\n    'CCG': 'P',\n    'ACT': 'T',\n    'ACC': 'T',\n    'ACA': 'T',\n    'ACG': 'T',\n    'GCT': 'A',\n    'GCC': 'A',\n    'GCA': 'A',\n    'GCG': 'A',\n    'TAT': 'Y',\n    'TAC': 'Y',\n    'TAA': '*', // stop\n    'TAG': '*', // stop\n    'CAT': 'H',\n    'CAC': 'H',\n    'CAA': 'Q',\n    'CAG': 'Q',\n    'AAT': 'N',\n    'AAC': 'N',\n    'AAA': 'K',\n    'AAG': 'K',\n    'GAT': 'D',\n    'GAC': 'D',\n    'GAA': 'E',\n    'GAG': 'E',\n    'TGT': 'C',\n    'TGC': 'C',\n    'TGA': '*', // stop\n    'TGG': 'W',\n    'CGT': 'R',\n    'CGC': 'R',\n    'CGA': 'R',\n    'CGG': 'R',\n    'AGT': 'S',\n    'AGC': 'S',\n    'AGA': 'R',\n    'AGG': 'R',\n    'GGT': 'G',\n    'GGC': 'G',\n    'GGA': 'G',\n    'GGG': 'G'\n};\n\nfunction resolveUrlToPage(rel) {\n    return makeElement('a', null, { href: rel }).href;\n}\n\n//\n// Missing APIs\n// \n\nif (!('trim' in String.prototype)) {\n    String.prototype.trim = function () {\n        return this.replace(/^\\s+/, '').replace(/\\s+$/, '');\n    };\n}\n\nif (typeof module !== 'undefined') {\n    module.exports = {\n        textXHR: textXHR,\n        relativeURL: relativeURL,\n        resolveUrlToPage: resolveUrlToPage,\n        shallowCopy: shallowCopy,\n        pusho: pusho,\n        pushnew: pushnew,\n        pushnewo: pushnewo,\n        arrayIndexOf: arrayIndexOf,\n        pick: pick,\n\n        makeElement: makeElement,\n        makeElementNS: makeElementNS,\n        removeChildren: removeChildren,\n\n        miniJSONify: miniJSONify,\n\n        Observed: Observed,\n        Awaited: Awaited,\n\n        AMINO_ACID_TRANSLATION: AMINO_ACID_TRANSLATION\n    };\n}\n\n},{\"./sha1\":10}],13:[function(require,module,exports){\n\"use strict\";\nvar Promise = require(\"./promise/promise\").Promise;\nvar polyfill = require(\"./promise/polyfill\").polyfill;\nexports.Promise = Promise;\nexports.polyfill = polyfill;\n},{\"./promise/polyfill\":18,\"./promise/promise\":19}],14:[function(require,module,exports){\n\"use strict\";\n/* global toString */\n\nvar isArray = require(\"./utils\").isArray;\nvar isFunction = require(\"./utils\").isFunction;\n\n/**\n  Returns a promise that is fulfilled when all the given promises have been\n  fulfilled, or rejected if any of them become rejected. The return promise\n  is fulfilled with an array that gives all the values in the order they were\n  passed in the `promises` array argument.\n\n  Example:\n\n  ```javascript\n  var promise1 = RSVP.resolve(1);\n  var promise2 = RSVP.resolve(2);\n  var promise3 = RSVP.resolve(3);\n  var promises = [ promise1, promise2, promise3 ];\n\n  RSVP.all(promises).then(function(array){\n    // The array here would be [ 1, 2, 3 ];\n  });\n  ```\n\n  If any of the `promises` given to `RSVP.all` are rejected, the first promise\n  that is rejected will be given as an argument to the returned promises's\n  rejection handler. For example:\n\n  Example:\n\n  ```javascript\n  var promise1 = RSVP.resolve(1);\n  var promise2 = RSVP.reject(new Error(\"2\"));\n  var promise3 = RSVP.reject(new Error(\"3\"));\n  var promises = [ promise1, promise2, promise3 ];\n\n  RSVP.all(promises).then(function(array){\n    // Code here never runs because there are rejected promises!\n  }, function(error) {\n    // error.message === \"2\"\n  });\n  ```\n\n  @method all\n  @for RSVP\n  @param {Array} promises\n  @param {String} label\n  @return {Promise} promise that is fulfilled when all `promises` have been\n  fulfilled, or rejected if any of them become rejected.\n*/\nfunction all(promises) {\n  /*jshint validthis:true */\n  var Promise = this;\n\n  if (!isArray(promises)) {\n    throw new TypeError('You must pass an array to all.');\n  }\n\n  return new Promise(function(resolve, reject) {\n    var results = [], remaining = promises.length,\n    promise;\n\n    if (remaining === 0) {\n      resolve([]);\n    }\n\n    function resolver(index) {\n      return function(value) {\n        resolveAll(index, value);\n      };\n    }\n\n    function resolveAll(index, value) {\n      results[index] = value;\n      if (--remaining === 0) {\n        resolve(results);\n      }\n    }\n\n    for (var i = 0; i < promises.length; i++) {\n      promise = promises[i];\n\n      if (promise && isFunction(promise.then)) {\n        promise.then(resolver(i), reject);\n      } else {\n        resolveAll(i, promise);\n      }\n    }\n  });\n}\n\nexports.all = all;\n},{\"./utils\":23}],15:[function(require,module,exports){\n(function (process,global){\n\"use strict\";\nvar browserGlobal = (typeof window !== 'undefined') ? window : {};\nvar BrowserMutationObserver = browserGlobal.MutationObserver || browserGlobal.WebKitMutationObserver;\nvar local = (typeof global !== 'undefined') ? global : (this === undefined? window:this);\n\n// node\nfunction useNextTick() {\n  return function() {\n    process.nextTick(flush);\n  };\n}\n\nfunction useMutationObserver() {\n  var iterations = 0;\n  var observer = new BrowserMutationObserver(flush);\n  var node = document.createTextNode('');\n  observer.observe(node, { characterData: true });\n\n  return function() {\n    node.data = (iterations = ++iterations % 2);\n  };\n}\n\nfunction useSetTimeout() {\n  return function() {\n    local.setTimeout(flush, 1);\n  };\n}\n\nvar queue = [];\nfunction flush() {\n  for (var i = 0; i < queue.length; i++) {\n    var tuple = queue[i];\n    var callback = tuple[0], arg = tuple[1];\n    callback(arg);\n  }\n  queue = [];\n}\n\nvar scheduleFlush;\n\n// Decide what async method to use to triggering processing of queued callbacks:\nif (typeof process !== 'undefined' && {}.toString.call(process) === '[object process]') {\n  scheduleFlush = useNextTick();\n} else if (BrowserMutationObserver) {\n  scheduleFlush = useMutationObserver();\n} else {\n  scheduleFlush = useSetTimeout();\n}\n\nfunction asap(callback, arg) {\n  var length = queue.push([callback, arg]);\n  if (length === 1) {\n    // If length is 1, that means that we need to schedule an async flush.\n    // If additional callbacks are queued before the queue is flushed, they\n    // will be processed by this flush that we are scheduling.\n    scheduleFlush();\n  }\n}\n\nexports.asap = asap;\n}).call(this,require('_process'),typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{\"_process\":25}],16:[function(require,module,exports){\n\"use strict\";\n/**\n  `RSVP.Promise.cast` returns the same promise if that promise shares a constructor\n  with the promise being casted.\n\n  Example:\n\n  ```javascript\n  var promise = RSVP.resolve(1);\n  var casted = RSVP.Promise.cast(promise);\n\n  console.log(promise === casted); // true\n  ```\n\n  In the case of a promise whose constructor does not match, it is assimilated.\n  The resulting promise will fulfill or reject based on the outcome of the\n  promise being casted.\n\n  In the case of a non-promise, a promise which will fulfill with that value is\n  returned.\n\n  Example:\n\n  ```javascript\n  var value = 1; // could be a number, boolean, string, undefined...\n  var casted = RSVP.Promise.cast(value);\n\n  console.log(value === casted); // false\n  console.log(casted instanceof RSVP.Promise) // true\n\n  casted.then(function(val) {\n    val === value // => true\n  });\n  ```\n\n  `RSVP.Promise.cast` is similar to `RSVP.resolve`, but `RSVP.Promise.cast` differs in the\n  following ways:\n  * `RSVP.Promise.cast` serves as a memory-efficient way of getting a promise, when you\n  have something that could either be a promise or a value. RSVP.resolve\n  will have the same effect but will create a new promise wrapper if the\n  argument is a promise.\n  * `RSVP.Promise.cast` is a way of casting incoming thenables or promise subclasses to\n  promises of the exact class specified, so that the resulting object's `then` is\n  ensured to have the behavior of the constructor you are calling cast on (i.e., RSVP.Promise).\n\n  @method cast\n  @for RSVP\n  @param {Object} object to be casted\n  @return {Promise} promise that is fulfilled when all properties of `promises`\n  have been fulfilled, or rejected if any of them become rejected.\n*/\n\n\nfunction cast(object) {\n  /*jshint validthis:true */\n  if (object && typeof object === 'object' && object.constructor === this) {\n    return object;\n  }\n\n  var Promise = this;\n\n  return new Promise(function(resolve) {\n    resolve(object);\n  });\n}\n\nexports.cast = cast;\n},{}],17:[function(require,module,exports){\n\"use strict\";\nvar config = {\n  instrument: false\n};\n\nfunction configure(name, value) {\n  if (arguments.length === 2) {\n    config[name] = value;\n  } else {\n    return config[name];\n  }\n}\n\nexports.config = config;\nexports.configure = configure;\n},{}],18:[function(require,module,exports){\n(function (global){\n\"use strict\";\n/*global self*/\nvar RSVPPromise = require(\"./promise\").Promise;\nvar isFunction = require(\"./utils\").isFunction;\n\nfunction polyfill() {\n  var local;\n\n  if (typeof global !== 'undefined') {\n    local = global;\n  } else if (typeof window !== 'undefined' && window.document) {\n    local = window;\n  } else {\n    local = self;\n  }\n\n  var es6PromiseSupport = \n    \"Promise\" in local &&\n    // Some of these methods are missing from\n    // Firefox/Chrome experimental implementations\n    \"cast\" in local.Promise &&\n    \"resolve\" in local.Promise &&\n    \"reject\" in local.Promise &&\n    \"all\" in local.Promise &&\n    \"race\" in local.Promise &&\n    // Older version of the spec had a resolver object\n    // as the arg rather than a function\n    (function() {\n      var resolve;\n      new local.Promise(function(r) { resolve = r; });\n      return isFunction(resolve);\n    }());\n\n  if (!es6PromiseSupport) {\n    local.Promise = RSVPPromise;\n  }\n}\n\nexports.polyfill = polyfill;\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{\"./promise\":19,\"./utils\":23}],19:[function(require,module,exports){\n\"use strict\";\nvar config = require(\"./config\").config;\nvar configure = require(\"./config\").configure;\nvar objectOrFunction = require(\"./utils\").objectOrFunction;\nvar isFunction = require(\"./utils\").isFunction;\nvar now = require(\"./utils\").now;\nvar cast = require(\"./cast\").cast;\nvar all = require(\"./all\").all;\nvar race = require(\"./race\").race;\nvar staticResolve = require(\"./resolve\").resolve;\nvar staticReject = require(\"./reject\").reject;\nvar asap = require(\"./asap\").asap;\n\nvar counter = 0;\n\nconfig.async = asap; // default async is asap;\n\nfunction Promise(resolver) {\n  if (!isFunction(resolver)) {\n    throw new TypeError('You must pass a resolver function as the first argument to the promise constructor');\n  }\n\n  if (!(this instanceof Promise)) {\n    throw new TypeError(\"Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.\");\n  }\n\n  this._subscribers = [];\n\n  invokeResolver(resolver, this);\n}\n\nfunction invokeResolver(resolver, promise) {\n  function resolvePromise(value) {\n    resolve(promise, value);\n  }\n\n  function rejectPromise(reason) {\n    reject(promise, reason);\n  }\n\n  try {\n    resolver(resolvePromise, rejectPromise);\n  } catch(e) {\n    rejectPromise(e);\n  }\n}\n\nfunction invokeCallback(settled, promise, callback, detail) {\n  var hasCallback = isFunction(callback),\n      value, error, succeeded, failed;\n\n  if (hasCallback) {\n    try {\n      value = callback(detail);\n      succeeded = true;\n    } catch(e) {\n      failed = true;\n      error = e;\n    }\n  } else {\n    value = detail;\n    succeeded = true;\n  }\n\n  if (handleThenable(promise, value)) {\n    return;\n  } else if (hasCallback && succeeded) {\n    resolve(promise, value);\n  } else if (failed) {\n    reject(promise, error);\n  } else if (settled === FULFILLED) {\n    resolve(promise, value);\n  } else if (settled === REJECTED) {\n    reject(promise, value);\n  }\n}\n\nvar PENDING   = void 0;\nvar SEALED    = 0;\nvar FULFILLED = 1;\nvar REJECTED  = 2;\n\nfunction subscribe(parent, child, onFulfillment, onRejection) {\n  var subscribers = parent._subscribers;\n  var length = subscribers.length;\n\n  subscribers[length] = child;\n  subscribers[length + FULFILLED] = onFulfillment;\n  subscribers[length + REJECTED]  = onRejection;\n}\n\nfunction publish(promise, settled) {\n  var child, callback, subscribers = promise._subscribers, detail = promise._detail;\n\n  for (var i = 0; i < subscribers.length; i += 3) {\n    child = subscribers[i];\n    callback = subscribers[i + settled];\n\n    invokeCallback(settled, child, callback, detail);\n  }\n\n  promise._subscribers = null;\n}\n\nPromise.prototype = {\n  constructor: Promise,\n\n  _state: undefined,\n  _detail: undefined,\n  _subscribers: undefined,\n\n  then: function(onFulfillment, onRejection) {\n    var promise = this;\n\n    var thenPromise = new this.constructor(function() {});\n\n    if (this._state) {\n      var callbacks = arguments;\n      config.async(function invokePromiseCallback() {\n        invokeCallback(promise._state, thenPromise, callbacks[promise._state - 1], promise._detail);\n      });\n    } else {\n      subscribe(this, thenPromise, onFulfillment, onRejection);\n    }\n\n    return thenPromise;\n  },\n\n  'catch': function(onRejection) {\n    return this.then(null, onRejection);\n  }\n};\n\nPromise.all = all;\nPromise.cast = cast;\nPromise.race = race;\nPromise.resolve = staticResolve;\nPromise.reject = staticReject;\n\nfunction handleThenable(promise, value) {\n  var then = null,\n  resolved;\n\n  try {\n    if (promise === value) {\n      throw new TypeError(\"A promises callback cannot return that same promise.\");\n    }\n\n    if (objectOrFunction(value)) {\n      then = value.then;\n\n      if (isFunction(then)) {\n        then.call(value, function(val) {\n          if (resolved) { return true; }\n          resolved = true;\n\n          if (value !== val) {\n            resolve(promise, val);\n          } else {\n            fulfill(promise, val);\n          }\n        }, function(val) {\n          if (resolved) { return true; }\n          resolved = true;\n\n          reject(promise, val);\n        });\n\n        return true;\n      }\n    }\n  } catch (error) {\n    if (resolved) { return true; }\n    reject(promise, error);\n    return true;\n  }\n\n  return false;\n}\n\nfunction resolve(promise, value) {\n  if (promise === value) {\n    fulfill(promise, value);\n  } else if (!handleThenable(promise, value)) {\n    fulfill(promise, value);\n  }\n}\n\nfunction fulfill(promise, value) {\n  if (promise._state !== PENDING) { return; }\n  promise._state = SEALED;\n  promise._detail = value;\n\n  config.async(publishFulfillment, promise);\n}\n\nfunction reject(promise, reason) {\n  if (promise._state !== PENDING) { return; }\n  promise._state = SEALED;\n  promise._detail = reason;\n\n  config.async(publishRejection, promise);\n}\n\nfunction publishFulfillment(promise) {\n  publish(promise, promise._state = FULFILLED);\n}\n\nfunction publishRejection(promise) {\n  publish(promise, promise._state = REJECTED);\n}\n\nexports.Promise = Promise;\n},{\"./all\":14,\"./asap\":15,\"./cast\":16,\"./config\":17,\"./race\":20,\"./reject\":21,\"./resolve\":22,\"./utils\":23}],20:[function(require,module,exports){\n\"use strict\";\n/* global toString */\nvar isArray = require(\"./utils\").isArray;\n\n/**\n  `RSVP.race` allows you to watch a series of promises and act as soon as the\n  first promise given to the `promises` argument fulfills or rejects.\n\n  Example:\n\n  ```javascript\n  var promise1 = new RSVP.Promise(function(resolve, reject){\n    setTimeout(function(){\n      resolve(\"promise 1\");\n    }, 200);\n  });\n\n  var promise2 = new RSVP.Promise(function(resolve, reject){\n    setTimeout(function(){\n      resolve(\"promise 2\");\n    }, 100);\n  });\n\n  RSVP.race([promise1, promise2]).then(function(result){\n    // result === \"promise 2\" because it was resolved before promise1\n    // was resolved.\n  });\n  ```\n\n  `RSVP.race` is deterministic in that only the state of the first completed\n  promise matters. For example, even if other promises given to the `promises`\n  array argument are resolved, but the first completed promise has become\n  rejected before the other promises became fulfilled, the returned promise\n  will become rejected:\n\n  ```javascript\n  var promise1 = new RSVP.Promise(function(resolve, reject){\n    setTimeout(function(){\n      resolve(\"promise 1\");\n    }, 200);\n  });\n\n  var promise2 = new RSVP.Promise(function(resolve, reject){\n    setTimeout(function(){\n      reject(new Error(\"promise 2\"));\n    }, 100);\n  });\n\n  RSVP.race([promise1, promise2]).then(function(result){\n    // Code here never runs because there are rejected promises!\n  }, function(reason){\n    // reason.message === \"promise2\" because promise 2 became rejected before\n    // promise 1 became fulfilled\n  });\n  ```\n\n  @method race\n  @for RSVP\n  @param {Array} promises array of promises to observe\n  @param {String} label optional string for describing the promise returned.\n  Useful for tooling.\n  @return {Promise} a promise that becomes fulfilled with the value the first\n  completed promises is resolved with if the first completed promise was\n  fulfilled, or rejected with the reason that the first completed promise\n  was rejected with.\n*/\nfunction race(promises) {\n  /*jshint validthis:true */\n  var Promise = this;\n\n  if (!isArray(promises)) {\n    throw new TypeError('You must pass an array to race.');\n  }\n  return new Promise(function(resolve, reject) {\n    var results = [], promise;\n\n    for (var i = 0; i < promises.length; i++) {\n      promise = promises[i];\n\n      if (promise && typeof promise.then === 'function') {\n        promise.then(resolve, reject);\n      } else {\n        resolve(promise);\n      }\n    }\n  });\n}\n\nexports.race = race;\n},{\"./utils\":23}],21:[function(require,module,exports){\n\"use strict\";\n/**\n  `RSVP.reject` returns a promise that will become rejected with the passed\n  `reason`. `RSVP.reject` is essentially shorthand for the following:\n\n  ```javascript\n  var promise = new RSVP.Promise(function(resolve, reject){\n    reject(new Error('WHOOPS'));\n  });\n\n  promise.then(function(value){\n    // Code here doesn't run because the promise is rejected!\n  }, function(reason){\n    // reason.message === 'WHOOPS'\n  });\n  ```\n\n  Instead of writing the above, your code now simply becomes the following:\n\n  ```javascript\n  var promise = RSVP.reject(new Error('WHOOPS'));\n\n  promise.then(function(value){\n    // Code here doesn't run because the promise is rejected!\n  }, function(reason){\n    // reason.message === 'WHOOPS'\n  });\n  ```\n\n  @method reject\n  @for RSVP\n  @param {Any} reason value that the returned promise will be rejected with.\n  @param {String} label optional string for identifying the returned promise.\n  Useful for tooling.\n  @return {Promise} a promise that will become rejected with the given\n  `reason`.\n*/\nfunction reject(reason) {\n  /*jshint validthis:true */\n  var Promise = this;\n\n  return new Promise(function (resolve, reject) {\n    reject(reason);\n  });\n}\n\nexports.reject = reject;\n},{}],22:[function(require,module,exports){\n\"use strict\";\n/**\n  `RSVP.resolve` returns a promise that will become fulfilled with the passed\n  `value`. `RSVP.resolve` is essentially shorthand for the following:\n\n  ```javascript\n  var promise = new RSVP.Promise(function(resolve, reject){\n    resolve(1);\n  });\n\n  promise.then(function(value){\n    // value === 1\n  });\n  ```\n\n  Instead of writing the above, your code now simply becomes the following:\n\n  ```javascript\n  var promise = RSVP.resolve(1);\n\n  promise.then(function(value){\n    // value === 1\n  });\n  ```\n\n  @method resolve\n  @for RSVP\n  @param {Any} value value that the returned promise will be resolved with\n  @param {String} label optional string for identifying the returned promise.\n  Useful for tooling.\n  @return {Promise} a promise that will become fulfilled with the given\n  `value`\n*/\nfunction resolve(value) {\n  /*jshint validthis:true */\n  var Promise = this;\n  return new Promise(function(resolve, reject) {\n    resolve(value);\n  });\n}\n\nexports.resolve = resolve;\n},{}],23:[function(require,module,exports){\n\"use strict\";\nfunction objectOrFunction(x) {\n  return isFunction(x) || (typeof x === \"object\" && x !== null);\n}\n\nfunction isFunction(x) {\n  return typeof x === \"function\";\n}\n\nfunction isArray(x) {\n  return Object.prototype.toString.call(x) === \"[object Array]\";\n}\n\n// Date.now is not available in browsers < IE9\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/now#Compatibility\nvar now = Date.now || function() { return new Date().getTime(); };\n\n\nexports.objectOrFunction = objectOrFunction;\nexports.isFunction = isFunction;\nexports.isArray = isArray;\nexports.now = now;\n},{}],24:[function(require,module,exports){\n/* -*- mode: javascript; c-basic-offset: 4; indent-tabs-mode: nil -*- */\n\n// \n// Javascript ZLib\n// By Thomas Down 2010-2011\n//\n// Based very heavily on portions of jzlib (by ymnk@jcraft.com), who in\n// turn credits Jean-loup Gailly and Mark Adler for the original zlib code.\n//\n// inflate.js: ZLib inflate code\n//\n\n//\n// Shared constants\n//\n\nvar MAX_WBITS=15; // 32K LZ77 window\nvar DEF_WBITS=MAX_WBITS;\nvar MAX_MEM_LEVEL=9;\nvar MANY=1440;\nvar BMAX = 15;\n\n// preset dictionary flag in zlib header\nvar PRESET_DICT=0x20;\n\nvar Z_NO_FLUSH=0;\nvar Z_PARTIAL_FLUSH=1;\nvar Z_SYNC_FLUSH=2;\nvar Z_FULL_FLUSH=3;\nvar Z_FINISH=4;\n\nvar Z_DEFLATED=8;\n\nvar Z_OK=0;\nvar Z_STREAM_END=1;\nvar Z_NEED_DICT=2;\nvar Z_ERRNO=-1;\nvar Z_STREAM_ERROR=-2;\nvar Z_DATA_ERROR=-3;\nvar Z_MEM_ERROR=-4;\nvar Z_BUF_ERROR=-5;\nvar Z_VERSION_ERROR=-6;\n\nvar METHOD=0;   // waiting for method byte\nvar FLAG=1;     // waiting for flag byte\nvar DICT4=2;    // four dictionary check bytes to go\nvar DICT3=3;    // three dictionary check bytes to go\nvar DICT2=4;    // two dictionary check bytes to go\nvar DICT1=5;    // one dictionary check byte to go\nvar DICT0=6;    // waiting for inflateSetDictionary\nvar BLOCKS=7;   // decompressing blocks\nvar CHECK4=8;   // four check bytes to go\nvar CHECK3=9;   // three check bytes to go\nvar CHECK2=10;  // two check bytes to go\nvar CHECK1=11;  // one check byte to go\nvar DONE=12;    // finished check, done\nvar BAD=13;     // got an error--stay here\n\nvar inflate_mask = [0x00000000, 0x00000001, 0x00000003, 0x00000007, 0x0000000f, 0x0000001f, 0x0000003f, 0x0000007f, 0x000000ff, 0x000001ff, 0x000003ff, 0x000007ff, 0x00000fff, 0x00001fff, 0x00003fff, 0x00007fff, 0x0000ffff];\n\nvar IB_TYPE=0;  // get type bits (3, including end bit)\nvar IB_LENS=1;  // get lengths for stored\nvar IB_STORED=2;// processing stored block\nvar IB_TABLE=3; // get table lengths\nvar IB_BTREE=4; // get bit lengths tree for a dynamic block\nvar IB_DTREE=5; // get length, distance trees for a dynamic block\nvar IB_CODES=6; // processing fixed or dynamic block\nvar IB_DRY=7;   // output remaining window bytes\nvar IB_DONE=8;  // finished last block, done\nvar IB_BAD=9;   // ot a data error--stuck here\n\nvar fixed_bl = 9;\nvar fixed_bd = 5;\n\nvar fixed_tl = [\n    96,7,256, 0,8,80, 0,8,16, 84,8,115,\n    82,7,31, 0,8,112, 0,8,48, 0,9,192,\n    80,7,10, 0,8,96, 0,8,32, 0,9,160,\n    0,8,0, 0,8,128, 0,8,64, 0,9,224,\n    80,7,6, 0,8,88, 0,8,24, 0,9,144,\n    83,7,59, 0,8,120, 0,8,56, 0,9,208,\n    81,7,17, 0,8,104, 0,8,40, 0,9,176,\n    0,8,8, 0,8,136, 0,8,72, 0,9,240,\n    80,7,4, 0,8,84, 0,8,20, 85,8,227,\n    83,7,43, 0,8,116, 0,8,52, 0,9,200,\n    81,7,13, 0,8,100, 0,8,36, 0,9,168,\n    0,8,4, 0,8,132, 0,8,68, 0,9,232,\n    80,7,8, 0,8,92, 0,8,28, 0,9,152,\n    84,7,83, 0,8,124, 0,8,60, 0,9,216,\n    82,7,23, 0,8,108, 0,8,44, 0,9,184,\n    0,8,12, 0,8,140, 0,8,76, 0,9,248,\n    80,7,3, 0,8,82, 0,8,18, 85,8,163,\n    83,7,35, 0,8,114, 0,8,50, 0,9,196,\n    81,7,11, 0,8,98, 0,8,34, 0,9,164,\n    0,8,2, 0,8,130, 0,8,66, 0,9,228,\n    80,7,7, 0,8,90, 0,8,26, 0,9,148,\n    84,7,67, 0,8,122, 0,8,58, 0,9,212,\n    82,7,19, 0,8,106, 0,8,42, 0,9,180,\n    0,8,10, 0,8,138, 0,8,74, 0,9,244,\n    80,7,5, 0,8,86, 0,8,22, 192,8,0,\n    83,7,51, 0,8,118, 0,8,54, 0,9,204,\n    81,7,15, 0,8,102, 0,8,38, 0,9,172,\n    0,8,6, 0,8,134, 0,8,70, 0,9,236,\n    80,7,9, 0,8,94, 0,8,30, 0,9,156,\n    84,7,99, 0,8,126, 0,8,62, 0,9,220,\n    82,7,27, 0,8,110, 0,8,46, 0,9,188,\n    0,8,14, 0,8,142, 0,8,78, 0,9,252,\n    96,7,256, 0,8,81, 0,8,17, 85,8,131,\n    82,7,31, 0,8,113, 0,8,49, 0,9,194,\n    80,7,10, 0,8,97, 0,8,33, 0,9,162,\n    0,8,1, 0,8,129, 0,8,65, 0,9,226,\n    80,7,6, 0,8,89, 0,8,25, 0,9,146,\n    83,7,59, 0,8,121, 0,8,57, 0,9,210,\n    81,7,17, 0,8,105, 0,8,41, 0,9,178,\n    0,8,9, 0,8,137, 0,8,73, 0,9,242,\n    80,7,4, 0,8,85, 0,8,21, 80,8,258,\n    83,7,43, 0,8,117, 0,8,53, 0,9,202,\n    81,7,13, 0,8,101, 0,8,37, 0,9,170,\n    0,8,5, 0,8,133, 0,8,69, 0,9,234,\n    80,7,8, 0,8,93, 0,8,29, 0,9,154,\n    84,7,83, 0,8,125, 0,8,61, 0,9,218,\n    82,7,23, 0,8,109, 0,8,45, 0,9,186,\n    0,8,13, 0,8,141, 0,8,77, 0,9,250,\n    80,7,3, 0,8,83, 0,8,19, 85,8,195,\n    83,7,35, 0,8,115, 0,8,51, 0,9,198,\n    81,7,11, 0,8,99, 0,8,35, 0,9,166,\n    0,8,3, 0,8,131, 0,8,67, 0,9,230,\n    80,7,7, 0,8,91, 0,8,27, 0,9,150,\n    84,7,67, 0,8,123, 0,8,59, 0,9,214,\n    82,7,19, 0,8,107, 0,8,43, 0,9,182,\n    0,8,11, 0,8,139, 0,8,75, 0,9,246,\n    80,7,5, 0,8,87, 0,8,23, 192,8,0,\n    83,7,51, 0,8,119, 0,8,55, 0,9,206,\n    81,7,15, 0,8,103, 0,8,39, 0,9,174,\n    0,8,7, 0,8,135, 0,8,71, 0,9,238,\n    80,7,9, 0,8,95, 0,8,31, 0,9,158,\n    84,7,99, 0,8,127, 0,8,63, 0,9,222,\n    82,7,27, 0,8,111, 0,8,47, 0,9,190,\n    0,8,15, 0,8,143, 0,8,79, 0,9,254,\n    96,7,256, 0,8,80, 0,8,16, 84,8,115,\n    82,7,31, 0,8,112, 0,8,48, 0,9,193,\n\n    80,7,10, 0,8,96, 0,8,32, 0,9,161,\n    0,8,0, 0,8,128, 0,8,64, 0,9,225,\n    80,7,6, 0,8,88, 0,8,24, 0,9,145,\n    83,7,59, 0,8,120, 0,8,56, 0,9,209,\n    81,7,17, 0,8,104, 0,8,40, 0,9,177,\n    0,8,8, 0,8,136, 0,8,72, 0,9,241,\n    80,7,4, 0,8,84, 0,8,20, 85,8,227,\n    83,7,43, 0,8,116, 0,8,52, 0,9,201,\n    81,7,13, 0,8,100, 0,8,36, 0,9,169,\n    0,8,4, 0,8,132, 0,8,68, 0,9,233,\n    80,7,8, 0,8,92, 0,8,28, 0,9,153,\n    84,7,83, 0,8,124, 0,8,60, 0,9,217,\n    82,7,23, 0,8,108, 0,8,44, 0,9,185,\n    0,8,12, 0,8,140, 0,8,76, 0,9,249,\n    80,7,3, 0,8,82, 0,8,18, 85,8,163,\n    83,7,35, 0,8,114, 0,8,50, 0,9,197,\n    81,7,11, 0,8,98, 0,8,34, 0,9,165,\n    0,8,2, 0,8,130, 0,8,66, 0,9,229,\n    80,7,7, 0,8,90, 0,8,26, 0,9,149,\n    84,7,67, 0,8,122, 0,8,58, 0,9,213,\n    82,7,19, 0,8,106, 0,8,42, 0,9,181,\n    0,8,10, 0,8,138, 0,8,74, 0,9,245,\n    80,7,5, 0,8,86, 0,8,22, 192,8,0,\n    83,7,51, 0,8,118, 0,8,54, 0,9,205,\n    81,7,15, 0,8,102, 0,8,38, 0,9,173,\n    0,8,6, 0,8,134, 0,8,70, 0,9,237,\n    80,7,9, 0,8,94, 0,8,30, 0,9,157,\n    84,7,99, 0,8,126, 0,8,62, 0,9,221,\n    82,7,27, 0,8,110, 0,8,46, 0,9,189,\n    0,8,14, 0,8,142, 0,8,78, 0,9,253,\n    96,7,256, 0,8,81, 0,8,17, 85,8,131,\n    82,7,31, 0,8,113, 0,8,49, 0,9,195,\n    80,7,10, 0,8,97, 0,8,33, 0,9,163,\n    0,8,1, 0,8,129, 0,8,65, 0,9,227,\n    80,7,6, 0,8,89, 0,8,25, 0,9,147,\n    83,7,59, 0,8,121, 0,8,57, 0,9,211,\n    81,7,17, 0,8,105, 0,8,41, 0,9,179,\n    0,8,9, 0,8,137, 0,8,73, 0,9,243,\n    80,7,4, 0,8,85, 0,8,21, 80,8,258,\n    83,7,43, 0,8,117, 0,8,53, 0,9,203,\n    81,7,13, 0,8,101, 0,8,37, 0,9,171,\n    0,8,5, 0,8,133, 0,8,69, 0,9,235,\n    80,7,8, 0,8,93, 0,8,29, 0,9,155,\n    84,7,83, 0,8,125, 0,8,61, 0,9,219,\n    82,7,23, 0,8,109, 0,8,45, 0,9,187,\n    0,8,13, 0,8,141, 0,8,77, 0,9,251,\n    80,7,3, 0,8,83, 0,8,19, 85,8,195,\n    83,7,35, 0,8,115, 0,8,51, 0,9,199,\n    81,7,11, 0,8,99, 0,8,35, 0,9,167,\n    0,8,3, 0,8,131, 0,8,67, 0,9,231,\n    80,7,7, 0,8,91, 0,8,27, 0,9,151,\n    84,7,67, 0,8,123, 0,8,59, 0,9,215,\n    82,7,19, 0,8,107, 0,8,43, 0,9,183,\n    0,8,11, 0,8,139, 0,8,75, 0,9,247,\n    80,7,5, 0,8,87, 0,8,23, 192,8,0,\n    83,7,51, 0,8,119, 0,8,55, 0,9,207,\n    81,7,15, 0,8,103, 0,8,39, 0,9,175,\n    0,8,7, 0,8,135, 0,8,71, 0,9,239,\n    80,7,9, 0,8,95, 0,8,31, 0,9,159,\n    84,7,99, 0,8,127, 0,8,63, 0,9,223,\n    82,7,27, 0,8,111, 0,8,47, 0,9,191,\n    0,8,15, 0,8,143, 0,8,79, 0,9,255\n];\nvar fixed_td = [\n    80,5,1, 87,5,257, 83,5,17, 91,5,4097,\n    81,5,5, 89,5,1025, 85,5,65, 93,5,16385,\n    80,5,3, 88,5,513, 84,5,33, 92,5,8193,\n    82,5,9, 90,5,2049, 86,5,129, 192,5,24577,\n    80,5,2, 87,5,385, 83,5,25, 91,5,6145,\n    81,5,7, 89,5,1537, 85,5,97, 93,5,24577,\n    80,5,4, 88,5,769, 84,5,49, 92,5,12289,\n    82,5,13, 90,5,3073, 86,5,193, 192,5,24577\n];\n\n  // Tables for deflate from PKZIP's appnote.txt.\n  var cplens = [ // Copy lengths for literal codes 257..285\n        3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,\n        35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0\n  ];\n\n  // see note #13 above about 258\n  var cplext = [ // Extra bits for literal codes 257..285\n        0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2,\n        3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 112, 112  // 112==invalid\n  ];\n\n var cpdist = [ // Copy offsets for distance codes 0..29\n        1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,\n        257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,\n        8193, 12289, 16385, 24577\n  ];\n\n  var cpdext = [ // Extra bits for distance codes\n        0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6,\n        7, 7, 8, 8, 9, 9, 10, 10, 11, 11,\n        12, 12, 13, 13];\n\n//\n// ZStream.java\n//\n\nfunction ZStream() {\n}\n\n\nZStream.prototype.inflateInit = function(w, nowrap) {\n    if (!w) {\n\tw = DEF_WBITS;\n    }\n    if (nowrap) {\n\tnowrap = false;\n    }\n    this.istate = new Inflate();\n    return this.istate.inflateInit(this, nowrap?-w:w);\n}\n\nZStream.prototype.inflate = function(f) {\n    if(this.istate==null) return Z_STREAM_ERROR;\n    return this.istate.inflate(this, f);\n}\n\nZStream.prototype.inflateEnd = function(){\n    if(this.istate==null) return Z_STREAM_ERROR;\n    var ret=istate.inflateEnd(this);\n    this.istate = null;\n    return ret;\n}\nZStream.prototype.inflateSync = function(){\n    // if(istate == null) return Z_STREAM_ERROR;\n    return istate.inflateSync(this);\n}\nZStream.prototype.inflateSetDictionary = function(dictionary, dictLength){\n    // if(istate == null) return Z_STREAM_ERROR;\n    return istate.inflateSetDictionary(this, dictionary, dictLength);\n}\n\n/*\n\n  public int deflateInit(int level){\n    return deflateInit(level, MAX_WBITS);\n  }\n  public int deflateInit(int level, boolean nowrap){\n    return deflateInit(level, MAX_WBITS, nowrap);\n  }\n  public int deflateInit(int level, int bits){\n    return deflateInit(level, bits, false);\n  }\n  public int deflateInit(int level, int bits, boolean nowrap){\n    dstate=new Deflate();\n    return dstate.deflateInit(this, level, nowrap?-bits:bits);\n  }\n  public int deflate(int flush){\n    if(dstate==null){\n      return Z_STREAM_ERROR;\n    }\n    return dstate.deflate(this, flush);\n  }\n  public int deflateEnd(){\n    if(dstate==null) return Z_STREAM_ERROR;\n    int ret=dstate.deflateEnd();\n    dstate=null;\n    return ret;\n  }\n  public int deflateParams(int level, int strategy){\n    if(dstate==null) return Z_STREAM_ERROR;\n    return dstate.deflateParams(this, level, strategy);\n  }\n  public int deflateSetDictionary (byte[] dictionary, int dictLength){\n    if(dstate == null)\n      return Z_STREAM_ERROR;\n    return dstate.deflateSetDictionary(this, dictionary, dictLength);\n  }\n\n*/\n\n/*\n  // Flush as much pending output as possible. All deflate() output goes\n  // through this function so some applications may wish to modify it\n  // to avoid allocating a large strm->next_out buffer and copying into it.\n  // (See also read_buf()).\n  void flush_pending(){\n    int len=dstate.pending;\n\n    if(len>avail_out) len=avail_out;\n    if(len==0) return;\n\n    if(dstate.pending_buf.length<=dstate.pending_out ||\n       next_out.length<=next_out_index ||\n       dstate.pending_buf.length<(dstate.pending_out+len) ||\n       next_out.length<(next_out_index+len)){\n      System.out.println(dstate.pending_buf.length+\", \"+dstate.pending_out+\n\t\t\t \", \"+next_out.length+\", \"+next_out_index+\", \"+len);\n      System.out.println(\"avail_out=\"+avail_out);\n    }\n\n    System.arraycopy(dstate.pending_buf, dstate.pending_out,\n\t\t     next_out, next_out_index, len);\n\n    next_out_index+=len;\n    dstate.pending_out+=len;\n    total_out+=len;\n    avail_out-=len;\n    dstate.pending-=len;\n    if(dstate.pending==0){\n      dstate.pending_out=0;\n    }\n  }\n\n  // Read a new buffer from the current input stream, update the adler32\n  // and total number of bytes read.  All deflate() input goes through\n  // this function so some applications may wish to modify it to avoid\n  // allocating a large strm->next_in buffer and copying from it.\n  // (See also flush_pending()).\n  int read_buf(byte[] buf, int start, int size) {\n    int len=avail_in;\n\n    if(len>size) len=size;\n    if(len==0) return 0;\n\n    avail_in-=len;\n\n    if(dstate.noheader==0) {\n      adler=_adler.adler32(adler, next_in, next_in_index, len);\n    }\n    System.arraycopy(next_in, next_in_index, buf, start, len);\n    next_in_index  += len;\n    total_in += len;\n    return len;\n  }\n\n  public void free(){\n    next_in=null;\n    next_out=null;\n    msg=null;\n    _adler=null;\n  }\n}\n*/\n\n\n//\n// Inflate.java\n//\n\nfunction Inflate() {\n    this.was = [0];\n}\n\nInflate.prototype.inflateReset = function(z) {\n    if(z == null || z.istate == null) return Z_STREAM_ERROR;\n    \n    z.total_in = z.total_out = 0;\n    z.msg = null;\n    z.istate.mode = z.istate.nowrap!=0 ? BLOCKS : METHOD;\n    z.istate.blocks.reset(z, null);\n    return Z_OK;\n}\n\nInflate.prototype.inflateEnd = function(z){\n    if(this.blocks != null)\n      this.blocks.free(z);\n    this.blocks=null;\n    return Z_OK;\n}\n\nInflate.prototype.inflateInit = function(z, w){\n    z.msg = null;\n    this.blocks = null;\n\n    // handle undocumented nowrap option (no zlib header or check)\n    nowrap = 0;\n    if(w < 0){\n      w = - w;\n      nowrap = 1;\n    }\n\n    // set window size\n    if(w<8 ||w>15){\n      this.inflateEnd(z);\n      return Z_STREAM_ERROR;\n    }\n    this.wbits=w;\n\n    z.istate.blocks=new InfBlocks(z, \n\t\t\t\t  z.istate.nowrap!=0 ? null : this,\n\t\t\t\t  1<<w);\n\n    // reset state\n    this.inflateReset(z);\n    return Z_OK;\n  }\n\nInflate.prototype.inflate = function(z, f){\n    var r, b;\n\n    if(z == null || z.istate == null || z.next_in == null)\n      return Z_STREAM_ERROR;\n    f = f == Z_FINISH ? Z_BUF_ERROR : Z_OK;\n    r = Z_BUF_ERROR;\n    while (true){\n      switch (z.istate.mode){\n      case METHOD:\n\n        if(z.avail_in==0)return r;r=f;\n\n        z.avail_in--; z.total_in++;\n        if(((z.istate.method = z.next_in[z.next_in_index++])&0xf)!=Z_DEFLATED){\n          z.istate.mode = BAD;\n          z.msg=\"unknown compression method\";\n          z.istate.marker = 5;       // can't try inflateSync\n          break;\n        }\n        if((z.istate.method>>4)+8>z.istate.wbits){\n          z.istate.mode = BAD;\n          z.msg=\"invalid window size\";\n          z.istate.marker = 5;       // can't try inflateSync\n          break;\n        }\n        z.istate.mode=FLAG;\n      case FLAG:\n\n        if(z.avail_in==0)return r;r=f;\n\n        z.avail_in--; z.total_in++;\n        b = (z.next_in[z.next_in_index++])&0xff;\n\n        if((((z.istate.method << 8)+b) % 31)!=0){\n          z.istate.mode = BAD;\n          z.msg = \"incorrect header check\";\n          z.istate.marker = 5;       // can't try inflateSync\n          break;\n        }\n\n        if((b&PRESET_DICT)==0){\n          z.istate.mode = BLOCKS;\n          break;\n        }\n        z.istate.mode = DICT4;\n      case DICT4:\n\n        if(z.avail_in==0)return r;r=f;\n\n        z.avail_in--; z.total_in++;\n        z.istate.need=((z.next_in[z.next_in_index++]&0xff)<<24)&0xff000000;\n        z.istate.mode=DICT3;\n      case DICT3:\n\n        if(z.avail_in==0)return r;r=f;\n\n        z.avail_in--; z.total_in++;\n        z.istate.need+=((z.next_in[z.next_in_index++]&0xff)<<16)&0xff0000;\n        z.istate.mode=DICT2;\n      case DICT2:\n\n        if(z.avail_in==0)return r;r=f;\n\n        z.avail_in--; z.total_in++;\n        z.istate.need+=((z.next_in[z.next_in_index++]&0xff)<<8)&0xff00;\n        z.istate.mode=DICT1;\n      case DICT1:\n\n        if(z.avail_in==0)return r;r=f;\n\n        z.avail_in--; z.total_in++;\n        z.istate.need += (z.next_in[z.next_in_index++]&0xff);\n        z.adler = z.istate.need;\n        z.istate.mode = DICT0;\n        return Z_NEED_DICT;\n      case DICT0:\n        z.istate.mode = BAD;\n        z.msg = \"need dictionary\";\n        z.istate.marker = 0;       // can try inflateSync\n        return Z_STREAM_ERROR;\n      case BLOCKS:\n\n        r = z.istate.blocks.proc(z, r);\n        if(r == Z_DATA_ERROR){\n          z.istate.mode = BAD;\n          z.istate.marker = 0;     // can try inflateSync\n          break;\n        }\n        if(r == Z_OK){\n          r = f;\n        }\n        if(r != Z_STREAM_END){\n          return r;\n        }\n        r = f;\n        z.istate.blocks.reset(z, z.istate.was);\n        if(z.istate.nowrap!=0){\n          z.istate.mode=DONE;\n          break;\n        }\n        z.istate.mode=CHECK4;\n      case CHECK4:\n\n        if(z.avail_in==0)return r;r=f;\n\n        z.avail_in--; z.total_in++;\n        z.istate.need=((z.next_in[z.next_in_index++]&0xff)<<24)&0xff000000;\n        z.istate.mode=CHECK3;\n      case CHECK3:\n\n        if(z.avail_in==0)return r;r=f;\n\n        z.avail_in--; z.total_in++;\n        z.istate.need+=((z.next_in[z.next_in_index++]&0xff)<<16)&0xff0000;\n        z.istate.mode = CHECK2;\n      case CHECK2:\n\n        if(z.avail_in==0)return r;r=f;\n\n        z.avail_in--; z.total_in++;\n        z.istate.need+=((z.next_in[z.next_in_index++]&0xff)<<8)&0xff00;\n        z.istate.mode = CHECK1;\n      case CHECK1:\n\n        if(z.avail_in==0)return r;r=f;\n\n        z.avail_in--; z.total_in++;\n        z.istate.need+=(z.next_in[z.next_in_index++]&0xff);\n\n        if(((z.istate.was[0])) != ((z.istate.need))){\n          z.istate.mode = BAD;\n          z.msg = \"incorrect data check\";\n          z.istate.marker = 5;       // can't try inflateSync\n          break;\n        }\n\n        z.istate.mode = DONE;\n      case DONE:\n        return Z_STREAM_END;\n      case BAD:\n        return Z_DATA_ERROR;\n      default:\n        return Z_STREAM_ERROR;\n      }\n    }\n  }\n\n\nInflate.prototype.inflateSetDictionary = function(z,  dictionary, dictLength) {\n    var index=0;\n    var length = dictLength;\n    if(z==null || z.istate == null|| z.istate.mode != DICT0)\n      return Z_STREAM_ERROR;\n\n    if(z._adler.adler32(1, dictionary, 0, dictLength)!=z.adler){\n      return Z_DATA_ERROR;\n    }\n\n    z.adler = z._adler.adler32(0, null, 0, 0);\n\n    if(length >= (1<<z.istate.wbits)){\n      length = (1<<z.istate.wbits)-1;\n      index=dictLength - length;\n    }\n    z.istate.blocks.set_dictionary(dictionary, index, length);\n    z.istate.mode = BLOCKS;\n    return Z_OK;\n  }\n\n//  static private byte[] mark = {(byte)0, (byte)0, (byte)0xff, (byte)0xff};\nvar mark = [0, 0, 255, 255]\n\nInflate.prototype.inflateSync = function(z){\n    var n;       // number of bytes to look at\n    var p;       // pointer to bytes\n    var m;       // number of marker bytes found in a row\n    var r, w;   // temporaries to save total_in and total_out\n\n    // set up\n    if(z == null || z.istate == null)\n      return Z_STREAM_ERROR;\n    if(z.istate.mode != BAD){\n      z.istate.mode = BAD;\n      z.istate.marker = 0;\n    }\n    if((n=z.avail_in)==0)\n      return Z_BUF_ERROR;\n    p=z.next_in_index;\n    m=z.istate.marker;\n\n    // search\n    while (n!=0 && m < 4){\n      if(z.next_in[p] == mark[m]){\n        m++;\n      }\n      else if(z.next_in[p]!=0){\n        m = 0;\n      }\n      else{\n        m = 4 - m;\n      }\n      p++; n--;\n    }\n\n    // restore\n    z.total_in += p-z.next_in_index;\n    z.next_in_index = p;\n    z.avail_in = n;\n    z.istate.marker = m;\n\n    // return no joy or set up to restart on a new block\n    if(m != 4){\n      return Z_DATA_ERROR;\n    }\n    r=z.total_in;  w=z.total_out;\n    this.inflateReset(z);\n    z.total_in=r;  z.total_out = w;\n    z.istate.mode = BLOCKS;\n    return Z_OK;\n}\n\n  // Returns true if inflate is currently at the end of a block generated\n  // by Z_SYNC_FLUSH or Z_FULL_FLUSH. This function is used by one PPP\n  // implementation to provide an additional safety check. PPP uses Z_SYNC_FLUSH\n  // but removes the length bytes of the resulting empty stored block. When\n  // decompressing, PPP checks that at the end of input packet, inflate is\n  // waiting for these length bytes.\nInflate.prototype.inflateSyncPoint = function(z){\n    if(z == null || z.istate == null || z.istate.blocks == null)\n      return Z_STREAM_ERROR;\n    return z.istate.blocks.sync_point();\n}\n\n\n//\n// InfBlocks.java\n//\n\nvar INFBLOCKS_BORDER = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];\n\nfunction InfBlocks(z, checkfn, w) {\n    this.hufts=new Int32Array(MANY*3);\n    this.window=new Uint8Array(w);\n    this.end=w;\n    this.checkfn = checkfn;\n    this.mode = IB_TYPE;\n    this.reset(z, null);\n\n    this.left = 0;            // if STORED, bytes left to copy \n\n    this.table = 0;           // table lengths (14 bits) \n    this.index = 0;           // index into blens (or border) \n    this.blens = null;         // bit lengths of codes \n    this.bb=new Int32Array(1); // bit length tree depth \n    this.tb=new Int32Array(1); // bit length decoding tree \n\n    this.codes = new InfCodes();\n\n    this.last = 0;            // true if this block is the last block \n\n  // mode independent information \n    this.bitk = 0;            // bits in bit buffer \n    this.bitb = 0;            // bit buffer \n    this.read = 0;            // window read pointer \n    this.write = 0;           // window write pointer \n    this.check = 0;          // check on output \n\n    this.inftree=new InfTree();\n}\n\n\n\n\nInfBlocks.prototype.reset = function(z, c){\n    if(c) c[0]=this.check;\n    if(this.mode==IB_CODES){\n      this.codes.free(z);\n    }\n    this.mode=IB_TYPE;\n    this.bitk=0;\n    this.bitb=0;\n    this.read=this.write=0;\n\n    if(this.checkfn)\n      z.adler=this.check=z._adler.adler32(0, null, 0, 0);\n  }\n\n InfBlocks.prototype.proc = function(z, r){\n    var t;              // temporary storage\n    var b;              // bit buffer\n    var k;              // bits in bit buffer\n    var p;              // input data pointer\n    var n;              // bytes available there\n    var q;              // output window write pointer\n    var m;              // bytes to end of window or read pointer\n\n    // copy input/output information to locals (UPDATE macro restores)\n    {p=z.next_in_index;n=z.avail_in;b=this.bitb;k=this.bitk;}\n    {q=this.write;m=(q<this.read ? this.read-q-1 : this.end-q);}\n\n    // process input based on current state\n    while(true){\n      switch (this.mode){\n      case IB_TYPE:\n\n\twhile(k<(3)){\n\t  if(n!=0){\n\t    r=Z_OK;\n\t  }\n\t  else{\n\t    this.bitb=b; this.bitk=k; \n\t    z.avail_in=n;\n\t    z.total_in+=p-z.next_in_index;z.next_in_index=p;\n\t    this.write=q;\n\t    return this.inflate_flush(z,r);\n\t  };\n\t  n--;\n\t  b|=(z.next_in[p++]&0xff)<<k;\n\t  k+=8;\n\t}\n\tt = (b & 7);\n\tthis.last = t & 1;\n\n\tswitch (t >>> 1){\n        case 0:                         // stored \n          {b>>>=(3);k-=(3);}\n          t = k & 7;                    // go to byte boundary\n\n          {b>>>=(t);k-=(t);}\n          this.mode = IB_LENS;                  // get length of stored block\n          break;\n        case 1:                         // fixed\n          {\n              var bl=new Int32Array(1);\n\t      var bd=new Int32Array(1);\n              var tl=[];\n\t      var td=[];\n\n\t      inflate_trees_fixed(bl, bd, tl, td, z);\n              this.codes.init(bl[0], bd[0], tl[0], 0, td[0], 0, z);\n          }\n\n          {b>>>=(3);k-=(3);}\n\n          this.mode = IB_CODES;\n          break;\n        case 2:                         // dynamic\n\n          {b>>>=(3);k-=(3);}\n\n          this.mode = IB_TABLE;\n          break;\n        case 3:                         // illegal\n\n          {b>>>=(3);k-=(3);}\n          this.mode = BAD;\n          z.msg = \"invalid block type\";\n          r = Z_DATA_ERROR;\n\n\t  this.bitb=b; this.bitk=k; \n\t  z.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;\n\t  this.write=q;\n\t  return this.inflate_flush(z,r);\n\t}\n\tbreak;\n      case IB_LENS:\n\twhile(k<(32)){\n\t  if(n!=0){\n\t    r=Z_OK;\n\t  }\n\t  else{\n\t    this.bitb=b; this.bitk=k; \n\t    z.avail_in=n;\n\t    z.total_in+=p-z.next_in_index;z.next_in_index=p;\n\t    this.write=q;\n\t    return this.inflate_flush(z,r);\n\t  };\n\t  n--;\n\t  b|=(z.next_in[p++]&0xff)<<k;\n\t  k+=8;\n\t}\n\n\tif ((((~b) >>> 16) & 0xffff) != (b & 0xffff)){\n\t  this.mode = BAD;\n\t  z.msg = \"invalid stored block lengths\";\n\t  r = Z_DATA_ERROR;\n\n\t  this.bitb=b; this.bitk=k; \n\t  z.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;\n\t  this.write=q;\n\t  return this.inflate_flush(z,r);\n\t}\n\tthis.left = (b & 0xffff);\n\tb = k = 0;                       // dump bits\n\tthis.mode = this.left!=0 ? IB_STORED : (this.last!=0 ? IB_DRY : IB_TYPE);\n\tbreak;\n      case IB_STORED:\n\tif (n == 0){\n\t  this.bitb=b; this.bitk=k; \n\t  z.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;\n\t  write=q;\n\t  return this.inflate_flush(z,r);\n\t}\n\n\tif(m==0){\n\t  if(q==end&&read!=0){\n\t    q=0; m=(q<this.read ? this.read-q-1 : this.end-q);\n\t  }\n\t  if(m==0){\n\t    this.write=q; \n\t    r=this.inflate_flush(z,r);\n\t    q=this.write; m = (q < this.read ? this.read-q-1 : this.end-q);\n\t    if(q==this.end && this.read != 0){\n\t      q=0; m = (q < this.read ? this.read-q-1 : this.end-q);\n\t    }\n\t    if(m==0){\n\t      this.bitb=b; this.bitk=k; \n\t      z.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;\n\t      this.write=q;\n\t      return this.inflate_flush(z,r);\n\t    }\n\t  }\n\t}\n\tr=Z_OK;\n\n\tt = this.left;\n\tif(t>n) t = n;\n\tif(t>m) t = m;\n\tarrayCopy(z.next_in, p, this.window, q, t);\n\tp += t;  n -= t;\n\tq += t;  m -= t;\n\tif ((this.left -= t) != 0)\n\t  break;\n\tthis.mode = (this.last != 0 ? IB_DRY : IB_TYPE);\n\tbreak;\n      case IB_TABLE:\n\n\twhile(k<(14)){\n\t  if(n!=0){\n\t    r=Z_OK;\n\t  }\n\t  else{\n\t    this.bitb=b; this.bitk=k; \n\t    z.avail_in=n;\n\t    z.total_in+=p-z.next_in_index;z.next_in_index=p;\n\t    this.write=q;\n\t    return this.inflate_flush(z,r);\n\t  };\n\t  n--;\n\t  b|=(z.next_in[p++]&0xff)<<k;\n\t  k+=8;\n\t}\n\n\tthis.table = t = (b & 0x3fff);\n\tif ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)\n\t  {\n\t    this.mode = IB_BAD;\n\t    z.msg = \"too many length or distance symbols\";\n\t    r = Z_DATA_ERROR;\n\n\t    this.bitb=b; this.bitk=k; \n\t    z.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;\n\t    this.write=q;\n\t    return this.inflate_flush(z,r);\n\t  }\n\tt = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);\n\tif(this.blens==null || this.blens.length<t){\n\t    this.blens=new Int32Array(t);\n\t}\n\telse{\n\t  for(var i=0; i<t; i++){\n              this.blens[i]=0;\n          }\n\t}\n\n\t{b>>>=(14);k-=(14);}\n\n\tthis.index = 0;\n\tmode = IB_BTREE;\n      case IB_BTREE:\n\twhile (this.index < 4 + (this.table >>> 10)){\n\t  while(k<(3)){\n\t    if(n!=0){\n\t      r=Z_OK;\n\t    }\n\t    else{\n\t      this.bitb=b; this.bitk=k; \n\t      z.avail_in=n;\n\t      z.total_in+=p-z.next_in_index;z.next_in_index=p;\n\t      this.write=q;\n\t      return this.inflate_flush(z,r);\n\t    };\n\t    n--;\n\t    b|=(z.next_in[p++]&0xff)<<k;\n\t    k+=8;\n\t  }\n\n\t  this.blens[INFBLOCKS_BORDER[this.index++]] = b&7;\n\n\t  {b>>>=(3);k-=(3);}\n\t}\n\n\twhile(this.index < 19){\n\t  this.blens[INFBLOCKS_BORDER[this.index++]] = 0;\n\t}\n\n\tthis.bb[0] = 7;\n\tt = this.inftree.inflate_trees_bits(this.blens, this.bb, this.tb, this.hufts, z);\n\tif (t != Z_OK){\n\t  r = t;\n\t  if (r == Z_DATA_ERROR){\n\t    this.blens=null;\n\t    this.mode = IB_BAD;\n\t  }\n\n\t  this.bitb=b; this.bitk=k; \n\t  z.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;\n\t  write=q;\n\t  return this.inflate_flush(z,r);\n\t}\n\n\tthis.index = 0;\n\tthis.mode = IB_DTREE;\n      case IB_DTREE:\n\twhile (true){\n\t  t = this.table;\n\t  if(!(this.index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))){\n\t    break;\n\t  }\n\n\t  var h; //int[]\n\t  var i, j, c;\n\n\t  t = this.bb[0];\n\n\t  while(k<(t)){\n\t    if(n!=0){\n\t      r=Z_OK;\n\t    }\n\t    else{\n\t      this.bitb=b; this.bitk=k; \n\t      z.avail_in=n;\n\t      z.total_in+=p-z.next_in_index;z.next_in_index=p;\n\t      this.write=q;\n\t      return this.inflate_flush(z,r);\n\t    };\n\t    n--;\n\t    b|=(z.next_in[p++]&0xff)<<k;\n\t    k+=8;\n\t  }\n\n//\t  if (this.tb[0]==-1){\n//            dlog(\"null...\");\n//\t  }\n\n\t  t=this.hufts[(this.tb[0]+(b & inflate_mask[t]))*3+1];\n\t  c=this.hufts[(this.tb[0]+(b & inflate_mask[t]))*3+2];\n\n\t  if (c < 16){\n\t    b>>>=(t);k-=(t);\n\t    this.blens[this.index++] = c;\n\t  }\n\t  else { // c == 16..18\n\t    i = c == 18 ? 7 : c - 14;\n\t    j = c == 18 ? 11 : 3;\n\n\t    while(k<(t+i)){\n\t      if(n!=0){\n\t\tr=Z_OK;\n\t      }\n\t      else{\n\t\tthis.bitb=b; this.bitk=k; \n\t\tz.avail_in=n;\n\t\tz.total_in+=p-z.next_in_index;z.next_in_index=p;\n\t\tthis.write=q;\n\t\treturn this.inflate_flush(z,r);\n\t      };\n\t      n--;\n\t      b|=(z.next_in[p++]&0xff)<<k;\n\t      k+=8;\n\t    }\n\n\t    b>>>=(t);k-=(t);\n\n\t    j += (b & inflate_mask[i]);\n\n\t    b>>>=(i);k-=(i);\n\n\t    i = this.index;\n\t    t = this.table;\n\t    if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) ||\n\t\t(c == 16 && i < 1)){\n\t      this.blens=null;\n\t      this.mode = IB_BAD;\n\t      z.msg = \"invalid bit length repeat\";\n\t      r = Z_DATA_ERROR;\n\n\t      this.bitb=b; this.bitk=k; \n\t      z.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;\n\t      this.write=q;\n\t      return this.inflate_flush(z,r);\n\t    }\n\n\t    c = c == 16 ? this.blens[i-1] : 0;\n\t    do{\n\t      this.blens[i++] = c;\n\t    }\n\t    while (--j!=0);\n\t    this.index = i;\n\t  }\n\t}\n\n\tthis.tb[0]=-1;\n\t{\n\t    var bl=new Int32Array(1);\n\t    var bd=new Int32Array(1);\n\t    var tl=new Int32Array(1);\n\t    var td=new Int32Array(1);\n\t    bl[0] = 9;         // must be <= 9 for lookahead assumptions\n\t    bd[0] = 6;         // must be <= 9 for lookahead assumptions\n\n\t    t = this.table;\n\t    t = this.inftree.inflate_trees_dynamic(257 + (t & 0x1f), \n\t\t\t\t\t      1 + ((t >> 5) & 0x1f),\n\t\t\t\t\t      this.blens, bl, bd, tl, td, this.hufts, z);\n\n\t    if (t != Z_OK){\n\t        if (t == Z_DATA_ERROR){\n\t            this.blens=null;\n\t            this.mode = BAD;\n\t        }\n\t        r = t;\n\n\t        this.bitb=b; this.bitk=k; \n\t        z.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;\n\t        this.write=q;\n\t        return this.inflate_flush(z,r);\n\t    }\n\t    this.codes.init(bl[0], bd[0], this.hufts, tl[0], this.hufts, td[0], z);\n\t}\n\tthis.mode = IB_CODES;\n      case IB_CODES:\n\tthis.bitb=b; this.bitk=k;\n\tz.avail_in=n; z.total_in+=p-z.next_in_index;z.next_in_index=p;\n\tthis.write=q;\n\n\tif ((r = this.codes.proc(this, z, r)) != Z_STREAM_END){\n\t  return this.inflate_flush(z, r);\n\t}\n\tr = Z_OK;\n\tthis.codes.free(z);\n\n\tp=z.next_in_index; n=z.avail_in;b=this.bitb;k=this.bitk;\n\tq=this.write;m = (q < this.read ? this.read-q-1 : this.end-q);\n\n\tif (this.last==0){\n\t  this.mode = IB_TYPE;\n\t  break;\n\t}\n\tthis.mode = IB_DRY;\n      case IB_DRY:\n\tthis.write=q; \n\tr = this.inflate_flush(z, r); \n\tq=this.write; m = (q < this.read ? this.read-q-1 : this.end-q);\n\tif (this.read != this.write){\n\t  this.bitb=b; this.bitk=k; \n\t  z.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;\n\t  this.write=q;\n\t  return this.inflate_flush(z, r);\n\t}\n\tmode = DONE;\n      case IB_DONE:\n\tr = Z_STREAM_END;\n\n\tthis.bitb=b; this.bitk=k; \n\tz.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;\n\tthis.write=q;\n\treturn this.inflate_flush(z, r);\n      case IB_BAD:\n\tr = Z_DATA_ERROR;\n\n\tthis.bitb=b; this.bitk=k; \n\tz.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;\n\tthis.write=q;\n\treturn this.inflate_flush(z, r);\n\n      default:\n\tr = Z_STREAM_ERROR;\n\n\tthis.bitb=b; this.bitk=k; \n\tz.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;\n\tthis.write=q;\n\treturn this.inflate_flush(z, r);\n      }\n    }\n  }\n\nInfBlocks.prototype.free = function(z){\n    this.reset(z, null);\n    this.window=null;\n    this.hufts=null;\n}\n\nInfBlocks.prototype.set_dictionary = function(d, start, n){\n    arrayCopy(d, start, window, 0, n);\n    this.read = this.write = n;\n}\n\n  // Returns true if inflate is currently at the end of a block generated\n  // by Z_SYNC_FLUSH or Z_FULL_FLUSH. \nInfBlocks.prototype.sync_point = function(){\n    return this.mode == IB_LENS;\n}\n\n  // copy as much as possible from the sliding window to the output area\nInfBlocks.prototype.inflate_flush = function(z, r){\n    var n;\n    var p;\n    var q;\n\n    // local copies of source and destination pointers\n    p = z.next_out_index;\n    q = this.read;\n\n    // compute number of bytes to copy as far as end of window\n    n = ((q <= this.write ? this.write : this.end) - q);\n    if (n > z.avail_out) n = z.avail_out;\n    if (n!=0 && r == Z_BUF_ERROR) r = Z_OK;\n\n    // update counters\n    z.avail_out -= n;\n    z.total_out += n;\n\n    // update check information\n    if(this.checkfn != null)\n      z.adler=this.check=z._adler.adler32(this.check, this.window, q, n);\n\n    // copy as far as end of window\n    arrayCopy(this.window, q, z.next_out, p, n);\n    p += n;\n    q += n;\n\n    // see if more to copy at beginning of window\n    if (q == this.end){\n      // wrap pointers\n      q = 0;\n      if (this.write == this.end)\n        this.write = 0;\n\n      // compute bytes to copy\n      n = this.write - q;\n      if (n > z.avail_out) n = z.avail_out;\n      if (n!=0 && r == Z_BUF_ERROR) r = Z_OK;\n\n      // update counters\n      z.avail_out -= n;\n      z.total_out += n;\n\n      // update check information\n      if(this.checkfn != null)\n\tz.adler=this.check=z._adler.adler32(this.check, this.window, q, n);\n\n      // copy\n      arrayCopy(this.window, q, z.next_out, p, n);\n      p += n;\n      q += n;\n    }\n\n    // update pointers\n    z.next_out_index = p;\n    this.read = q;\n\n    // done\n    return r;\n  }\n\n//\n// InfCodes.java\n//\n\nvar IC_START=0;  // x: set up for LEN\nvar IC_LEN=1;    // i: get length/literal/eob next\nvar IC_LENEXT=2; // i: getting length extra (have base)\nvar IC_DIST=3;   // i: get distance next\nvar IC_DISTEXT=4;// i: getting distance extra\nvar IC_COPY=5;   // o: copying bytes in window, waiting for space\nvar IC_LIT=6;    // o: got literal, waiting for output space\nvar IC_WASH=7;   // o: got eob, possibly still output waiting\nvar IC_END=8;    // x: got eob and all data flushed\nvar IC_BADCODE=9;// x: got error\n\nfunction InfCodes() {\n}\n\nInfCodes.prototype.init = function(bl, bd, tl, tl_index, td, td_index, z) {\n    this.mode=IC_START;\n    this.lbits=bl;\n    this.dbits=bd;\n    this.ltree=tl;\n    this.ltree_index=tl_index;\n    this.dtree = td;\n    this.dtree_index=td_index;\n    this.tree=null;\n}\n\nInfCodes.prototype.proc = function(s, z, r){ \n    var j;              // temporary storage\n    var t;              // temporary pointer (int[])\n    var tindex;         // temporary pointer\n    var e;              // extra bits or operation\n    var b=0;            // bit buffer\n    var k=0;            // bits in bit buffer\n    var p=0;            // input data pointer\n    var n;              // bytes available there\n    var q;              // output window write pointer\n    var m;              // bytes to end of window or read pointer\n    var f;              // pointer to copy strings from\n\n    // copy input/output information to locals (UPDATE macro restores)\n    p=z.next_in_index;n=z.avail_in;b=s.bitb;k=s.bitk;\n    q=s.write;m=q<s.read?s.read-q-1:s.end-q;\n\n    // process input and output based on current state\n    while (true){\n      switch (this.mode){\n\t// waiting for \"i:\"=input, \"o:\"=output, \"x:\"=nothing\n      case IC_START:         // x: set up for LEN\n\tif (m >= 258 && n >= 10){\n\n\t  s.bitb=b;s.bitk=k;\n\t  z.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;\n\t  s.write=q;\n\t  r = this.inflate_fast(this.lbits, this.dbits, \n\t\t\t   this.ltree, this.ltree_index, \n\t\t\t   this.dtree, this.dtree_index,\n\t\t\t   s, z);\n\n\t  p=z.next_in_index;n=z.avail_in;b=s.bitb;k=s.bitk;\n\t  q=s.write;m=q<s.read?s.read-q-1:s.end-q;\n\n\t  if (r != Z_OK){\n\t    this.mode = r == Z_STREAM_END ? IC_WASH : IC_BADCODE;\n\t    break;\n\t  }\n\t}\n\tthis.need = this.lbits;\n\tthis.tree = this.ltree;\n\tthis.tree_index=this.ltree_index;\n\n\tthis.mode = IC_LEN;\n      case IC_LEN:           // i: get length/literal/eob next\n\tj = this.need;\n\n\twhile(k<(j)){\n\t  if(n!=0)r=Z_OK;\n\t  else{\n\n\t    s.bitb=b;s.bitk=k;\n\t    z.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;\n\t    s.write=q;\n\t    return s.inflate_flush(z,r);\n\t  }\n\t  n--;\n\t  b|=(z.next_in[p++]&0xff)<<k;\n\t  k+=8;\n\t}\n\n\ttindex=(this.tree_index+(b&inflate_mask[j]))*3;\n\n\tb>>>=(this.tree[tindex+1]);\n\tk-=(this.tree[tindex+1]);\n\n\te=this.tree[tindex];\n\n\tif(e == 0){               // literal\n\t  this.lit = this.tree[tindex+2];\n\t  this.mode = IC_LIT;\n\t  break;\n\t}\n\tif((e & 16)!=0 ){          // length\n\t  this.get = e & 15;\n\t  this.len = this.tree[tindex+2];\n\t  this.mode = IC_LENEXT;\n\t  break;\n\t}\n\tif ((e & 64) == 0){        // next table\n\t  this.need = e;\n\t  this.tree_index = tindex/3 + this.tree[tindex+2];\n\t  break;\n\t}\n\tif ((e & 32)!=0){               // end of block\n\t  this.mode = IC_WASH;\n\t  break;\n\t}\n\tthis.mode = IC_BADCODE;        // invalid code\n\tz.msg = \"invalid literal/length code\";\n\tr = Z_DATA_ERROR;\n\n\ts.bitb=b;s.bitk=k;\n\tz.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;\n\ts.write=q;\n\treturn s.inflate_flush(z,r);\n\n      case IC_LENEXT:        // i: getting length extra (have base)\n\tj = this.get;\n\n\twhile(k<(j)){\n\t  if(n!=0)r=Z_OK;\n\t  else{\n\n\t    s.bitb=b;s.bitk=k;\n\t    z.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;\n\t    s.write=q;\n\t    return s.inflate_flush(z,r);\n\t  }\n\t  n--; b|=(z.next_in[p++]&0xff)<<k;\n\t  k+=8;\n\t}\n\n\tthis.len += (b & inflate_mask[j]);\n\n\tb>>=j;\n\tk-=j;\n\n\tthis.need = this.dbits;\n\tthis.tree = this.dtree;\n\tthis.tree_index = this.dtree_index;\n\tthis.mode = IC_DIST;\n      case IC_DIST:          // i: get distance next\n\tj = this.need;\n\n\twhile(k<(j)){\n\t  if(n!=0)r=Z_OK;\n\t  else{\n\n\t    s.bitb=b;s.bitk=k;\n\t    z.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;\n\t    s.write=q;\n\t    return s.inflate_flush(z,r);\n\t  }\n\t  n--; b|=(z.next_in[p++]&0xff)<<k;\n\t  k+=8;\n\t}\n\n\ttindex=(this.tree_index+(b & inflate_mask[j]))*3;\n\n\tb>>=this.tree[tindex+1];\n\tk-=this.tree[tindex+1];\n\n\te = (this.tree[tindex]);\n\tif((e & 16)!=0){               // distance\n\t  this.get = e & 15;\n\t  this.dist = this.tree[tindex+2];\n\t  this.mode = IC_DISTEXT;\n\t  break;\n\t}\n\tif ((e & 64) == 0){        // next table\n\t  this.need = e;\n\t  this.tree_index = tindex/3 + this.tree[tindex+2];\n\t  break;\n\t}\n\tthis.mode = IC_BADCODE;        // invalid code\n\tz.msg = \"invalid distance code\";\n\tr = Z_DATA_ERROR;\n\n\ts.bitb=b;s.bitk=k;\n\tz.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;\n\ts.write=q;\n\treturn s.inflate_flush(z,r);\n\n      case IC_DISTEXT:       // i: getting distance extra\n\tj = this.get;\n\n\twhile(k<(j)){\n\t  if(n!=0)r=Z_OK;\n\t  else{\n\n\t    s.bitb=b;s.bitk=k;\n\t    z.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;\n\t    s.write=q;\n\t    return s.inflate_flush(z,r);\n\t  }\n\t  n--; b|=(z.next_in[p++]&0xff)<<k;\n\t  k+=8;\n\t}\n\n\tthis.dist += (b & inflate_mask[j]);\n\n\tb>>=j;\n\tk-=j;\n\n\tthis.mode = IC_COPY;\n      case IC_COPY:          // o: copying bytes in window, waiting for space\n        f = q - this.dist;\n        while(f < 0){     // modulo window size-\"while\" instead\n          f += s.end;     // of \"if\" handles invalid distances\n\t}\n\twhile (this.len!=0){\n\n\t  if(m==0){\n\t    if(q==s.end&&s.read!=0){q=0;m=q<s.read?s.read-q-1:s.end-q;}\n\t    if(m==0){\n\t      s.write=q; r=s.inflate_flush(z,r);\n\t      q=s.write;m=q<s.read?s.read-q-1:s.end-q;\n\n\t      if(q==s.end&&s.read!=0){q=0;m=q<s.read?s.read-q-1:s.end-q;}\n\n\t      if(m==0){\n\t\ts.bitb=b;s.bitk=k;\n\t\tz.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;\n\t\ts.write=q;\n\t\treturn s.inflate_flush(z,r);\n\t      }  \n\t    }\n\t  }\n\n\t  s.window[q++]=s.window[f++]; m--;\n\n\t  if (f == s.end)\n            f = 0;\n\t  this.len--;\n\t}\n\tthis.mode = IC_START;\n\tbreak;\n      case IC_LIT:           // o: got literal, waiting for output space\n\tif(m==0){\n\t  if(q==s.end&&s.read!=0){q=0;m=q<s.read?s.read-q-1:s.end-q;}\n\t  if(m==0){\n\t    s.write=q; r=s.inflate_flush(z,r);\n\t    q=s.write;m=q<s.read?s.read-q-1:s.end-q;\n\n\t    if(q==s.end&&s.read!=0){q=0;m=q<s.read?s.read-q-1:s.end-q;}\n\t    if(m==0){\n\t      s.bitb=b;s.bitk=k;\n\t      z.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;\n\t      s.write=q;\n\t      return s.inflate_flush(z,r);\n\t    }\n\t  }\n\t}\n\tr=Z_OK;\n\n\ts.window[q++]=this.lit; m--;\n\n\tthis.mode = IC_START;\n\tbreak;\n      case IC_WASH:           // o: got eob, possibly more output\n\tif (k > 7){        // return unused byte, if any\n\t  k -= 8;\n\t  n++;\n\t  p--;             // can always return one\n\t}\n\n\ts.write=q; r=s.inflate_flush(z,r);\n\tq=s.write;m=q<s.read?s.read-q-1:s.end-q;\n\n\tif (s.read != s.write){\n\t  s.bitb=b;s.bitk=k;\n\t  z.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;\n\t  s.write=q;\n\t  return s.inflate_flush(z,r);\n\t}\n\tthis.mode = IC_END;\n      case IC_END:\n\tr = Z_STREAM_END;\n\ts.bitb=b;s.bitk=k;\n\tz.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;\n\ts.write=q;\n\treturn s.inflate_flush(z,r);\n\n      case IC_BADCODE:       // x: got error\n\n\tr = Z_DATA_ERROR;\n\n\ts.bitb=b;s.bitk=k;\n\tz.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;\n\ts.write=q;\n\treturn s.inflate_flush(z,r);\n\n      default:\n\tr = Z_STREAM_ERROR;\n\n\ts.bitb=b;s.bitk=k;\n\tz.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;\n\ts.write=q;\n\treturn s.inflate_flush(z,r);\n      }\n    }\n  }\n\nInfCodes.prototype.free = function(z){\n    //  ZFREE(z, c);\n}\n\n  // Called with number of bytes left to write in window at least 258\n  // (the maximum string length) and number of input bytes available\n  // at least ten.  The ten bytes are six bytes for the longest length/\n  // distance pair plus four bytes for overloading the bit buffer.\n\nInfCodes.prototype.inflate_fast = function(bl, bd, tl, tl_index, td, td_index, s, z) {\n    var t;                // temporary pointer\n    var   tp;             // temporary pointer (int[])\n    var tp_index;         // temporary pointer\n    var e;                // extra bits or operation\n    var b;                // bit buffer\n    var k;                // bits in bit buffer\n    var p;                // input data pointer\n    var n;                // bytes available there\n    var q;                // output window write pointer\n    var m;                // bytes to end of window or read pointer\n    var ml;               // mask for literal/length tree\n    var md;               // mask for distance tree\n    var c;                // bytes to copy\n    var d;                // distance back to copy from\n    var r;                // copy source pointer\n\n    var tp_index_t_3;     // (tp_index+t)*3\n\n    // load input, output, bit values\n    p=z.next_in_index;n=z.avail_in;b=s.bitb;k=s.bitk;\n    q=s.write;m=q<s.read?s.read-q-1:s.end-q;\n\n    // initialize masks\n    ml = inflate_mask[bl];\n    md = inflate_mask[bd];\n\n    // do until not enough input or output space for fast loop\n    do {                          // assume called with m >= 258 && n >= 10\n      // get literal/length code\n      while(k<(20)){              // max bits for literal/length code\n\tn--;\n\tb|=(z.next_in[p++]&0xff)<<k;k+=8;\n      }\n\n      t= b&ml;\n      tp=tl; \n      tp_index=tl_index;\n      tp_index_t_3=(tp_index+t)*3;\n      if ((e = tp[tp_index_t_3]) == 0){\n\tb>>=(tp[tp_index_t_3+1]); k-=(tp[tp_index_t_3+1]);\n\n\ts.window[q++] = tp[tp_index_t_3+2];\n\tm--;\n\tcontinue;\n      }\n      do {\n\n\tb>>=(tp[tp_index_t_3+1]); k-=(tp[tp_index_t_3+1]);\n\n\tif((e&16)!=0){\n\t  e &= 15;\n\t  c = tp[tp_index_t_3+2] + (b & inflate_mask[e]);\n\n\t  b>>=e; k-=e;\n\n\t  // decode distance base of block to copy\n\t  while(k<(15)){           // max bits for distance code\n\t    n--;\n\t    b|=(z.next_in[p++]&0xff)<<k;k+=8;\n\t  }\n\n\t  t= b&md;\n\t  tp=td;\n\t  tp_index=td_index;\n          tp_index_t_3=(tp_index+t)*3;\n\t  e = tp[tp_index_t_3];\n\n\t  do {\n\n\t    b>>=(tp[tp_index_t_3+1]); k-=(tp[tp_index_t_3+1]);\n\n\t    if((e&16)!=0){\n\t      // get extra bits to add to distance base\n\t      e &= 15;\n\t      while(k<(e)){         // get extra bits (up to 13)\n\t\tn--;\n\t\tb|=(z.next_in[p++]&0xff)<<k;k+=8;\n\t      }\n\n\t      d = tp[tp_index_t_3+2] + (b&inflate_mask[e]);\n\n\t      b>>=(e); k-=(e);\n\n\t      // do the copy\n\t      m -= c;\n\t      if (q >= d){                // offset before dest\n\t\t//  just copy\n\t\tr=q-d;\n\t\tif(q-r>0 && 2>(q-r)){           \n\t\t  s.window[q++]=s.window[r++]; // minimum count is three,\n\t\t  s.window[q++]=s.window[r++]; // so unroll loop a little\n\t\t  c-=2;\n\t\t}\n\t\telse{\n\t\t  s.window[q++]=s.window[r++]; // minimum count is three,\n\t\t  s.window[q++]=s.window[r++]; // so unroll loop a little\n\t\t  c-=2;\n\t\t}\n\t      }\n\t      else{                  // else offset after destination\n                r=q-d;\n                do{\n                  r+=s.end;          // force pointer in window\n                }while(r<0);         // covers invalid distances\n\t\te=s.end-r;\n\t\tif(c>e){             // if source crosses,\n\t\t  c-=e;              // wrapped copy\n\t\t  if(q-r>0 && e>(q-r)){           \n\t\t    do{s.window[q++] = s.window[r++];}\n\t\t    while(--e!=0);\n\t\t  }\n\t\t  else{\n\t\t    arrayCopy(s.window, r, s.window, q, e);\n\t\t    q+=e; r+=e; e=0;\n\t\t  }\n\t\t  r = 0;                  // copy rest from start of window\n\t\t}\n\n\t      }\n\n\t      // copy all or what's left\n              do{s.window[q++] = s.window[r++];}\n\t\twhile(--c!=0);\n\t      break;\n\t    }\n\t    else if((e&64)==0){\n\t      t+=tp[tp_index_t_3+2];\n\t      t+=(b&inflate_mask[e]);\n\t      tp_index_t_3=(tp_index+t)*3;\n\t      e=tp[tp_index_t_3];\n\t    }\n\t    else{\n\t      z.msg = \"invalid distance code\";\n\n\t      c=z.avail_in-n;c=(k>>3)<c?k>>3:c;n+=c;p-=c;k-=c<<3;\n\n\t      s.bitb=b;s.bitk=k;\n\t      z.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;\n\t      s.write=q;\n\n\t      return Z_DATA_ERROR;\n\t    }\n\t  }\n\t  while(true);\n\t  break;\n\t}\n\n\tif((e&64)==0){\n\t  t+=tp[tp_index_t_3+2];\n\t  t+=(b&inflate_mask[e]);\n\t  tp_index_t_3=(tp_index+t)*3;\n\t  if((e=tp[tp_index_t_3])==0){\n\n\t    b>>=(tp[tp_index_t_3+1]); k-=(tp[tp_index_t_3+1]);\n\n\t    s.window[q++]=tp[tp_index_t_3+2];\n\t    m--;\n\t    break;\n\t  }\n\t}\n\telse if((e&32)!=0){\n\n\t  c=z.avail_in-n;c=(k>>3)<c?k>>3:c;n+=c;p-=c;k-=c<<3;\n \n\t  s.bitb=b;s.bitk=k;\n\t  z.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;\n\t  s.write=q;\n\n\t  return Z_STREAM_END;\n\t}\n\telse{\n\t  z.msg=\"invalid literal/length code\";\n\n\t  c=z.avail_in-n;c=(k>>3)<c?k>>3:c;n+=c;p-=c;k-=c<<3;\n\n\t  s.bitb=b;s.bitk=k;\n\t  z.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;\n\t  s.write=q;\n\n\t  return Z_DATA_ERROR;\n\t}\n      } \n      while(true);\n    } \n    while(m>=258 && n>= 10);\n\n    // not enough input or output--restore pointers and return\n    c=z.avail_in-n;c=(k>>3)<c?k>>3:c;n+=c;p-=c;k-=c<<3;\n\n    s.bitb=b;s.bitk=k;\n    z.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;\n    s.write=q;\n\n    return Z_OK;\n}\n\n//\n// InfTree.java\n//\n\nfunction InfTree() {\n}\n\nInfTree.prototype.huft_build = function(b, bindex, n, s, d, e, t, m, hp, hn, v) {\n\n    // Given a list of code lengths and a maximum table size, make a set of\n    // tables to decode that set of codes.  Return Z_OK on success, Z_BUF_ERROR\n    // if the given code set is incomplete (the tables are still built in this\n    // case), Z_DATA_ERROR if the input is invalid (an over-subscribed set of\n    // lengths), or Z_MEM_ERROR if not enough memory.\n\n    var a;                       // counter for codes of length k\n    var f;                       // i repeats in table every f entries\n    var g;                       // maximum code length\n    var h;                       // table level\n    var i;                       // counter, current code\n    var j;                       // counter\n    var k;                       // number of bits in current code\n    var l;                       // bits per table (returned in m)\n    var mask;                    // (1 << w) - 1, to avoid cc -O bug on HP\n    var p;                       // pointer into c[], b[], or v[]\n    var q;                       // points to current table\n    var w;                       // bits before this table == (l * h)\n    var xp;                      // pointer into x\n    var y;                       // number of dummy codes added\n    var z;                       // number of entries in current table\n\n    // Generate counts for each bit length\n\n    p = 0; i = n;\n    do {\n      this.c[b[bindex+p]]++; p++; i--;   // assume all entries <= BMAX\n    }while(i!=0);\n\n    if(this.c[0] == n){                // null input--all zero length codes\n      t[0] = -1;\n      m[0] = 0;\n      return Z_OK;\n    }\n\n    // Find minimum and maximum length, bound *m by those\n    l = m[0];\n    for (j = 1; j <= BMAX; j++)\n      if(this.c[j]!=0) break;\n    k = j;                        // minimum code length\n    if(l < j){\n      l = j;\n    }\n    for (i = BMAX; i!=0; i--){\n      if(this.c[i]!=0) break;\n    }\n    g = i;                        // maximum code length\n    if(l > i){\n      l = i;\n    }\n    m[0] = l;\n\n    // Adjust last length count to fill out codes, if needed\n    for (y = 1 << j; j < i; j++, y <<= 1){\n      if ((y -= this.c[j]) < 0){\n        return Z_DATA_ERROR;\n      }\n    }\n    if ((y -= this.c[i]) < 0){\n      return Z_DATA_ERROR;\n    }\n    this.c[i] += y;\n\n    // Generate starting offsets into the value table for each length\n    this.x[1] = j = 0;\n    p = 1;  xp = 2;\n    while (--i!=0) {                 // note that i == g from above\n      this.x[xp] = (j += this.c[p]);\n      xp++;\n      p++;\n    }\n\n    // Make a table of values in order of bit lengths\n    i = 0; p = 0;\n    do {\n      if ((j = b[bindex+p]) != 0){\n        this.v[this.x[j]++] = i;\n      }\n      p++;\n    }\n    while (++i < n);\n    n = this.x[g];                     // set n to length of v\n\n    // Generate the Huffman codes and for each, make the table entries\n    this.x[0] = i = 0;                 // first Huffman code is zero\n    p = 0;                        // grab values in bit order\n    h = -1;                       // no tables yet--level -1\n    w = -l;                       // bits decoded == (l * h)\n    this.u[0] = 0;                     // just to keep compilers happy\n    q = 0;                        // ditto\n    z = 0;                        // ditto\n\n    // go through the bit lengths (k already is bits in shortest code)\n    for (; k <= g; k++){\n      a = this.c[k];\n      while (a--!=0){\n\t// here i is the Huffman code of length k bits for value *p\n\t// make tables up to required level\n        while (k > w + l){\n          h++;\n          w += l;                 // previous table always l bits\n\t  // compute minimum size table less than or equal to l bits\n          z = g - w;\n          z = (z > l) ? l : z;        // table size upper limit\n          if((f=1<<(j=k-w))>a+1){     // try a k-w bit table\n                                      // too few codes for k-w bit table\n            f -= a + 1;               // deduct codes from patterns left\n            xp = k;\n            if(j < z){\n              while (++j < z){        // try smaller tables up to z bits\n                if((f <<= 1) <= this.c[++xp])\n                  break;              // enough codes to use up j bits\n                f -= this.c[xp];           // else deduct codes from patterns\n              }\n\t    }\n          }\n          z = 1 << j;                 // table entries for j-bit table\n\n\t  // allocate new table\n          if (this.hn[0] + z > MANY){       // (note: doesn't matter for fixed)\n            return Z_DATA_ERROR;       // overflow of MANY\n          }\n          this.u[h] = q = /*hp+*/ this.hn[0];   // DEBUG\n          this.hn[0] += z;\n \n\t  // connect to last table, if there is one\n\t  if(h!=0){\n            this.x[h]=i;           // save pattern for backing up\n            this.r[0]=j;     // bits in this table\n            this.r[1]=l;     // bits to dump before this table\n            j=i>>>(w - l);\n            this.r[2] = (q - this.u[h-1] - j);               // offset to this table\n            arrayCopy(this.r, 0, hp, (this.u[h-1]+j)*3, 3); // connect to last table\n          }\n          else{\n            t[0] = q;               // first table is returned result\n\t  }\n        }\n\n\t// set up table entry in r\n        this.r[1] = (k - w);\n        if (p >= n){\n          this.r[0] = 128 + 64;      // out of values--invalid code\n\t}\n        else if (v[p] < s){\n          this.r[0] = (this.v[p] < 256 ? 0 : 32 + 64);  // 256 is end-of-block\n          this.r[2] = this.v[p++];          // simple code is just the value\n        }\n        else{\n          this.r[0]=(e[this.v[p]-s]+16+64); // non-simple--look up in lists\n          this.r[2]=d[this.v[p++] - s];\n        }\n\n        // fill code-like entries with r\n        f=1<<(k-w);\n        for (j=i>>>w;j<z;j+=f){\n          arrayCopy(this.r, 0, hp, (q+j)*3, 3);\n\t}\n\n\t// backwards increment the k-bit code i\n        for (j = 1 << (k - 1); (i & j)!=0; j >>>= 1){\n          i ^= j;\n\t}\n        i ^= j;\n\n\t// backup over finished tables\n        mask = (1 << w) - 1;      // needed on HP, cc -O bug\n        while ((i & mask) != this.x[h]){\n          h--;                    // don't need to update q\n          w -= l;\n          mask = (1 << w) - 1;\n        }\n      }\n    }\n    // Return Z_BUF_ERROR if we were given an incomplete table\n    return y != 0 && g != 1 ? Z_BUF_ERROR : Z_OK;\n}\n\nInfTree.prototype.inflate_trees_bits = function(c, bb, tb, hp, z) {\n    var result;\n    this.initWorkArea(19);\n    this.hn[0]=0;\n    result = this.huft_build(c, 0, 19, 19, null, null, tb, bb, hp, this.hn, this.v);\n\n    if(result == Z_DATA_ERROR){\n      z.msg = \"oversubscribed dynamic bit lengths tree\";\n    }\n    else if(result == Z_BUF_ERROR || bb[0] == 0){\n      z.msg = \"incomplete dynamic bit lengths tree\";\n      result = Z_DATA_ERROR;\n    }\n    return result;\n}\n\nInfTree.prototype.inflate_trees_dynamic = function(nl, nd, c, bl, bd, tl, td, hp, z) {\n    var result;\n\n    // build literal/length tree\n    this.initWorkArea(288);\n    this.hn[0]=0;\n    result = this.huft_build(c, 0, nl, 257, cplens, cplext, tl, bl, hp, this.hn, this.v);\n    if (result != Z_OK || bl[0] == 0){\n      if(result == Z_DATA_ERROR){\n        z.msg = \"oversubscribed literal/length tree\";\n      }\n      else if (result != Z_MEM_ERROR){\n        z.msg = \"incomplete literal/length tree\";\n        result = Z_DATA_ERROR;\n      }\n      return result;\n    }\n\n    // build distance tree\n    this.initWorkArea(288);\n    result = this.huft_build(c, nl, nd, 0, cpdist, cpdext, td, bd, hp, this.hn, this.v);\n\n    if (result != Z_OK || (bd[0] == 0 && nl > 257)){\n      if (result == Z_DATA_ERROR){\n        z.msg = \"oversubscribed distance tree\";\n      }\n      else if (result == Z_BUF_ERROR) {\n        z.msg = \"incomplete distance tree\";\n        result = Z_DATA_ERROR;\n      }\n      else if (result != Z_MEM_ERROR){\n        z.msg = \"empty distance tree with lengths\";\n        result = Z_DATA_ERROR;\n      }\n      return result;\n    }\n\n    return Z_OK;\n}\n/*\n  static int inflate_trees_fixed(int[] bl,  //literal desired/actual bit depth\n                                 int[] bd,  //distance desired/actual bit depth\n                                 int[][] tl,//literal/length tree result\n                                 int[][] td,//distance tree result \n                                 ZStream z  //for memory allocation\n\t\t\t\t ){\n\n*/\n\nfunction inflate_trees_fixed(bl, bd, tl, td, z) {\n    bl[0]=fixed_bl;\n    bd[0]=fixed_bd;\n    tl[0]=fixed_tl;\n    td[0]=fixed_td;\n    return Z_OK;\n}\n\nInfTree.prototype.initWorkArea = function(vsize){\n    if(this.hn==null){\n        this.hn=new Int32Array(1);\n        this.v=new Int32Array(vsize);\n        this.c=new Int32Array(BMAX+1);\n        this.r=new Int32Array(3);\n        this.u=new Int32Array(BMAX);\n        this.x=new Int32Array(BMAX+1);\n    }\n    if(this.v.length<vsize){ \n        this.v=new Int32Array(vsize); \n    }\n    for(var i=0; i<vsize; i++){this.v[i]=0;}\n    for(var i=0; i<BMAX+1; i++){this.c[i]=0;}\n    for(var i=0; i<3; i++){this.r[i]=0;}\n//  for(int i=0; i<BMAX; i++){u[i]=0;}\n    arrayCopy(this.c, 0, this.u, 0, BMAX);\n//  for(int i=0; i<BMAX+1; i++){x[i]=0;}\n    arrayCopy(this.c, 0, this.x, 0, BMAX+1);\n}\n\nvar testArray = new Uint8Array(1);\nvar hasSubarray = (typeof testArray.subarray === 'function');\nvar hasSlice = false; /* (typeof testArray.slice === 'function'); */ // Chrome slice performance is so dire that we're currently not using it...\n\nfunction arrayCopy(src, srcOffset, dest, destOffset, count) {\n    if (count == 0) {\n        return;\n    } \n    if (!src) {\n        throw \"Undef src\";\n    } else if (!dest) {\n        throw \"Undef dest\";\n    }\n\n    if (srcOffset == 0 && count == src.length) {\n        arrayCopy_fast(src, dest, destOffset);\n    } else if (hasSubarray) {\n        arrayCopy_fast(src.subarray(srcOffset, srcOffset + count), dest, destOffset); \n    } else if (src.BYTES_PER_ELEMENT == 1 && count > 100) {\n        arrayCopy_fast(new Uint8Array(src.buffer, src.byteOffset + srcOffset, count), dest, destOffset);\n    } else { \n        arrayCopy_slow(src, srcOffset, dest, destOffset, count);\n    }\n\n}\n\nfunction arrayCopy_slow(src, srcOffset, dest, destOffset, count) {\n\n    // dlog('_slow call: srcOffset=' + srcOffset + '; destOffset=' + destOffset + '; count=' + count);\n\n     for (var i = 0; i < count; ++i) {\n        dest[destOffset + i] = src[srcOffset + i];\n    }\n}\n\nfunction arrayCopy_fast(src, dest, destOffset) {\n    dest.set(src, destOffset);\n}\n\n\n  // largest prime smaller than 65536\nvar ADLER_BASE=65521; \n  // NMAX is the largest n such that 255n(n+1)/2 + (n+1)(BASE-1) <= 2^32-1\nvar ADLER_NMAX=5552;\n\nfunction adler32(adler, /* byte[] */ buf,  index, len){\n    if(buf == null){ return 1; }\n\n    var s1=adler&0xffff;\n    var s2=(adler>>16)&0xffff;\n    var k;\n\n    while(len > 0) {\n      k=len<ADLER_NMAX?len:ADLER_NMAX;\n      len-=k;\n      while(k>=16){\n        s1+=buf[index++]&0xff; s2+=s1;\n        s1+=buf[index++]&0xff; s2+=s1;\n        s1+=buf[index++]&0xff; s2+=s1;\n        s1+=buf[index++]&0xff; s2+=s1;\n        s1+=buf[index++]&0xff; s2+=s1;\n        s1+=buf[index++]&0xff; s2+=s1;\n        s1+=buf[index++]&0xff; s2+=s1;\n        s1+=buf[index++]&0xff; s2+=s1;\n        s1+=buf[index++]&0xff; s2+=s1;\n        s1+=buf[index++]&0xff; s2+=s1;\n        s1+=buf[index++]&0xff; s2+=s1;\n        s1+=buf[index++]&0xff; s2+=s1;\n        s1+=buf[index++]&0xff; s2+=s1;\n        s1+=buf[index++]&0xff; s2+=s1;\n        s1+=buf[index++]&0xff; s2+=s1;\n        s1+=buf[index++]&0xff; s2+=s1;\n        k-=16;\n      }\n      if(k!=0){\n        do{\n          s1+=buf[index++]&0xff; s2+=s1;\n        }\n        while(--k!=0);\n      }\n      s1%=ADLER_BASE;\n      s2%=ADLER_BASE;\n    }\n    return (s2<<16)|s1;\n}\n\n\n\nfunction jszlib_inflate_buffer(buffer, start, length, afterUncOffset) {\n    if (!start) {\n        buffer = new Uint8Array(buffer);\n    } else if (!length) {\n        buffer = new Uint8Array(buffer, start, buffer.byteLength - start);\n    } else {\n        buffer = new Uint8Array(buffer, start, length);\n    }\n\n    var z = new ZStream();\n    z.inflateInit(DEF_WBITS, true);\n    z.next_in = buffer;\n    z.next_in_index = 0;\n    z.avail_in = buffer.length;\n\n    var oBlockList = [];\n    var totalSize = 0;\n    while (true) {\n        var obuf = new Uint8Array(32000);\n        z.next_out = obuf;\n        z.next_out_index = 0;\n        z.avail_out = obuf.length;\n        var status = z.inflate(Z_NO_FLUSH);\n        if (status != Z_OK && status != Z_STREAM_END && status != Z_BUF_ERROR) {\n            throw z.msg;\n        }\n        if (z.avail_out != 0) {\n            var newob = new Uint8Array(obuf.length - z.avail_out);\n            arrayCopy(obuf, 0, newob, 0, (obuf.length - z.avail_out));\n            obuf = newob;\n        }\n        oBlockList.push(obuf);\n        totalSize += obuf.length;\n        if (status == Z_STREAM_END || status == Z_BUF_ERROR) {\n            break;\n        }\n    }\n\n    if (afterUncOffset) {\n        afterUncOffset[0] = (start || 0) + z.next_in_index;\n    }\n\n    if (oBlockList.length == 1) {\n        return oBlockList[0].buffer;\n    } else {\n        var out = new Uint8Array(totalSize);\n        var cursor = 0;\n        for (var i = 0; i < oBlockList.length; ++i) {\n            var b = oBlockList[i];\n            arrayCopy(b, 0, out, cursor, b.length);\n            cursor += b.length;\n        }\n        return out.buffer;\n    }\n}\n\nif (typeof(module) !== 'undefined') {\n  module.exports = {\n    inflateBuffer: jszlib_inflate_buffer,\n    arrayCopy: arrayCopy\n  };\n}\n\n},{}],25:[function(require,module,exports){\n// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n},{}]},{},[8])\n\n","/* -*- mode: javascript; c-basic-offset: 4; indent-tabs-mode: nil -*- */\n\n// \n// Dalliance Genome Explorer\n// (c) Thomas Down 2006-2010\n//\n// bigwig.js: indexed binary WIG (and BED) files\n//\n\n\"use strict\";\n\n\nif (typeof(require) !== 'undefined') {\n    var spans = require('./spans');\n    var Range = spans.Range;\n    var union = spans.union;\n    var intersection = spans.intersection;\n\n    var das = require('./das');\n    var DASFeature = das.DASFeature;\n    var DASGroup = das.DASGroup;\n\n    var utils = require('./utils');\n    var shallowCopy = utils.shallowCopy;\n\n    var bin = require('./bin');\n    var readInt = bin.readInt;\n\n    var jszlib = require('jszlib');\n    var jszlib_inflate_buffer = jszlib.inflateBuffer;\n    var arrayCopy = jszlib.arrayCopy;\n}\n\nvar BIG_WIG_MAGIC = 0x888FFC26;\nvar BIG_WIG_MAGIC_BE = 0x26FC8F88;\nvar BIG_BED_MAGIC = 0x8789F2EB;\nvar BIG_BED_MAGIC_BE = 0xEBF28987;\n\n\nvar BIG_WIG_TYPE_GRAPH = 1;\nvar BIG_WIG_TYPE_VSTEP = 2;\nvar BIG_WIG_TYPE_FSTEP = 3;\n  \nvar M1 = 256;\nvar M2 = 256*256;\nvar M3 = 256*256*256;\nvar M4 = 256*256*256*256;\n\nvar BED_COLOR_REGEXP = new RegExp(\"^[0-9]+,[0-9]+,[0-9]+\");\n\nfunction bwg_readOffset(ba, o) {\n    var offset = ba[o] + ba[o+1]*M1 + ba[o+2]*M2 + ba[o+3]*M3 + ba[o+4]*M4;\n    return offset;\n}\n\nfunction BigWig() {\n}\n\nBigWig.prototype.readChromTree = function(callback) {\n    var thisB = this;\n    this.chromsToIDs = {};\n    this.idsToChroms = {};\n    this.maxID = 0;\n\n    var udo = this.unzoomedDataOffset;\n    var eb = (udo - this.chromTreeOffset) & 3;\n    udo = udo + 4 - eb;\n\n    this.data.slice(this.chromTreeOffset, udo - this.chromTreeOffset).fetch(function(bpt) {\n        var ba = new Uint8Array(bpt);\n        var sa = new Int16Array(bpt);\n        var la = new Int32Array(bpt);\n        var bptMagic = la[0];\n        var blockSize = la[1];\n        var keySize = la[2];\n        var valSize = la[3];\n        var itemCount = bwg_readOffset(ba, 16);\n        var rootNodeOffset = 32;\n\n        var bptReadNode = function(offset) {\n            var nodeType = ba[offset];\n            var cnt = sa[(offset/2) + 1];\n            offset += 4;\n            for (var n = 0; n < cnt; ++n) {\n                if (nodeType == 0) {\n                    offset += keySize;\n                    var childOffset = bwg_readOffset(ba, offset);\n                    offset += 8;\n                    childOffset -= thisB.chromTreeOffset;\n                    bptReadNode(childOffset);\n                } else {\n                    var key = '';\n                    for (var ki = 0; ki < keySize; ++ki) {\n                        var charCode = ba[offset++];\n                        if (charCode != 0) {\n                            key += String.fromCharCode(charCode);\n                        }\n                    }\n                    var chromId = (ba[offset+3]<<24) | (ba[offset+2]<<16) | (ba[offset+1]<<8) | (ba[offset+0]);\n                    var chromSize = (ba[offset + 7]<<24) | (ba[offset+6]<<16) | (ba[offset+5]<<8) | (ba[offset+4]);\n                    offset += 8;\n\n                    thisB.chromsToIDs[key] = chromId;\n                    if (key.indexOf('chr') == 0) {\n                        thisB.chromsToIDs[key.substr(3)] = chromId;\n                    }\n                    thisB.idsToChroms[chromId] = key;\n                    thisB.maxID = Math.max(thisB.maxID, chromId);\n                }\n            }\n        };\n        bptReadNode(rootNodeOffset);\n\n        callback(thisB);\n    });\n}\n\nfunction BigWigView(bwg, cirTreeOffset, cirTreeLength, isSummary) {\n    this.bwg = bwg;\n    this.cirTreeOffset = cirTreeOffset;\n    this.cirTreeLength = cirTreeLength;\n    this.isSummary = isSummary;\n}\n\n\n\nBigWigView.prototype.readWigData = function(chrName, min, max, callback) {\n    var chr = this.bwg.chromsToIDs[chrName];\n    if (chr === undefined) {\n        // Not an error because some .bwgs won't have data for all chromosomes.\n        return callback([]);\n    } else {\n        this.readWigDataById(chr, min, max, callback);\n    }\n}\n\nBigWigView.prototype.readWigDataById = function(chr, min, max, callback) {\n    var thisB = this;\n    if (!this.cirHeader) {\n        this.bwg.data.slice(this.cirTreeOffset, 48).fetch(function(result) {\n            thisB.cirHeader = result;\n            var la = new Int32Array(thisB.cirHeader);\n            thisB.cirBlockSize = la[1];\n            thisB.readWigDataById(chr, min, max, callback);\n        });\n        return;\n    }\n\n    var blocksToFetch = [];\n    var outstanding = 0;\n\n    var beforeBWG = Date.now();\n\n    var filter = function(chromId, fmin, fmax, toks) {\n        return ((chr < 0 || chromId == chr) && fmin <= max && fmax >= min);\n    }\n\n    var cirFobRecur = function(offset, level) {\n        if (thisB.bwg.instrument)\n            console.log('level=' + level + '; offset=' + offset + '; time=' + (Date.now()|0));\n\n        outstanding += offset.length;\n\n        if (offset.length == 1 && offset[0] - thisB.cirTreeOffset == 48 && thisB.cachedCirRoot) {\n            cirFobRecur2(thisB.cachedCirRoot, 0, level);\n            --outstanding;\n            if (outstanding == 0) {\n                thisB.fetchFeatures(filter, blocksToFetch, callback);\n            }\n            return;\n        }\n\n        var maxCirBlockSpan = 4 +  (thisB.cirBlockSize * 32);   // Upper bound on size, based on a completely full leaf node.\n        var spans;\n        for (var i = 0; i < offset.length; ++i) {\n            var blockSpan = new Range(offset[i], offset[i] + maxCirBlockSpan);\n            spans = spans ? union(spans, blockSpan) : blockSpan;\n        }\n        \n        var fetchRanges = spans.ranges();\n        for (var r = 0; r < fetchRanges.length; ++r) {\n            var fr = fetchRanges[r];\n            cirFobStartFetch(offset, fr, level);\n        }\n    }\n\n    var cirFobStartFetch = function(offset, fr, level, attempts) {\n        var length = fr.max() - fr.min();\n        thisB.bwg.data.slice(fr.min(), fr.max() - fr.min()).fetch(function(resultBuffer) {\n            for (var i = 0; i < offset.length; ++i) {\n                if (fr.contains(offset[i])) {\n                    cirFobRecur2(resultBuffer, offset[i] - fr.min(), level);\n\n                    if (offset[i] - thisB.cirTreeOffset == 48 && offset[i] - fr.min() == 0)\n                        thisB.cachedCirRoot = resultBuffer;\n\n                    --outstanding;\n                    if (outstanding == 0) {\n                        thisB.fetchFeatures(filter, blocksToFetch, callback);\n                    }\n                }\n            }\n        });\n    }\n\n    var cirFobRecur2 = function(cirBlockData, offset, level) {\n        var ba = new Uint8Array(cirBlockData);\n        var sa = new Int16Array(cirBlockData);\n        var la = new Int32Array(cirBlockData);\n\n        var isLeaf = ba[offset];\n        var cnt = sa[offset/2 + 1];\n        offset += 4;\n\n        if (isLeaf != 0) {\n            for (var i = 0; i < cnt; ++i) {\n                var lo = offset/4;\n                var startChrom = la[lo];\n                var startBase = la[lo + 1];\n                var endChrom = la[lo + 2];\n                var endBase = la[lo + 3];\n                var blockOffset = bwg_readOffset(ba, offset+16);\n                var blockSize = bwg_readOffset(ba, offset+24);\n                if (((chr < 0 || startChrom < chr) || (startChrom == chr && startBase <= max)) &&\n                    ((chr < 0 || endChrom   > chr) || (endChrom == chr && endBase >= min)))\n                {\n                    blocksToFetch.push({offset: blockOffset, size: blockSize});\n                }\n                offset += 32;\n            }\n        } else {\n            var recurOffsets = [];\n            for (var i = 0; i < cnt; ++i) {\n                var lo = offset/4;\n                var startChrom = la[lo];\n                var startBase = la[lo + 1];\n                var endChrom = la[lo + 2];\n                var endBase = la[lo + 3];\n                var blockOffset = bwg_readOffset(ba, offset+16);\n                if ((chr < 0 || startChrom < chr || (startChrom == chr && startBase <= max)) &&\n                    (chr < 0 || endChrom   > chr || (endChrom == chr && endBase >= min)))\n                {\n                    recurOffsets.push(blockOffset);\n                }\n                offset += 24;\n            }\n            if (recurOffsets.length > 0) {\n                cirFobRecur(recurOffsets, level + 1);\n            }\n        }\n    };\n\n    cirFobRecur([thisB.cirTreeOffset + 48], 1);\n}\n\n\nBigWigView.prototype.fetchFeatures = function(filter, blocksToFetch, callback) {\n    var thisB = this;\n\n    blocksToFetch.sort(function(b0, b1) {\n        return (b0.offset|0) - (b1.offset|0);\n    });\n\n    if (blocksToFetch.length == 0) {\n        callback([]);\n    } else {\n        var features = [];\n        var createFeature = function(chr, fmin, fmax, opts) {\n            if (!opts) {\n                opts = {};\n            }\n        \n            var f = new DASFeature();\n            f._chromId = chr;\n            f.segment = thisB.bwg.idsToChroms[chr];\n            f.min = fmin;\n            f.max = fmax;\n            f.type = thisB.bwg.type;\n            \n            for (var k in opts) {\n                f[k] = opts[k];\n            }\n            \n            features.push(f);\n        };\n\n        var tramp = function() {\n            if (blocksToFetch.length == 0) {\n                var afterBWG = Date.now();\n                // dlog('BWG fetch took ' + (afterBWG - beforeBWG) + 'ms');\n                callback(features);\n                return;  // just in case...\n            } else {\n                var block = blocksToFetch[0];\n                if (block.data) {\n                    thisB.parseFeatures(block.data, createFeature, filter);\n                    blocksToFetch.splice(0, 1);\n                    tramp();\n                } else {\n                    var fetchStart = block.offset;\n                    var fetchSize = block.size;\n                    var bi = 1;\n                    while (bi < blocksToFetch.length && blocksToFetch[bi].offset == (fetchStart + fetchSize)) {\n                        fetchSize += blocksToFetch[bi].size;\n                        ++bi;\n                    }\n\n                    thisB.bwg.data.slice(fetchStart, fetchSize).fetch(function(result) {\n                        var offset = 0;\n                        var bi = 0;\n                        while (offset < fetchSize) {\n                            var fb = blocksToFetch[bi];\n                        \n                            var data;\n                            if (thisB.bwg.uncompressBufSize > 0) {\n                                data = jszlib_inflate_buffer(result, offset + 2, fb.size - 2);\n                            } else {\n                                var tmp = new Uint8Array(fb.size);    // FIXME is this really the best we can do?\n                                arrayCopy(new Uint8Array(result, offset, fb.size), 0, tmp, 0, fb.size);\n                                data = tmp.buffer;\n                            }\n                            fb.data = data;\n                            \n                            offset += fb.size;\n                            ++bi;\n                        }\n                        tramp();\n                    });\n                }\n            }\n        }\n        tramp();\n    }\n}\n\nBigWigView.prototype.parseFeatures = function(data, createFeature, filter) {\n    var ba = new Uint8Array(data);\n\n    if (this.isSummary) {\n        var sa = new Int16Array(data);\n        var la = new Int32Array(data);\n        var fa = new Float32Array(data);\n\n        var itemCount = data.byteLength/32;\n        for (var i = 0; i < itemCount; ++i) {\n            var chromId =   la[(i*8)];\n            var start =     la[(i*8)+1];\n            var end =       la[(i*8)+2];\n            var validCnt =  la[(i*8)+3];\n            var minVal    = fa[(i*8)+4];\n            var maxVal    = fa[(i*8)+5];\n            var sumData   = fa[(i*8)+6];\n            var sumSqData = fa[(i*8)+7];\n            \n            if (filter(chromId, start + 1, end)) {\n                var summaryOpts = {type: 'bigwig', score: sumData/validCnt, maxScore: maxVal};\n                if (this.bwg.type == 'bigbed') {\n                    summaryOpts.type = 'density';\n                }\n                createFeature(chromId, start + 1, end, summaryOpts);\n            }\n        }\n    } else if (this.bwg.type == 'bigwig') {\n        var sa = new Int16Array(data);\n        var la = new Int32Array(data);\n        var fa = new Float32Array(data);\n\n        var chromId = la[0];\n        var blockStart = la[1];\n        var blockEnd = la[2];\n        var itemStep = la[3];\n        var itemSpan = la[4];\n        var blockType = ba[20];\n        var itemCount = sa[11];\n        \n        if (blockType == BIG_WIG_TYPE_FSTEP) {\n            for (var i = 0; i < itemCount; ++i) {\n                var score = fa[i + 6];\n                var fmin = blockStart + (i*itemStep) + 1, fmax = blockStart + (i*itemStep) + itemSpan;\n                if (filter(chromId, fmin, fmax))\n                    createFeature(chromId, fmin, fmax, {score: score});\n            }\n        } else if (blockType == BIG_WIG_TYPE_VSTEP) {\n            for (var i = 0; i < itemCount; ++i) {\n                var start = la[(i*2) + 6] + 1;\n                var end = start + itemSpan - 1;\n                var score = fa[(i*2) + 7];\n                if (filter(chromId, start, end))\n                    createFeature(chromId, start, end, {score: score});\n            }\n        } else if (blockType == BIG_WIG_TYPE_GRAPH) {\n            for (var i = 0; i < itemCount; ++i) {\n                var start = la[(i*3) + 6] + 1;\n                var end   = la[(i*3) + 7];\n                var score = fa[(i*3) + 8];\n                if (start > end) {\n                    start = end;\n                }\n                if (filter(chromId, start, end))\n                    createFeature(chromId, start, end, {score: score});\n            }\n        } else {\n            console.log('Currently not handling bwgType=' + blockType);\n        }\n    } else if (this.bwg.type == 'bigbed') {\n        var offset = 0;\n        var dfc = this.bwg.definedFieldCount;\n        var schema = this.bwg.schema;\n\n        while (offset < ba.length) {\n            var chromId = (ba[offset+3]<<24) | (ba[offset+2]<<16) | (ba[offset+1]<<8) | (ba[offset+0]);\n            var start = (ba[offset+7]<<24) | (ba[offset+6]<<16) | (ba[offset+5]<<8) | (ba[offset+4]);\n            var end = (ba[offset+11]<<24) | (ba[offset+10]<<16) | (ba[offset+9]<<8) | (ba[offset+8]);\n            offset += 12;\n            var rest = '';\n            while (true) {\n                var ch = ba[offset++];\n                if (ch != 0) {\n                    rest += String.fromCharCode(ch);\n                } else {\n                    break;\n                }\n            }\n\n            var featureOpts = {};\n            \n            var bedColumns;\n            if (rest.length > 0) {\n                bedColumns = rest.split('\\t');\n            } else {\n                bedColumns = [];\n            }\n            if (bedColumns.length > 0 && dfc > 3) {\n                featureOpts.label = bedColumns[0];\n            }\n            if (bedColumns.length > 1 && dfc > 4) {\n                var score = parseInt(bedColumns[1]);\n                if (!isNaN(score))\n                    featureOpts.score = score;\n            }\n            if (bedColumns.length > 2 && dfc > 5) {\n                featureOpts.orientation = bedColumns[2];\n            }\n            if (bedColumns.length > 5 && dfc > 8) {\n                var color = bedColumns[5];\n                if (BED_COLOR_REGEXP.test(color)) {\n                    featureOpts.itemRgb = 'rgb(' + color + ')';\n                }\n            }\n\n            if (bedColumns.length > dfc-3 && schema) {\n                for (var col = dfc - 3; col < bedColumns.length; ++col) {\n                    featureOpts[schema.fields[col+3].name] = bedColumns[col];\n                }\n            }\n\n            if (filter(chromId, start + 1, end, bedColumns)) {\n                if (dfc < 12) {\n                    createFeature(chromId, start + 1, end, featureOpts);\n                } else {\n                    var thickStart = bedColumns[3]|0;\n                    var thickEnd   = bedColumns[4]|0;\n                    var blockCount = bedColumns[6]|0;\n                    var blockSizes = bedColumns[7].split(',');\n                    var blockStarts = bedColumns[8].split(',');\n\n                    if (featureOpts.exonFrames) {\n                        var exonFrames = featureOpts.exonFrames.split(',');\n                        featureOpts.exonFrames = undefined;\n                    }\n                    \n                    featureOpts.type = 'transcript'\n                    var grp = new DASGroup();\n                    for (var k in featureOpts) {\n                        grp[k] = featureOpts[k];\n                    }\n                    grp.id = bedColumns[0];\n                    grp.segment = this.bwg.idsToChroms[chromId];\n                    grp.min = start + 1;\n                    grp.max = end;\n                    grp.notes = [];\n                    featureOpts.groups = [grp];\n\n                    // Moving towards using bigGenePred model, but will\n                    // still support old Dalliance-style BED12+gene-name for the\n                    // foreseeable future.\n                    if (bedColumns.length > 9) {\n                        var geneId = featureOpts.geneName || bedColumns[9];\n                        var geneName = geneId;\n                        if (bedColumns.length > 10) {\n                            geneName = bedColumns[10];\n                        }\n                        if (featureOpts.geneName2)\n                            geneName = featureOpts.geneName2;\n\n                        var gg = shallowCopy(grp);\n                        gg.id = geneId;\n                        gg.label = geneName;\n                        gg.type = 'gene';\n                        featureOpts.groups.push(gg);\n                    }\n\n                    var spanList = [];\n                    for (var b = 0; b < blockCount; ++b) {\n                        var bmin = (blockStarts[b]|0) + start;\n                        var bmax = bmin + (blockSizes[b]|0);\n                        var span = new Range(bmin, bmax);\n                        spanList.push(span);\n                    }\n                    var spans = union(spanList);\n                    \n                    var tsList = spans.ranges();\n                    for (var s = 0; s < tsList.length; ++s) {\n                        var ts = tsList[s];\n                        createFeature(chromId, ts.min() + 1, ts.max(), featureOpts);\n                    }\n\n                    if (thickEnd > thickStart) {\n                        var codingRegion = (featureOpts.orientation == '+') ?\n                            new Range(thickStart, thickEnd + 3) :\n                            new Range(thickStart - 3, thickEnd);\n                            // +/- 3 to account for stop codon\n\n                        var tl = intersection(spans, codingRegion);\n                        if (tl) {\n                            featureOpts.type = 'translation';\n                            var tlList = tl.ranges();\n                            var readingFrame = 0;\n\n                            var tlOffset = 0;\n                            while (tlList[0].min() > tsList[tlOffset].max())\n                                tlOffset++;\n\n                            for (var s = 0; s < tlList.length; ++s) {\n                                // Record reading frame for every exon\n                                var index = s;\n                                if (featureOpts.orientation == '-')\n                                    index = tlList.length - s - 1;\n                                var ts = tlList[index];\n                                featureOpts.readframe = readingFrame;\n                                if (exonFrames) {\n                                    var brf = parseInt(exonFrames[index + tlOffset]);\n                                    if (typeof(brf) === 'number' && brf >= 0 && brf <= 2) {\n                                        featureOpts.readframe = brf;\n                                        featureOpts.readframeExplicit = true;\n                                    }\n                                }\n                                var length = ts.max() - ts.min();\n                                readingFrame = (readingFrame + length) % 3;\n                                createFeature(chromId, ts.min() + 1, ts.max(), featureOpts);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    } else {\n        throw Error(\"Don't know what to do with \" + this.bwg.type);\n    }\n}\n\n//\n// nasty cut/paste, should roll back in!\n//\n\nBigWigView.prototype.getFirstAdjacent = function(chrName, pos, dir, callback) {\n    var chr = this.bwg.chromsToIDs[chrName];\n    if (chr === undefined) {\n        // Not an error because some .bwgs won't have data for all chromosomes.\n        return callback([]);\n    } else {\n        this.getFirstAdjacentById(chr, pos, dir, callback);\n    }\n}\n\nBigWigView.prototype.getFirstAdjacentById = function(chr, pos, dir, callback) {\n    var thisB = this;\n    if (!this.cirHeader) {\n        this.bwg.data.slice(this.cirTreeOffset, 48).fetch(function(result) {\n            thisB.cirHeader = result;\n            var la = new Int32Array(thisB.cirHeader);\n            thisB.cirBlockSize = la[1];\n            thisB.getFirstAdjacentById(chr, pos, dir, callback);\n        });\n        return;\n    }\n\n    var blockToFetch = null;\n    var bestBlockChr = -1;\n    var bestBlockOffset = -1;\n\n    var outstanding = 0;\n\n    var beforeBWG = Date.now();\n\n    var cirFobRecur = function(offset, level) {\n        outstanding += offset.length;\n\n        var maxCirBlockSpan = 4 +  (thisB.cirBlockSize * 32);   // Upper bound on size, based on a completely full leaf node.\n        var spans;\n        for (var i = 0; i < offset.length; ++i) {\n            var blockSpan = new Range(offset[i], offset[i] + maxCirBlockSpan);\n            spans = spans ? union(spans, blockSpan) : blockSpan;\n        }\n        \n        var fetchRanges = spans.ranges();\n        for (var r = 0; r < fetchRanges.length; ++r) {\n            var fr = fetchRanges[r];\n            cirFobStartFetch(offset, fr, level);\n        }\n    }\n\n    var cirFobStartFetch = function(offset, fr, level, attempts) {\n        var length = fr.max() - fr.min();\n        thisB.bwg.data.slice(fr.min(), fr.max() - fr.min()).fetch(function(resultBuffer) {\n            for (var i = 0; i < offset.length; ++i) {\n                if (fr.contains(offset[i])) {\n                    cirFobRecur2(resultBuffer, offset[i] - fr.min(), level);\n                    --outstanding;\n                    if (outstanding == 0) {\n                        if (!blockToFetch) {\n                            if (dir > 0 && (chr != 0 || pos > 0)) {\n                                return thisB.getFirstAdjacentById(0, 0, dir, callback);\n                            } else if (dir < 0 && (chr != thisB.bwg.maxID || pos < 1000000000)) {\n                                return thisB.getFirstAdjacentById(thisB.bwg.maxID, 1000000000, dir, callback);\n                            }\n                            return callback([]);\n                        }\n\n                        thisB.fetchFeatures(function(chrx, fmin, fmax, toks) {\n                            return (dir < 0 && (chrx < chr || fmax < pos)) || (dir > 0 && (chrx > chr || fmin > pos));\n                        }, [blockToFetch], function(features) {\n                            var bestFeature = null;\n                            var bestChr = -1;\n                            var bestPos = -1;\n                            for (var fi = 0; fi < features.length; ++fi) {\n                                var f = features[fi];\n                                var chrx = f._chromId, fmin = f.min, fmax = f.max;\n                                if (bestFeature == null || ((dir < 0) && (chrx > bestChr || fmax > bestPos)) || ((dir > 0) && (chrx < bestChr || fmin < bestPos))) {\n                                    bestFeature = f;\n                                    bestPos = (dir < 0) ? fmax : fmin;\n                                    bestChr = chrx;\n                                }\n                            }\n\n                            if (bestFeature != null) \n                                return callback([bestFeature]);\n                            else\n                                return callback([]);\n                        });\n                    }\n                }\n            }\n        });\n    }\n\n    var cirFobRecur2 = function(cirBlockData, offset, level) {\n        var ba = new Uint8Array(cirBlockData);\n        var sa = new Int16Array(cirBlockData);\n        var la = new Int32Array(cirBlockData);\n\n        var isLeaf = ba[offset];\n        var cnt = sa[offset/2 + 1];\n        offset += 4;\n\n        if (isLeaf != 0) {\n            for (var i = 0; i < cnt; ++i) {\n                var lo = offset/4;\n                var startChrom = la[lo];\n                var startBase = la[lo + 1];\n                var endChrom = la[lo + 2];\n                var endBase = la[lo + 3];\n                var blockOffset = bwg_readOffset(ba, offset+16);\n                var blockSize = bwg_readOffset(ba, offset+24);\n                if ((dir < 0 && ((startChrom < chr || (startChrom == chr && startBase <= pos)))) ||\n                    (dir > 0 && ((endChrom > chr || (endChrom == chr && endBase >= pos)))))\n                {\n                    // console.log('Got an interesting block: startBase=' + startChrom + ':' + startBase + '; endBase=' + endChrom + ':' + endBase + '; offset=' + blockOffset + '; size=' + blockSize);\n                    if (/_random/.exec(thisB.bwg.idsToChroms[startChrom])) {\n                        // dlog('skipping random: ' + thisB.bwg.idsToChroms[startChrom]);\n                    } else if (blockToFetch == null || ((dir < 0) && (endChrom > bestBlockChr || (endChrom == bestBlockChr && endBase > bestBlockOffset)) ||\n                                                 (dir > 0) && (startChrom < bestBlockChr || (startChrom == bestBlockChr && startBase < bestBlockOffset))))\n                    {\n                        //                        dlog('best is: startBase=' + startChrom + ':' + startBase + '; endBase=' + endChrom + ':' + endBase + '; offset=' + blockOffset + '; size=' + blockSize);\n                        blockToFetch = {offset: blockOffset, size: blockSize};\n                        bestBlockOffset = (dir < 0) ? endBase : startBase;\n                        bestBlockChr = (dir < 0) ? endChrom : startChrom;\n                    }\n                }\n                offset += 32;\n            }\n        } else {\n            var bestRecur = -1;\n            var bestPos = -1;\n            var bestChr = -1;\n            for (var i = 0; i < cnt; ++i) {\n                var lo = offset/4;\n                var startChrom = la[lo];\n                var startBase = la[lo + 1];\n                var endChrom = la[lo + 2];\n                var endBase = la[lo + 3];\n                var blockOffset = (la[lo + 4]<<32) | (la[lo + 5]);\n                if ((dir < 0 && ((startChrom < chr || (startChrom == chr && startBase <= pos)) &&\n                                 (endChrom   >= chr))) ||\n                     (dir > 0 && ((endChrom > chr || (endChrom == chr && endBase >= pos)) &&\n                                  (startChrom <= chr))))\n                {\n                    if (bestRecur < 0 || endBase > bestPos) {\n                        bestRecur = blockOffset;\n                        bestPos = (dir < 0) ? endBase : startBase;\n                        bestChr = (dir < 0) ? endChrom : startChrom;\n                    }\n                }\n                offset += 24;\n            }\n            if (bestRecur >= 0) {\n                cirFobRecur([bestRecur], level + 1);\n            }\n        }\n    };\n    \n\n    cirFobRecur([thisB.cirTreeOffset + 48], 1);\n}\n\nBigWig.prototype.readWigData = function(chrName, min, max, callback) {\n    this.getUnzoomedView().readWigData(chrName, min, max, callback);\n}\n\nBigWig.prototype.getUnzoomedView = function() {\n    if (!this.unzoomedView) {\n        var cirLen = 4000;\n        var nzl = this.zoomLevels[0];\n        if (nzl) {\n            cirLen = this.zoomLevels[0].dataOffset - this.unzoomedIndexOffset;\n        }\n        this.unzoomedView = new BigWigView(this, this.unzoomedIndexOffset, cirLen, false);\n    }\n    return this.unzoomedView;\n}\n\nBigWig.prototype.getZoomedView = function(z) {\n    var zh = this.zoomLevels[z];\n    if (!zh.view) {\n        zh.view = new BigWigView(this, zh.indexOffset, /* this.zoomLevels[z + 1].dataOffset - zh.indexOffset */ 4000, true);\n    }\n    return zh.view;\n}\n\nfunction makeBwg(data, callback, name) {\n    var bwg = new BigWig();\n    bwg.data = data;\n    bwg.name = name;\n    bwg.data.slice(0, 512).salted().fetch(function(result) {\n        if (!result) {\n            return callback(null, \"Couldn't fetch file\");\n        }\n\n        var header = result;\n        var ba = new Uint8Array(header);\n        var sa = new Int16Array(header);\n        var la = new Int32Array(header);\n        var magic = ba[0] + (M1 * ba[1]) + (M2 * ba[2]) + (M3 * ba[3]);\n        if (magic == BIG_WIG_MAGIC) {\n            bwg.type = 'bigwig';\n        } else if (magic == BIG_BED_MAGIC) {\n            bwg.type = 'bigbed';\n        } else if (magic == BIG_WIG_MAGIC_BE || magic == BIG_BED_MAGIC_BE) {\n            return callback(null, \"Currently don't support big-endian BBI files\");\n            \n        } else {\n            return callback(null, \"Not a supported format, magic=0x\" + magic.toString(16));\n            \n        }\n\n        bwg.version = sa[2];             // 4\n        bwg.numZoomLevels = sa[3];       // 6\n        bwg.chromTreeOffset = bwg_readOffset(ba, 8);\n        bwg.unzoomedDataOffset = bwg_readOffset(ba, 16);\n        bwg.unzoomedIndexOffset = bwg_readOffset(ba, 24);\n        bwg.fieldCount = sa[16];         // 32\n        bwg.definedFieldCount = sa[17];  // 34\n        bwg.asOffset = bwg_readOffset(ba, 36);\n        bwg.totalSummaryOffset = bwg_readOffset(ba, 44);\n        bwg.uncompressBufSize = la[13];  // 52\n        bwg.extHeaderOffset = bwg_readOffset(ba, 56);\n\n        bwg.zoomLevels = [];\n        for (var zl = 0; zl < bwg.numZoomLevels; ++zl) {\n            var zlReduction = la[zl*6 + 16]\n            var zlData = bwg_readOffset(ba, zl*24 + 72);\n            var zlIndex = bwg_readOffset(ba, zl*24 + 80);\n            bwg.zoomLevels.push({reduction: zlReduction, dataOffset: zlData, indexOffset: zlIndex});\n        }\n\n        bwg.readChromTree(function() {\n            bwg.getAutoSQL(function(as) {\n                bwg.schema = as;\n                return callback(bwg);\n            });\n        });\n    }, {timeout: 5000});    // Potential timeout on first request to catch mixed-content errors on\n                            // Chromium.\n}\n\n\nBigWig.prototype._tsFetch = function(zoom, chr, min, max, callback) {\n    var bwg = this;\n    if (zoom >= this.zoomLevels.length - 1) {\n        if (!this.topLevelReductionCache) {\n            this.getZoomedView(this.zoomLevels.length - 1).readWigDataById(-1, 0, 300000000, function(feats) {\n                bwg.topLevelReductionCache = feats;\n                return bwg._tsFetch(zoom, chr, min, max, callback);\n            });\n        } else {\n            var f = [];\n            var c = this.topLevelReductionCache;\n            for (var fi = 0; fi < c.length; ++fi) {\n                if (c[fi]._chromId == chr) {\n                    f.push(c[fi]);\n                }\n            }\n            return callback(f);\n        }\n    } else {\n        var view;\n        if (zoom < 0) {\n            view = this.getUnzoomedView();\n        } else {\n            view = this.getZoomedView(zoom);\n        }\n        return view.readWigDataById(chr, min, max, callback);\n    }\n}\n\nBigWig.prototype.thresholdSearch = function(chrName, referencePoint, dir, threshold, callback) {\n    dir = (dir<0) ? -1 : 1;\n    var bwg = this;\n    var initialChr = this.chromsToIDs[chrName];\n    var candidates = [{chrOrd: 0, chr: initialChr, zoom: bwg.zoomLevels.length - 4, min: 0, max: 300000000, fromRef: true}]\n    for (var i = 1; i <= this.maxID + 1; ++i) {\n        var chrId = (initialChr + (dir*i)) % (this.maxID + 1);\n        if (chrId < 0) \n            chrId += (this.maxID + 1);\n        candidates.push({chrOrd: i, chr: chrId, zoom: bwg.zoomLevels.length - 1, min: 0, max: 300000000})\n    }\n       \n    function fbThresholdSearchRecur() {\n    \tif (candidates.length == 0) {\n    \t    return callback(null);\n    \t}\n    \tcandidates.sort(function(c1, c2) {\n    \t    var d = c1.zoom - c2.zoom;\n    \t    if (d != 0)\n    \t\t    return d;\n\n            d = c1.chrOrd - c2.chrOrd;\n            if (d != 0)\n                return d;\n    \t    else\n    \t\t    return c1.min - c2.min * dir;\n    \t});\n\n\t    var candidate = candidates.splice(0, 1)[0];\n        bwg._tsFetch(candidate.zoom, candidate.chr, candidate.min, candidate.max, function(feats) {\n            var rp = dir > 0 ? 0 : 300000000;\n            if (candidate.fromRef)\n                rp = referencePoint;\n            \n            for (var fi = 0; fi < feats.length; ++fi) {\n    \t        var f = feats[fi];\n                var score;\n                if (f.maxScore != undefined)\n                    score = f.maxScore;\n                else\n                    score = f.score;\n\n                if (dir > 0) {\n    \t            if (score > threshold) {\n        \t\t        if (candidate.zoom < 0) {\n        \t\t            if (f.min > rp)\n                                return callback(f);\n        \t\t        } else if (f.max > rp) {\n        \t\t            candidates.push({chr: candidate.chr, chrOrd: candidate.chrOrd, zoom: candidate.zoom - 2, min: f.min, max: f.max, fromRef: candidate.fromRef});\n        \t\t        }\n                    }\n                } else {\n                    if (score > threshold) {\n            \t\t    if (candidate.zoom < 0) {\n                \t        if (f.max < rp)\n                \t\t\t    return callback(f);\n                        } else if (f.min < rp) {\n                            candidates.push({chr: candidate.chr, chrOrd: candidate.chrOrd, zoom: candidate.zoom - 2, min: f.min, max: f.max, fromRef: candidate.fromRef});\n                        }\n    \t            }\n                }\n    \t    }\n            fbThresholdSearchRecur();\n        });\n    }\n    \n    fbThresholdSearchRecur();\n}\n\nBigWig.prototype.getAutoSQL = function(callback) {\n    var thisB = this;\n    if (!this.asOffset)\n        return callback(null);\n\n\n    this.data.slice(this.asOffset, 2048).fetch(function(result) {\n        var ba = new Uint8Array(result);\n        var s = '';\n        for (var i = 0; i < ba.length; ++i) {\n            if (ba[i] == 0)\n                break;\n            s += String.fromCharCode(ba[i]);\n        }\n        \n        /* \n         * Quick'n'dirty attempt to parse autoSql format.\n         * See: http://www.linuxjournal.com/files/linuxjournal.com/linuxjournal/articles/059/5949/5949l2.html\n         */\n\n        var header_re = /(\\w+)\\s+(\\w+)\\s+(\"([^\"]+)\")?\\s+\\(\\s*/;\n        var field_re = /([\\w\\[\\]]+)\\s+(\\w+)\\s*;\\s*(\"([^\"]+)\")?\\s*/g;\n\n        var headerMatch = header_re.exec(s);\n        if (headerMatch) {\n            var as = {\n                declType: headerMatch[1],\n                name: headerMatch[2],\n                comment: headerMatch[4],\n\n                fields: []\n            };\n\n            s = s.substring(headerMatch[0]);\n            for (var m = field_re.exec(s); m != null; m = field_re.exec(s)) {\n                as.fields.push({type: m[1],\n                             name: m[2],\n                             comment: m[4]});\n            }\n\n            return callback(as);\n        }\n    });\n}\n\nBigWig.prototype.getExtraIndices = function(callback) {\n    var thisB = this;\n    if (this.version < 4 || this.extHeaderOffset == 0 || this.type != 'bigbed') {\n        return callback(null);\n    } else {\n        this.data.slice(this.extHeaderOffset, 64).fetch(function(result) {\n            if (!result) {\n                return callback(null, \"Couldn't fetch extension header\");\n            }\n\n            var ba = new Uint8Array(result);\n            var sa = new Int16Array(result);\n            var la = new Int32Array(result);\n            \n            var extHeaderSize = sa[0];\n            var extraIndexCount = sa[1];\n            var extraIndexListOffset = bwg_readOffset(ba, 4);\n\n            if (extraIndexCount == 0) {\n                return callback(null);\n            }\n\n            // FIXME 20byte records only make sense for single-field indices.\n            // Right now, these seem to be the only things around, but the format\n            // is actually more general.\n            thisB.data.slice(extraIndexListOffset, extraIndexCount * 20).fetch(function(eil) {\n                if (!eil) {\n                    return callback(null, \"Couldn't fetch index info\");\n                }\n\n                var ba = new Uint8Array(eil);\n                var sa = new Int16Array(eil);\n                var la = new Int32Array(eil);\n\n                var indices = [];\n                for (var ii = 0; ii < extraIndexCount; ++ii) {\n                    var eiType = sa[ii*10];\n                    var eiFieldCount = sa[ii*10 + 1];\n                    var eiOffset = bwg_readOffset(ba, ii*20 + 4);\n                    var eiField = sa[ii*10 + 8]\n                    var index = new BBIExtraIndex(thisB, eiType, eiFieldCount, eiOffset, eiField);\n                    indices.push(index);\n                }\n                callback(indices);\n            });\n        });\n    }\n}\n\nfunction BBIExtraIndex(bbi, type, fieldCount, offset, field) {\n    this.bbi = bbi;\n    this.type = type;\n    this.fieldCount = fieldCount;\n    this.offset = offset;\n    this.field = field;\n}\n\nBBIExtraIndex.prototype.lookup = function(name, callback) {\n    var thisB = this;\n\n    this.bbi.data.slice(this.offset, 32).fetch(function(bpt) {\n        var ba = new Uint8Array(bpt);\n        var sa = new Int16Array(bpt);\n        var la = new Int32Array(bpt);\n        var bptMagic = la[0];\n        var blockSize = la[1];\n        var keySize = la[2];\n        var valSize = la[3];\n        var itemCount = bwg_readOffset(ba, 16);\n        var rootNodeOffset = 32;\n\n        function bptReadNode(nodeOffset) {\n            thisB.bbi.data.slice(nodeOffset, 4 + (blockSize * (keySize + valSize))).fetch(function(node) {\n                var ba = new Uint8Array(node);\n                var sa = new Uint16Array(node);\n                var la = new Uint32Array(node);\n\n                var nodeType = ba[0];\n                var cnt = sa[1];\n\n                var offset = 4;\n                if (nodeType == 0) {\n                    var lastChildOffset = null;\n                    for (var n = 0; n < cnt; ++n) {\n                        var key = '';\n                        for (var ki = 0; ki < keySize; ++ki) {\n                            var charCode = ba[offset++];\n                            if (charCode != 0) {\n                                key += String.fromCharCode(charCode);\n                            }\n                        }\n\n                        var childOffset = bwg_readOffset(ba, offset);\n                        offset += 8;\n                        \n                        if (name.localeCompare(key) < 0 && lastChildOffset) {\n                            bptReadNode(lastChildOffset);\n                            return;\n                        }\n                        lastChildOffset = childOffset;\n                    }\n                    bptReadNode(lastChildOffset);\n                } else {\n                    for (var n = 0; n < cnt; ++n) {\n                        var key = '';\n                        for (var ki = 0; ki < keySize; ++ki) {\n                            var charCode = ba[offset++];\n                            if (charCode != 0) {\n                                key += String.fromCharCode(charCode);\n                            }\n                        }\n                        \n                        // Specific for EI case.\n                        if (key == name) {\n                            var start = bwg_readOffset(ba, offset);\n                            var length = readInt(ba, offset + 8);\n\n                            return thisB.bbi.getUnzoomedView().fetchFeatures(\n                                function(chr, min, max, toks) {\n                                    if (toks && toks.length > thisB.field - 3)\n                                        return toks[thisB.field - 3] == name;\n                                }, \n                                [{offset: start, size: length}], \n                                callback);\n                        }\n                        offset += valSize;\n                    }\n                    return callback([]);\n                }\n            });\n        }\n\n        bptReadNode(thisB.offset + rootNodeOffset);\n    });\n}\n\nif (typeof(module) !== 'undefined') {\n    module.exports = {\n        makeBwg: makeBwg,\n        BIG_BED_MAGIC: BIG_BED_MAGIC,\n        BIG_WIG_MAGIC: BIG_WIG_MAGIC\n    }\n}\n","/* -*- mode: javascript; c-basic-offset: 4; indent-tabs-mode: nil -*- */\n\n// \n// Dalliance Genome Explorer\n// (c) Thomas Down 2006-2011\n//\n// bin.js general binary data support\n//\n\n\"use strict\";\n\nif (typeof(require) !== 'undefined') {\n    var utils = require('./utils');\n    var shallowCopy = utils.shallowCopy;\n\n    var sha1 = require('./sha1');\n    var b64_sha1 = sha1.b64_sha1;\n\n    var Promise = require('es6-promise').Promise;\n}\n\nfunction BlobFetchable(b) {\n    this.blob = b;\n}\n\nBlobFetchable.prototype.slice = function(start, length) {\n    var b;\n\n    if (this.blob.slice) {\n        if (length) {\n            b = this.blob.slice(start, start + length);\n        } else {\n            b = this.blob.slice(start);\n        }\n    } else {\n        if (length) {\n            b = this.blob.webkitSlice(start, start + length);\n        } else {\n            b = this.blob.webkitSlice(start);\n        }\n    }\n    return new BlobFetchable(b);\n}\n\nBlobFetchable.prototype.salted = function() {return this;}\n\nif (typeof(FileReader) !== 'undefined') {\n    // console.log('defining async BlobFetchable.fetch');\n\n    BlobFetchable.prototype.fetch = function(callback) {\n        var reader = new FileReader();\n        reader.onloadend = function(ev) {\n            callback(bstringToBuffer(reader.result));\n        };\n        reader.readAsBinaryString(this.blob);\n    }\n\n} else {\n    // if (console && console.log)\n    //    console.log('defining sync BlobFetchable.fetch');\n\n    BlobFetchable.prototype.fetch = function(callback) {\n        var reader = new FileReaderSync();\n        try {\n            var res = reader.readAsArrayBuffer(this.blob);\n            callback(res);\n        } catch (e) {\n            callback(null, e);\n        }\n    }\n}\n\nfunction URLFetchable(url, start, end, opts) {\n    if (!opts) {\n        if (typeof start === 'object') {\n            opts = start;\n            start = undefined;\n        } else {\n            opts = {};\n        }\n    }\n\n    this.url = url;\n    this.start = start || 0;\n    if (end) {\n        this.end = end;\n    }\n    this.opts = opts;\n}\n\nURLFetchable.prototype.slice = function(s, l) {\n    if (s < 0) {\n        throw 'Bad slice ' + s;\n    }\n\n    var ns = this.start, ne = this.end;\n    if (ns && s) {\n        ns = ns + s;\n    } else {\n        ns = s || ns;\n    }\n    if (l && ns) {\n        ne = ns + l - 1;\n    } else {\n        ne = ne || l - 1;\n    }\n    return new URLFetchable(this.url, ns, ne, this.opts);\n}\n\nvar seed=0;\nvar isSafari = typeof(navigator) !== 'undefined' &&\n    navigator.userAgent.indexOf('Safari') >= 0 &&\n    navigator.userAgent.indexOf('Chrome') < 0 ;\n\nURLFetchable.prototype.fetchAsText = function(callback) {\n    var thisB = this;\n\n    this.getURL().then(function(url) {\n        try {\n            var req = new XMLHttpRequest();\n            var length;\n            if ((isSafari || thisB.opts.salt) && url.indexOf('?') < 0) {\n                url = url + '?salt=' + b64_sha1('' + Date.now() + ',' + (++seed));\n            }\n            req.open('GET', url, true);\n            \n            if (thisB.end) {\n                if (thisB.end - thisB.start > 100000000) {\n                    throw 'Monster fetch!';\n                }\n                req.setRequestHeader('Range', 'bytes=' + thisB.start + '-' + thisB.end);\n                length = thisB.end - thisB.start + 1;\n            }\n\n            req.onreadystatechange = function() {\n                if (req.readyState == 4) {\n                    if (req.status == 200 || req.status == 206) {\n                        return callback(req.responseText);\n                    } else {\n                        return callback(null);\n                    }\n                }\n            };\n            if (thisB.opts.credentials) {\n                req.withCredentials = true;\n            }\n            req.send();\n        } catch (e) {\n            return callback(null);\n        }\n    }).catch(function(err) {\n        console.log(err);\n        return callback(null, err);\n    });\n}\n\nURLFetchable.prototype.salted = function() {\n    var o = shallowCopy(this.opts);\n    o.salt = true;\n    return new URLFetchable(this.url, this.start, this.end, o);\n}\n\nURLFetchable.prototype.getURL = function() {\n    if (this.opts.resolver) {\n        return this.opts.resolver(this.url).then(function (urlOrObj) {\n            if (typeof urlOrObj === 'string') {\n                return urlOrObj;\n            } else {\n                return urlOrObj.url;\n            }\n        });\n    } else {\n        return Promise.resolve(this.url);\n    }\n}\n\nURLFetchable.prototype.fetch = function(callback, opts) {\n    var thisB = this;\n \n    opts = opts || {};\n    var attempt = opts.attempt || 1;\n    var truncatedLength = opts.truncatedLength;\n    if (attempt > 3) {\n        return callback(null);\n    }\n\n    this.getURL().then(function(url) {\n        try {\n            var timeout;\n            if (opts.timeout && !thisB.opts.credentials) {\n                timeout = setTimeout(\n                    function() {\n                        console.log('timing out ' + url);\n                        req.abort();\n                        return callback(null, 'Timeout');\n                    },\n                    opts.timeout\n                );\n            }\n            \n            var req = new XMLHttpRequest();\n            var length;\n            if ((isSafari || thisB.opts.salt) && url.indexOf('?') < 0) {\n                url = url + '?salt=' + b64_sha1('' + Date.now() + ',' + (++seed));\n            }\n            req.open('GET', url, true);\n            req.overrideMimeType('text/plain; charset=x-user-defined');\n            if (thisB.end) {\n                if (thisB.end - thisB.start > 100000000) {\n                    throw 'Monster fetch!';\n                }\n                req.setRequestHeader('Range', 'bytes=' + thisB.start + '-' + thisB.end);\n                length = thisB.end - thisB.start + 1;\n            }\n            req.responseType = 'arraybuffer';\n            req.onreadystatechange = function() {\n                if (req.readyState == 4) {\n                    if (timeout)\n                        clearTimeout(timeout);\n                    if (req.status == 200 || req.status == 206) {\n                        if (req.response) {\n                            var bl = req.response.byteLength;\n                            if (length && length != bl && (!truncatedLength || bl != truncatedLength)) {\n                                return thisB.fetch(callback, {attempt: attempt + 1, truncatedLength: bl});\n                            } else {\n                                return callback(req.response);\n                            }\n                        } else if (req.mozResponseArrayBuffer) {\n                            return callback(req.mozResponseArrayBuffer);\n                        } else {\n                            var r = req.responseText;\n                            if (length && length != r.length && (!truncatedLength || r.length != truncatedLength)) {\n                                return thisB.fetch(callback, {attempt: attempt + 1, truncatedLength: r.length});\n                            } else {\n                                return callback(bstringToBuffer(req.responseText));\n                            }\n                        }\n                    } else {\n                        return thisB.fetch(callback, {attempt: attempt + 1});\n                    }\n                }\n            };\n            if (thisB.opts.credentials) {\n                req.withCredentials = true;\n            }\n            req.send();\n        } catch (e) {\n            return callback(null);\n        }\n    }).catch(function(err) {\n        console.log(err);\n        return callback(null, err);\n    });\n}\n                       \nfunction bstringToBuffer(result) {\n    if (!result) {\n        return null;\n    }\n\n    var ba = new Uint8Array(result.length);\n    for (var i = 0; i < ba.length; ++i) {\n        ba[i] = result.charCodeAt(i);\n    }\n    return ba.buffer;\n}\n\n// Read from Uint8Array\n\nvar convertBuffer = new ArrayBuffer(8);\nvar ba = new Uint8Array(convertBuffer);\nvar fa = new Float32Array(convertBuffer);\n\nfunction readFloat(buf, offset) {\n    ba[0] = buf[offset];\n    ba[1] = buf[offset+1];\n    ba[2] = buf[offset+2];\n        ba[3] = buf[offset+3];\n    return fa[0];\n}\n\nfunction readInt64(ba, offset) {\n    return (ba[offset + 7] << 24) | (ba[offset + 6] << 16) | (ba[offset + 5] << 8) | (ba[offset + 4]);\n}\n\nfunction readInt(ba, offset) {\n    return (ba[offset + 3] << 24) | (ba[offset + 2] << 16) | (ba[offset + 1] << 8) | (ba[offset]);\n}\n\nfunction readShort(ba, offset) {\n    return (ba[offset + 1] << 8) | (ba[offset]);\n}\n\nfunction readByte(ba, offset) {\n    return ba[offset];\n}\n\nfunction readIntBE(ba, offset) {\n    return (ba[offset] << 24) | (ba[offset + 1] << 16) | (ba[offset + 2] << 8) | (ba[offset + 3]);\n}\n\n// Exports if we are being used as a module\n\nif (typeof(module) !== 'undefined') {\n    module.exports = {\n        BlobFetchable: BlobFetchable,\n        URLFetchable: URLFetchable,\n\n        readInt: readInt,\n        readIntBE: readIntBE,\n        readInt64: readInt64,\n        readShort: readShort,\n        readByte: readByte,\n        readFloat: readFloat\n    }\n}\n","/* -*- mode: javascript; c-basic-offset: 4; indent-tabs-mode: nil -*- */\n\n// \n// Dalliance Genome Explorer\n// (c) Thomas Down 2006-2010\n//\n// color.js\n//\n\n\"use strict\";\n\nfunction DColour(red, green, blue, name) {\n    this.red = red|0;\n    this.green = green|0;\n    this.blue = blue|0;\n    if (name) {\n        this.name = name;\n    }\n}\n\nDColour.prototype.toSvgString = function() {\n    if (!this.name) {\n        this.name = \"rgb(\" + this.red + \",\" + this.green + \",\" + this.blue + \")\";\n    }\n\n    return this.name;\n}\n\nfunction hex2(x) {\n    var y = '00' + x.toString(16);\n    return y.substring(y.length - 2);\n}\n\nDColour.prototype.toHexString = function() {\n    return '#' + hex2(this.red) + hex2(this.green) + hex2(this.blue);\n}\n\nvar palette = {\n    red: new DColour(255, 0, 0, 'red'),\n    green: new DColour(0, 255, 0, 'green'),\n    blue: new DColour(0, 0, 255, 'blue'),\n    yellow: new DColour(255, 255, 0, 'yellow'),\n    white: new DColour(255, 255, 255, 'white'),\n    black: new DColour(0, 0, 0, 'black'),\n    gray: new DColour(180, 180, 180, 'gray'),\n    grey: new DColour(180, 180, 180, 'grey'),\n    lightskyblue: new DColour(135, 206, 250, 'lightskyblue'),\n    lightsalmon: new DColour(255, 160, 122, 'lightsalmon'),\n    hotpink: new DColour(255, 105, 180, 'hotpink')\n};\n\nvar COLOR_RE = new RegExp('^#([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})$');\nvar CSS_COLOR_RE = /rgb\\(([0-9]+),([0-9]+),([0-9]+)\\)/\n\nfunction dasColourForName(name) {\n    var c = palette[name];\n    if (!c) {\n        var match = COLOR_RE.exec(name);\n        if (match) {\n            c = new DColour(('0x' + match[1])|0, ('0x' + match[2])|0, ('0x' + match[3])|0, name);\n            palette[name] = c;\n        } else {\n    \t    match = CSS_COLOR_RE.exec(name);\n    \t    if (match) {\n        \t\tc = new DColour(match[1]|0, match[2]|0, match[3]|0, name);\n        \t\tpalette[name] = c;\n\t       } else {\n\t\t      console.log(\"couldn't handle color: \" + name);\n\t\t      c = palette.black;\n\t\t      palette[name] = c;\n\t       }\n        }\n    }\n    return c;\n}\n\nfunction makeColourSteps(steps, stops, colours) {\n    var dcolours = [];\n    for (var ci = 0; ci < colours.length; ++ci) {\n        dcolours.push(dasColourForName(colours[ci]));\n    }\n\n    var grad = [];\n  STEP_LOOP:\n    for (var si = 0; si < steps; ++si) {\n        var rs = (1.0 * si) / (steps-1);\n        var score = stops[0] + (stops[stops.length -1] - stops[0]) * rs;\n        for (var i = 0; i < stops.length - 1; ++i) {\n            if (score >= stops[i] && score <= stops[i+1]) {\n                var frac = (score - stops[i]) / (stops[i+1] - stops[i]);\n                var ca = dcolours[i];\n                var cb = dcolours[i+1];\n\n                var fill = new DColour(\n                    ((ca.red * (1.0 - frac)) + (cb.red * frac))|0,\n                    ((ca.green * (1.0 - frac)) + (cb.green * frac))|0,\n                    ((ca.blue * (1.0 - frac)) + (cb.blue * frac))|0\n                ).toSvgString();\n                grad.push(fill);\n\n                continue STEP_LOOP;\n            }\n        }\n        throw 'Bad step';\n    }\n\n    return grad;\n}\n\nfunction makeGradient(steps, color1, color2, color3) {\n    if (color3) {\n        return makeColourSteps(steps, [0, 0.5, 1], [color1, color2, color3]);\n    } else {\n        return makeColourSteps(steps, [0, 1], [color1, color2]);\n    }\n}\n\nif (typeof(module) !== 'undefined') {\n    module.exports = {\n        makeColourSteps: makeColourSteps,\n        makeGradient: makeGradient,\n        dasColourForName: dasColourForName\n    };\n}\n","/* -*- mode: javascript; c-basic-offset: 4; indent-tabs-mode: nil -*- */\n\n// \n// Dalliance Genome Explorer\n// (c) Thomas Down 2006-2011\n//\n// cram.js: indexed binary alignments\n//\n\n\"use strict\";\n\nif (typeof(require) !== 'undefined') {\n    var spans = require('./spans');\n    var Range = spans.Range;\n    var union = spans.union;\n    var intersection = spans.intersection;\n\n    var bin = require('./bin');\n    var readInt = bin.readInt;\n    var readShort = bin.readShort;\n    var readByte = bin.readByte;\n    var readInt64 = bin.readInt64;\n    var readFloat = bin.readFloat;\n\n    var lh3utils = require('./lh3utils');\n    var readVob = lh3utils.readVob;\n    var unbgzf = lh3utils.unbgzf;\n    var reg2bins = lh3utils.reg2bins;\n    var Chunk = lh3utils.Chunk;\n\n    var jszlib = require('jszlib');\n}\n\n\nvar CRAM_MAGIC = 0x14d4142;\nvar CRAI_MAGIC = 0x88B1F;\n\nvar CramFlags = {\n    MULTIPLE_SEGMENTS:       0x1,\n    ALL_SEGMENTS_ALIGN:      0x2,\n    SEGMENT_UNMAPPED:        0x4,\n    NEXT_SEGMENT_UNMAPPED:   0x8,\n    REVERSE_COMPLEMENT:      0x10,\n    NEXT_REVERSE_COMPLEMENT: 0x20,\n    FIRST_SEGMENT:           0x40,\n    LAST_SEGMENT:            0x80,\n    SECONDARY_ALIGNMENT:     0x100,\n    QC_FAIL:                 0x200,\n    DUPLICATE:               0x400,\n    SUPPLEMENTARY:           0x800\n};\n\nfunction CramFile() {\n}\n\n\n// Calculate the length (in bytes) of the CRAI ref starting at offset.\n// Returns {nbin, length, minBlockIndex}\nfunction _getCraiRefLength(uncba, offset) {\n    var p = offset;\n    var nbin = readInt(uncba, p); p += 4;\n    for (var b = 0; b < nbin; ++b) {\n        var bin = readInt(uncba, p);\n        var nchnk = readInt(uncba, p+4);\n        p += 8 + (nchnk * 16);\n    }\n    var nintv = readInt(uncba, p); p += 4;\n\n    var minBlockIndex = 1000000000;\n    var q = p;\n    for (var i = 0; i < nintv; ++i) {\n        var v = readVob(uncba, q); q += 8;\n        if (v) {\n            var bi = v.block;\n            if (v.offset > 0)\n                bi += 65536;\n\n            if (bi < minBlockIndex)\n                minBlockIndex = bi;\n            break;\n        }\n    }\n    p += (nintv * 8);\n\n    return {\n        minBlockIndex: minBlockIndex,\n        nbin: nbin,\n        length: p - offset\n    };\n}\n\n\nfunction makeCram(data, crai, indexChunks, callback, attempted) {\n    // Do an initial probe on the CRAM file to catch any mixed-content errors.\n    data.slice(0, 10).fetch(function(header) {\n        if (header) {\n            return makeCram2(data, crai, indexChunks, callback, attempted);\n        } else {\n            return callback(null, \"Couldn't access CRAM.\");\n        }\n    }, {timeout: 5000});\n}\n\nfunction makeCram2(data, crai, indexChunks, callback, attempted) {\n    var cram = new CramFile();\n    cram.data = data;\n    cram.crai = crai;\n    cram.indexChunks = indexChunks;\n\n    var minBlockIndex = cram.indexChunks ? cram.indexChunks.minBlockIndex : 1000000000;\n\n    // Fills out cram.chrToIndex and cram.indexToChr based on the first few bytes of the CRAM.\n    function parseCramHeader(r) {\n        if (!r) {\n            return callback(null, \"Couldn't access CRAM\");\n        }\n\n        var unc = unbgzf(r, r.byteLength);\n        var uncba = new Uint8Array(unc);\n\n        var magic = readInt(uncba, 0);\n        if (magic != CRAM_MAGIC) {\n            return callback(null, \"Not a CRAM file, magic=0x\" + magic.toString(16));\n        }\n        var headLen = readInt(uncba, 4);\n        var header = '';\n        for (var i = 0; i < headLen; ++i) {\n            header += String.fromCharCode(uncba[i + 8]);\n        }\n\n        var nRef = readInt(uncba, headLen + 8);\n        var p = headLen + 12;\n\n        cram.chrToIndex = {};\n        cram.indexToChr = [];\n        for (var i = 0; i < nRef; ++i) {\n            var lName = readInt(uncba, p);\n            var name = '';\n            for (var j = 0; j < lName-1; ++j) {\n                name += String.fromCharCode(uncba[p + 4 + j]);\n            }\n            var lRef = readInt(uncba, p + lName + 4);\n            cram.chrToIndex[name] = i;\n            if (name.indexOf('chr') == 0) {\n                cram.chrToIndex[name.substring(3)] = i;\n            } else {\n                cram.chrToIndex['chr' + name] = i;\n            }\n            cram.indexToChr.push(name);\n\n            p = p + 8 + lName;\n        }\n\n        if (cram.indices) {\n            return callback(cram);\n        }\n    }\n\n    function parseCrai(header) {\n        if (!header) {\n            return \"Couldn't access CRAI\";\n        }\n\n        var uncba = new Uint8Array(header);\n\n        var craiMagic = readInt(uncba, 0);\n        if (craiMagic != CRAI_MAGIC) {\n            return callback(null, 'Not a CRAI file, magic=0x' + craiMagic.toString(16));\n        }\n\n        var offset = 10;\n        var unc = jszlib.inflateBuffer(header,offset,header.byteLength - offset);\n        var s = ''\n        var resultBB = new Uint8Array(unc);\n        for (var i = 0; i < resultBB.length; ++i) {\n          s += String.fromCharCode(resultBB[i]);\n        }\n        console.log(s);\n\n        cram.indices = [];\n\n        var p = 8;\n        for (var ref = 0; ref < nref; ++ref) {\n            var blockStart = p;\n            var o = _getCraiRefLength(uncba, blockStart);\n            p += o.length;\n\n            minBlockIndex = Math.min(o.minBlockIndex, minBlockIndex);\n\n            var nbin = o.nbin;\n\n            if (nbin > 0) {\n                cram.indices[ref] = new Uint8Array(header, blockStart, p - blockStart);\n            }\n        }\n\n        return true;\n    }\n\n    if (!cram.indexChunks) {\n        cram.crai.fetch(function(header) {   // Do we really need to fetch the whole thing? :-(\n            var result = parseCrai(header);\n            if (result !== true) {\n                if (cram.crai.url && typeof(attempted) === \"undefined\") {\n                    // Already attempted x.cram.crai not there so now trying x.crai\n                    cram.crai.url = cram.data.url.replace(new RegExp('.cram$'), '.crai');\n                    \n                     // True lets us know we are making a second attempt\n                    makeCram2(data, cram.crai, indexChunks, callback, true);\n                }\n                else {\n                    // We've attempted x.cram.crai & x.crai and nothing worked\n                    callback(null, result);\n                }\n            } else {\n              cram.data.slice(0, minBlockIndex).fetch(parseCramHeader);\n            }\n        });   // Timeout on first request to catch Chrome mixed-content error.\n    } else {\n        var chunks = cram.indexChunks.chunks;\n        cram.indices = []\n        for (var i = 0; i < chunks.length; i++) {\n           cram.indices[i] = null;  // To be filled out lazily as needed\n        }\n        cram.data.slice(0, minBlockIndex).fetch(parseCramHeader);\n    }\n}\n\n\n\nCramFile.prototype.blocksForRange = function(refId, min, max) {\n    var index = this.indices[refId];\n    if (!index) {\n        return [];\n    }\n\n    var intBinsL = reg2bins(min, max);\n    var intBins = [];\n    for (var i = 0; i < intBinsL.length; ++i) {\n        intBins[intBinsL[i]] = true;\n    }\n    var leafChunks = [], otherChunks = [];\n\n    var nbin = readInt(index, 0);\n    var p = 4;\n    for (var b = 0; b < nbin; ++b) {\n        var bin = readInt(index, p);\n        var nchnk = readInt(index, p+4);\n//        dlog('bin=' + bin + '; nchnk=' + nchnk);\n        p += 8;\n        if (intBins[bin]) {\n            for (var c = 0; c < nchnk; ++c) {\n                var cs = readVob(index, p);\n                var ce = readVob(index, p + 8);\n                (bin < 4681 ? otherChunks : leafChunks).push(new Chunk(cs, ce));\n                p += 16;\n            }\n        } else {\n            p +=  (nchnk * 16);\n        }\n    }\n    // console.log('leafChunks = ' + JSON.stringify(leafChunks));\n    // console.log('otherChunks = ' + JSON.stringify(otherChunks));\n\n    var nintv = readInt(index, p);\n    // console.log('nintv=' + nintv);\n    var lowest = null;\n    var minLin = Math.min(min>>14, nintv - 1), maxLin = Math.min(max>>14, nintv - 1);\n    for (var i = minLin; i <= maxLin; ++i) {\n        var lb =  readVob(index, p + 4 + (i * 8));\n        if (!lb) {\n            continue;\n        }\n        if (!lowest || lb.block < lowest.block || (lb.block == lowest.block && lb.offset < lowest.offset)) {\n            lowest = lb;\n        }\n    }\n    // console.log('Lowest LB = ' + lowest);\n\n    var prunedOtherChunks = [];\n    if (lowest != null) {\n        for (var i = 0; i < otherChunks.length; ++i) {\n            var chnk = otherChunks[i];\n            if (chnk.maxv.block > lowest.block || (chnk.maxv.block == lowest.block && chnk.maxv.offset >= lowest.offset)) {\n                prunedOtherChunks.push(chnk);\n            }\n        }\n    }\n    // console.log('prunedOtherChunks = ' + JSON.stringify(prunedOtherChunks));\n    otherChunks = prunedOtherChunks;\n\n    var intChunks = [];\n    for (var i = 0; i < otherChunks.length; ++i) {\n        intChunks.push(otherChunks[i]);\n    }\n    for (var i = 0; i < leafChunks.length; ++i) {\n        intChunks.push(leafChunks[i]);\n    }\n\n    intChunks.sort(function(c0, c1) {\n        var dif = c0.minv.block - c1.minv.block;\n        if (dif != 0) {\n            return dif;\n        } else {\n            return c0.minv.offset - c1.minv.offset;\n        }\n    });\n    var mergedChunks = [];\n    if (intChunks.length > 0) {\n        var cur = intChunks[0];\n        for (var i = 1; i < intChunks.length; ++i) {\n            var nc = intChunks[i];\n            if (nc.minv.block == cur.maxv.block /* && nc.minv.offset == cur.maxv.offset */) { // no point splitting mid-block\n                cur = new Chunk(cur.minv, nc.maxv);\n            } else {\n                mergedChunks.push(cur);\n                cur = nc;\n            }\n        }\n        mergedChunks.push(cur);\n    }\n    // console.log('mergedChunks = ' + JSON.stringify(mergedChunks));\n\n    return mergedChunks;\n}\n\nCramFile.prototype.fetch = function(chr, min, max, callback, opts) {\n    var thisB = this;\n    opts = opts || {};\n\n    var chrId = this.chrToIndex[chr];\n    var chunks;\n    if (chrId === undefined) {\n        chunks = [];\n    } else {\n        // Fetch this portion of the CRAI if it hasn't been loaded yet.\n        if (this.indices[chrId] === null && this.indexChunks.chunks[chrId]) {\n            var start_stop = this.indexChunks.chunks[chrId];\n            return this.crai.slice(start_stop[0], start_stop[1]).fetch(function(data) {\n                var buffer = new Uint8Array(data);\n                this.indices[chrId] = buffer;\n                return this.fetch(chr, min, max, callback, opts);\n            }.bind(this));\n        }\n\n        chunks = this.blocksForRange(chrId, min, max);\n        if (!chunks) {\n            callback(null, 'Error in index fetch');\n        }\n    }\n    \n    var records = [];\n    var index = 0;\n    var data;\n\n    function tramp() {\n        if (index >= chunks.length) {\n            return callback(records);\n        } else if (!data) {\n            var c = chunks[index];\n            var fetchMin = c.minv.block;\n            var fetchMax = c.maxv.block + (1<<16); // *sigh*\n            // console.log('fetching ' + fetchMin + ':' + fetchMax);\n            thisB.data.slice(fetchMin, fetchMax - fetchMin).fetch(function(r) {\n                data = unbgzf(r, c.maxv.block - c.minv.block + 1);\n                return tramp();\n            });\n        } else {\n            var ba = new Uint8Array(data);\n            var finished = thisB.readCramRecords(ba, chunks[index].minv.offset, records, min, max, chrId, opts);\n            data = null;\n            ++index;\n            if (finished)\n                return callback(records);\n            else\n                return tramp();\n        }\n    }\n    tramp();\n}\n\nvar SEQRET_DECODER = ['=', 'A', 'C', 'x', 'G', 'x', 'x', 'x', 'T', 'x', 'x', 'x', 'x', 'x', 'x', 'N'];\nvar CIGAR_DECODER = ['M', 'I', 'D', 'N', 'S', 'H', 'P', '=', 'X', '?', '?', '?', '?', '?', '?', '?'];\n\nfunction CramRecord() {\n}\n\nCramFile.prototype.readCramRecords = function(ba, offset, sink, min, max, chrId, opts) {\n    while (true) {\n        var blockSize = readInt(ba, offset);\n        var blockEnd = offset + blockSize + 4;\n        if (blockEnd > ba.length) {\n            return false;\n        }\n\n        var record = new CramRecord();\n\n        var refID = readInt(ba, offset + 4);\n        var pos = readInt(ba, offset + 8);\n        \n        var bmn = readInt(ba, offset + 12);\n        var bin = (bmn & 0xffff0000) >> 16;\n        var mq = (bmn & 0xff00) >> 8;\n        var nl = bmn & 0xff;\n\n        var flag_nc = readInt(ba, offset + 16);\n        var flag = (flag_nc & 0xffff0000) >> 16;\n        var nc = flag_nc & 0xffff;\n    \n        var lseq = readInt(ba, offset + 20);\n        \n        var nextRef  = readInt(ba, offset + 24);\n        var nextPos = readInt(ba, offset + 28);\n        \n        var tlen = readInt(ba, offset + 32);\n    \n        record.segment = this.indexToChr[refID];\n        record.flag = flag;\n        record.pos = pos;\n        record.mq = mq;\n        if (opts.light)\n            record.seqLength = lseq;\n\n        if (!opts.light || opts.includeName) {\n            var readName = '';\n            for (var j = 0; j < nl-1; ++j) {\n                readName += String.fromCharCode(ba[offset + 36 + j]);\n            }\n            record.readName = readName;\n        }\n        \n        if (!opts.light) {\n            if (nextRef >= 0) {\n                record.nextSegment = this.indexToChr[nextRef];\n                record.nextPos = nextPos;\n            }\n        \n            var p = offset + 36 + nl;\n\n            var cigar = '';\n            for (var c = 0; c < nc; ++c) {\n                var cigop = readInt(ba, p);\n                cigar = cigar + (cigop>>4) + CIGAR_DECODER[cigop & 0xf];\n                p += 4;\n            }\n            record.cigar = cigar;\n        \n            var seq = '';\n            var seqBytes = (lseq + 1) >> 1;\n            for (var j = 0; j < seqBytes; ++j) {\n                var sb = ba[p + j];\n                seq += SEQRET_DECODER[(sb & 0xf0) >> 4];\n                if (seq.length < lseq)\n                    seq += SEQRET_DECODER[(sb & 0x0f)];\n            }\n            p += seqBytes;\n            record.seq = seq;\n\n            var qseq = '';\n            for (var j = 0; j < lseq; ++j) {\n                qseq += String.fromCharCode(ba[p + j] + 33);\n            }\n            p += lseq;\n            record.quals = qseq;\n\n            while (p < blockEnd) {\n                var tag = String.fromCharCode(ba[p], ba[p + 1]);\n                var type = String.fromCharCode(ba[p + 2]);\n                var value;\n\n                if (type == 'A') {\n                    value = String.fromCharCode(ba[p + 3]);\n                    p += 4;\n                } else if (type == 'i' || type == 'I') {\n                    value = readInt(ba, p + 3);\n                    p += 7;\n                } else if (type == 'c' || type == 'C') {\n                    value = ba[p + 3];\n                    p += 4;\n                } else if (type == 's' || type == 'S') {\n                    value = readShort(ba, p + 3);\n                    p += 5;\n                } else if (type == 'f') {\n                    value = readFloat(ba, p + 3);\n                    p += 7;\n                } else if (type == 'Z' || type == 'H') {\n                    p += 3;\n                    value = '';\n                    for (;;) {\n                        var cc = ba[p++];\n                        if (cc == 0) {\n                            break;\n                        } else {\n                            value += String.fromCharCode(cc);\n                        }\n                    }\n                } else if (type == 'B') {\n                    var atype = String.fromCharCode(ba[p + 3]);\n                    var alen = readInt(ba, p + 4);\n                    var elen;\n                    var reader;\n                    if (atype == 'i' || atype == 'I' || atype == 'f') {\n                        elen = 4;\n                        if (atype == 'f')\n                            reader = readFloat;\n                        else\n                            reader = readInt;\n                    } else if (atype == 's' || atype == 'S') {\n                        elen = 2;\n                        reader = readShort;\n                    } else if (atype == 'c' || atype == 'C') {\n                        elen = 1;\n                        reader = readByte;\n                    } else {\n                        throw 'Unknown array type ' + atype;\n                    }\n\n                    p += 8;\n                    value = [];\n                    for (var i = 0; i < alen; ++i) {\n                        value.push(reader(ba, p));\n                        p += elen;\n                    }\n                } else {\n                    throw 'Unknown type '+ type;\n                }\n                record[tag] = value;\n            }\n        }\n\n        if (!min || record.pos <= max && record.pos + lseq >= min) {\n            if (chrId === undefined || refID == chrId) {\n                sink.push(record);\n            }\n        }\n        if (record.pos > max) {\n            return true;\n        }\n        offset = blockEnd;\n    }\n\n    // Exits via top of loop.\n};\n\nif (typeof(module) !== 'undefined') {\n    module.exports = {\n        makeCram: makeCram,\n        CRAM_MAGIC: CRAM_MAGIC,\n        CRAI_MAGIC: CRAI_MAGIC,\n        CramFlags: CramFlags\n    };\n}\n","/* -*- mode: javascript; c-basic-offset: 4; indent-tabs-mode: nil -*- */\n\n// \n// Dalliance Genome Explorer\n// (c) Thomas Down 2006-2010\n//\n// das.js: queries and low-level data model.\n//\n\n\"use strict\";\n\nif (typeof(require) !== 'undefined') {\n    var utils = require('./utils');\n    var shallowCopy = utils.shallowCopy;\n    var pusho = utils.pusho;\n\n    var color = require('./color');\n    var makeColourSteps = color.makeColourSteps;\n}\n\nvar dasLibErrorHandler = function(errMsg) {\n    alert(errMsg);\n}\nvar dasLibRequestQueue = new Array();\n\nfunction DASSegment(name, start, end, description) {\n    this.name = name;\n    this.start = start;\n    this.end = end;\n    this.description = description;\n}\nDASSegment.prototype.toString = function() {\n    return this.name + ':' + this.start + '..' + this.end;\n};\nDASSegment.prototype.isBounded = function() {\n    return this.start && this.end;\n}\nDASSegment.prototype.toDASQuery = function() {\n    var q = 'segment=' + this.name;\n    if (this.start && this.end) {\n        q += (':' + this.start + ',' + this.end);\n    }\n    return q;\n}\n\n\nfunction DASSource(a1, a2) {\n    var options;\n    if (typeof a1 == 'string') {\n        this.uri = a1;\n        options = a2 || {};\n    } else {\n        options = a1 || {};\n    }\n    for (var k in options) {\n        this[k] = options[k];\n    }\n\n    if (!this.coords) {\n        this.coords = [];\n    }\n    if (!this.props) {\n        this.props = {};\n    }\n\n    this.dasBaseURI = this.uri;\n    if (this.dasBaseURI && this.dasBaseURI.substr(this.uri.length - 1) != '/') {\n        this.dasBaseURI = this.dasBaseURI + '/';\n    }\n}\n\nDASSource.prototype.getURI = function(uri) {\n    if (this.resolver) {\n        return this.resolver(uri).then(function (urlOrObj) {\n            if (typeof urlOrObj === 'string') {\n                return urlOrObj;\n            } else {\n                return urlOrObj.url;\n            }\n        });\n    } else {\n        return Promise.resolve(uri);\n    }\n}\n\nfunction DASCoords() {\n}\n\nfunction coordsMatch(c1, c2) {\n    return c1.taxon == c2.taxon && c1.auth == c2.auth && c1.version == c2.version;\n}\n\n//\n// DAS 1.6 entry_points command\n//\n\nDASSource.prototype.entryPoints = function(callback) {\n    var dasURI = this.dasBaseURI + 'entry_points';\n    this.doCrossDomainRequest(dasURI, function(responseXML) {\n            if (!responseXML) {\n                return callback([]);\n            }\n\n                var entryPoints = new Array();\n                \n                var segs = responseXML.getElementsByTagName('SEGMENT');\n                for (var i = 0; i < segs.length; ++i) {\n                    var seg = segs[i];\n                    var segId = seg.getAttribute('id');\n                    \n                    var segSize = seg.getAttribute('size');\n                    var segMin, segMax;\n                    if (segSize) {\n                        segMin = 1; segMax = segSize|0;\n                    } else {\n                        segMin = seg.getAttribute('start');\n                        if (segMin) {\n                            segMin |= 0;\n                        }\n                        segMax = seg.getAttribute('stop');\n                        if (segMax) {\n                            segMax |= 0;\n                        }\n                    }\n                    var segDesc = null;\n                    if (seg.firstChild) {\n                        segDesc = seg.firstChild.nodeValue;\n                    }\n                    entryPoints.push(new DASSegment(segId, segMin, segMax, segDesc));\n                }          \n               callback(entryPoints);\n    });         \n}\n\n//\n// DAS 1.6 sequence command\n// Do we need an option to fall back to the dna command?\n//\n\nfunction DASSequence(name, start, end, alpha, seq) {\n    this.name = name;\n    this.start = start;\n    this.end = end;\n    this.alphabet = alpha;\n    this.seq = seq;\n}\n\nDASSource.prototype.sequence = function(segment, callback) {\n    var dasURI = this.dasBaseURI + 'sequence?' + segment.toDASQuery();\n    this.doCrossDomainRequest(dasURI, function(responseXML) {\n        if (!responseXML) {\n            callback([]);\n            return;\n        } else {\n                var seqs = new Array();\n                \n                var segs = responseXML.getElementsByTagName('SEQUENCE');\n                for (var i = 0; i < segs.length; ++i) {\n                    var seg = segs[i];\n                    var segId = seg.getAttribute('id');\n                    var segMin = seg.getAttribute('start');\n                    var segMax = seg.getAttribute('stop');\n                    var segAlpha = 'DNA';\n                    var segSeq = null;\n                    if (seg.firstChild) {\n                        var rawSeq = seg.firstChild.nodeValue;\n                        segSeq = '';\n                        var idx = 0;\n                        while (true) {\n                            var space = rawSeq.indexOf('\\n', idx);\n                            if (space >= 0) {\n                                segSeq += rawSeq.substring(idx, space).toUpperCase();\n                                idx = space + 1;\n                            } else {\n                                segSeq += rawSeq.substring(idx).toUpperCase();\n                                break;\n                            }\n                        }\n                    }\n                    seqs.push(new DASSequence(segId, segMin, segMax, segAlpha, segSeq));\n                }\n                \n                callback(seqs);\n        }\n    });\n}\n\n//\n// DAS 1.6 features command\n//\n\nfunction DASFeature() {\n}\n\nfunction DASGroup(id) {\n    if (id)\n        this.id = id;\n}\n\nfunction DASLink(desc, uri) {\n    this.desc = desc;\n    this.uri = uri;\n}\n\nDASSource.prototype.features = function(segment, options, callback) {\n    options = options || {};\n    var thisB = this;\n\n    var dasURI;\n    if (this.features_uri) {\n        dasURI = this.features_uri;\n    } else {\n        var filters = [];\n\n        if (segment) {\n            filters.push(segment.toDASQuery());\n        } else if (options.group) {\n            var g = options.group;\n            if (typeof g == 'string') {\n                filters.push('group_id=' + g);\n            } else {\n                for (var gi = 0; gi < g.length; ++gi) {\n                    filters.push('group_id=' + g[gi]);\n                }\n            }\n        }\n\n        if (options.adjacent) {\n            var adj = options.adjacent;\n            if (typeof adj == 'string') {\n                adj = [adj];\n            }\n            for (var ai = 0; ai < adj.length; ++ai) {\n                filters.push('adjacent=' + adj[ai]);\n            }\n        }\n\n        if (options.type) {\n            if (typeof options.type == 'string') {\n                filters.push('type=' + options.type);\n            } else {\n                for (var ti = 0; ti < options.type.length; ++ti) {\n                    filters.push('type=' + options.type[ti]);\n                }\n            }\n        }\n        \n        if (options.maxbins) {\n            filters.push('maxbins=' + options.maxbins);\n        }\n        \n        if (filters.length > 0) {\n            dasURI = this.dasBaseURI + 'features?' + filters.join(';');\n        } else {\n            callback([], 'No filters specified');\n        }\n    } \n   \n\n    this.doCrossDomainRequest(dasURI, function(responseXML, req) {\n        if (!responseXML) {\n            var msg;\n            if (req.status == 0) {\n                msg = 'server may not support CORS';\n            } else {\n                msg = 'status=' + req.status;\n            }\n            callback([], 'Failed request: ' + msg);\n            return;\n        }\n/*      if (req) {\n            var caps = req.getResponseHeader('X-DAS-Capabilties');\n            if (caps) {\n                alert(caps);\n            }\n        } */\n\n        var features = new Array();\n        var segmentMap = {};\n\n        var segs = responseXML.getElementsByTagName('SEGMENT');\n        for (var si = 0; si < segs.length; ++si) {\n            var segmentXML = segs[si];\n            var segmentID = segmentXML.getAttribute('id');\n            segmentMap[segmentID] = {\n                min: segmentXML.getAttribute('start'),\n                max: segmentXML.getAttribute('stop')\n            };\n            \n            var featureXMLs = segmentXML.getElementsByTagName('FEATURE');\n            for (var i = 0; i < featureXMLs.length; ++i) {\n                var feature = featureXMLs[i];\n                var dasFeature = new DASFeature();\n                \n                dasFeature.segment = segmentID;\n                dasFeature.id = feature.getAttribute('id');\n                dasFeature.label = feature.getAttribute('label');\n\n\n/*\n                var childNodes = feature.childNodes;\n                for (var c = 0; c < childNodes.length; ++c) {\n                    var cn = childNodes[c];\n                    if (cn.nodeType == Node.ELEMENT_NODE) {\n                        var key = cn.tagName;\n                        //var val = null;\n                        //if (cn.firstChild) {\n                        //   val = cn.firstChild.nodeValue;\n                        //}\n                        dasFeature[key] = 'x';\n                    }\n                } */\n\n\n                var spos = elementValue(feature, \"START\");\n                var epos = elementValue(feature, \"END\");\n                if ((spos|0) > (epos|0)) {\n                    dasFeature.min = epos|0;\n                    dasFeature.max = spos|0;\n                } else {\n                    dasFeature.min = spos|0;\n                    dasFeature.max = epos|0;\n                }\n                {\n                    var tec = feature.getElementsByTagName('TYPE');\n                    if (tec.length > 0) {\n                        var te = tec[0];\n                        if (te.firstChild) {\n                            dasFeature.type = te.firstChild.nodeValue;\n                        }\n                        dasFeature.typeId = te.getAttribute('id');\n                        dasFeature.typeCv = te.getAttribute('cvId');\n                    }\n                }\n                dasFeature.type = elementValue(feature, \"TYPE\");\n                if (!dasFeature.type && dasFeature.typeId) {\n                    dasFeature.type = dasFeature.typeId; // FIXME?\n                }\n                \n                dasFeature.method = elementValue(feature, \"METHOD\");\n                {\n                    var ori = elementValue(feature, \"ORIENTATION\");\n                    if (!ori) {\n                        ori = '0';\n                    }\n                    dasFeature.orientation = ori;\n                }\n                dasFeature.score = elementValue(feature, \"SCORE\");\n                dasFeature.links = dasLinksOf(feature);\n                dasFeature.notes = dasNotesOf(feature);\n                \n                var groups = feature.getElementsByTagName(\"GROUP\");\n                for (var gi  = 0; gi < groups.length; ++gi) {\n                    var groupXML = groups[gi];\n                    var dasGroup = new DASGroup();\n                    dasGroup.type = groupXML.getAttribute('type');\n                    dasGroup.id = groupXML.getAttribute('id');\n                    dasGroup.links = dasLinksOf(groupXML);\n                    dasGroup.notes = dasNotesOf(groupXML);\n                    if (!dasFeature.groups) {\n                        dasFeature.groups = new Array(dasGroup);\n                    } else {\n                        dasFeature.groups.push(dasGroup);\n                    }\n                }\n\n                // Magic notes.  Check with TAD before changing this.\n                if (dasFeature.notes) {\n                    for (var ni = 0; ni < dasFeature.notes.length; ++ni) {\n                        var n = dasFeature.notes[ni];\n                        if (n.indexOf('Genename=') == 0) {\n                            var gg = new DASGroup();\n                            gg.type='gene';\n                            gg.id = n.substring(9);\n                            if (!dasFeature.groups) {\n                                dasFeature.groups = new Array(gg);\n                            } else {\n                                dasFeature.groups.push(gg);\n                            }\n                        }\n                    }\n                }\n                \n                {\n                    var pec = feature.getElementsByTagName('PART');\n                    if (pec.length > 0) {\n                        var parts = [];\n                        for (var pi = 0; pi < pec.length; ++pi) {\n                            parts.push(pec[pi].getAttribute('id'));\n                        }\n                        dasFeature.parts = parts;\n                    }\n                }\n                {\n                    var pec = feature.getElementsByTagName('PARENT');\n                    if (pec.length > 0) {\n                        var parents = [];\n                        for (var pi = 0; pi < pec.length; ++pi) {\n                            parents.push(pec[pi].getAttribute('id'));\n                        }\n                        dasFeature.parents = parents;\n                    }\n                }\n                \n                features.push(dasFeature);\n            }\n        }\n                \n        callback(features, undefined, segmentMap);\n    },\n    function (err) {\n        callback([], err);\n    });\n}\n\nfunction DASAlignment(type) {\n    this.type = type;\n    this.objects = {};\n    this.blocks = [];\n}\n\nDASSource.prototype.alignments = function(segment, options, callback) {\n    var dasURI = this.dasBaseURI + 'alignment?query=' + segment;\n    this.doCrossDomainRequest(dasURI, function(responseXML) {\n        if (!responseXML) {\n            callback([], 'Failed request ' + dasURI);\n            return;\n        }\n\n        var alignments = [];\n        var aliXMLs = responseXML.getElementsByTagName('alignment');\n        for (var ai = 0; ai < aliXMLs.length; ++ai) {\n            var aliXML = aliXMLs[ai];\n            var ali = new DASAlignment(aliXML.getAttribute('alignType'));\n            var objXMLs = aliXML.getElementsByTagName('alignObject');\n            for (var oi = 0; oi < objXMLs.length; ++oi) {\n                var objXML = objXMLs[oi];\n                var obj = {\n                    id:          objXML.getAttribute('intObjectId'),\n                    accession:   objXML.getAttribute('dbAccessionId'),\n                    version:     objXML.getAttribute('objectVersion'),\n                    dbSource:    objXML.getAttribute('dbSource'),\n                    dbVersion:   objXML.getAttribute('dbVersion')\n                };\n                ali.objects[obj.id] = obj;\n            }\n            \n            var blockXMLs = aliXML.getElementsByTagName('block');\n            for (var bi = 0; bi < blockXMLs.length; ++bi) {\n                var blockXML = blockXMLs[bi];\n                var block = {\n                    order:      blockXML.getAttribute('blockOrder'),\n                    segments:   []\n                };\n                var segXMLs = blockXML.getElementsByTagName('segment');\n                for (var si = 0; si < segXMLs.length; ++si) {\n                    var segXML = segXMLs[si];\n                    var seg = {\n                        object:      segXML.getAttribute('intObjectId'),\n                        min:         segXML.getAttribute('start'),\n                        max:         segXML.getAttribute('end'),\n                        strand:      segXML.getAttribute('strand'),\n                        cigar:       elementValue(segXML, 'cigar')\n                    };\n                    block.segments.push(seg);\n                }\n                ali.blocks.push(block);\n            }       \n                    \n            alignments.push(ali);\n        }\n        callback(alignments);\n    });\n}\n\n\nfunction DASStylesheet() {\n    this.styles = [];\n}\n\nDASStylesheet.prototype.pushStyle = function(filters, zoom, style) {\n    if (!filters) {\n        filters = {type: 'default'};\n    }\n    var styleHolder = shallowCopy(filters);\n    if (zoom) {\n        styleHolder.zoom = zoom;\n    }\n    styleHolder.style = style;\n    this.styles.push(styleHolder);\n}\n\nfunction DASStyle() {\n}\n\nfunction parseGradient(grad) {\n    var steps = grad.getAttribute('steps');\n    if (steps) {\n        steps = steps|0;\n    } else {\n        steps = 50;\n    }\n\n    var stops = [];\n    var colors = [];\n    var se = grad.getElementsByTagName('STOP');\n    for (var si = 0; si < se.length; ++si) {\n        var stop = se[si];\n        stops.push(1.0 * stop.getAttribute('score'));\n        colors.push(stop.firstChild.nodeValue);\n    }\n\n    return makeColourSteps(steps, stops, colors);\n}\n\nDASSource.prototype.stylesheet = function(successCB, failureCB) {\n    var dasURI, creds = this.credentials;\n    if (this.stylesheet_uri) {\n        dasURI = this.stylesheet_uri;\n        creds = false;\n    } else {\n        dasURI = this.dasBaseURI + 'stylesheet';\n    }\n\n    this.getURI(dasURI).then(function(dasURI) {\n        doCrossDomainRequest(dasURI, function(responseXML) {\n            if (!responseXML) {\n                if (failureCB) {\n                    failureCB();\n                } \n                return;\n            }\n            var stylesheet = new DASStylesheet();\n            var typeXMLs = responseXML.getElementsByTagName('TYPE');\n            for (var i = 0; i < typeXMLs.length; ++i) {\n                var typeStyle = typeXMLs[i];\n            \n                var filter = {};\n                filter.type = typeStyle.getAttribute('id'); // Am I right in thinking that this makes DASSTYLE XML invalid?  Ugh.\n                filter.label = typeStyle.getAttribute('label');\n                filter.method = typeStyle.getAttribute('method');\n                var glyphXMLs = typeStyle.getElementsByTagName('GLYPH');\n                for (var gi = 0; gi < glyphXMLs.length; ++gi) {\n                    var glyphXML = glyphXMLs[gi];\n                    var zoom = glyphXML.getAttribute('zoom');\n                    var glyph = childElementOf(glyphXML);\n                    var style = new DASStyle();\n                    style.glyph = glyph.localName;\n                    var child = glyph.firstChild;\n                    \n                    while (child) {\n                        if (child.nodeType == Node.ELEMENT_NODE) {\n                            if (child.localName == 'BGGRAD') {\n                                style[child.localName] = parseGradient(child);\n                            } else {      \n                                style[child.localName] = child.firstChild.nodeValue;\n                            }\n                        }\n                        child = child.nextSibling;\n                    }\n                    stylesheet.pushStyle(filter, zoom, style);\n                }\n            }\n            successCB(stylesheet);\n        }, creds);\n    }).catch(function(err) {\n        console.log(err);\n        failureCB();\n    });\n}\n\n//\n// sources command\n// \n\nfunction DASRegistry(uri, opts)\n{\n    opts = opts || {};\n    this.uri = uri;\n    this.opts = opts;   \n}\n\nDASRegistry.prototype.sources = function(callback, failure, opts)\n{\n    if (!opts) {\n        opts = {};\n    }\n\n    var filters = [];\n    if (opts.taxon) {\n        filters.push('organism=' + opts.taxon);\n    }\n    if (opts.auth) {\n        filters.push('authority=' + opts.auth);\n    }\n    if (opts.version) {\n        filters.push('version=' + opts.version);\n    }\n    var quri = this.uri;\n    if (filters.length > 0) {\n        quri = quri + '?' + filters.join('&');   // '&' as a separator to hack around dasregistry.org bug.\n    }\n\n    doCrossDomainRequest(quri, function(responseXML) {\n        if (!responseXML && failure) {\n            failure();\n            return;\n        }\n\n        var sources = [];       \n        var sourceXMLs = responseXML.getElementsByTagName('SOURCE');\n        for (var si = 0; si < sourceXMLs.length; ++si) {\n            var sourceXML = sourceXMLs[si];\n            var versionXMLs = sourceXML.getElementsByTagName('VERSION');\n            if (versionXMLs.length < 1) {\n                continue;\n            }\n            var versionXML = versionXMLs[0];\n\n            var coordXMLs = versionXML.getElementsByTagName('COORDINATES');\n            var coords = [];\n            for (var ci = 0; ci < coordXMLs.length; ++ci) {\n                var coordXML = coordXMLs[ci];\n                var coord = new DASCoords();\n                coord.auth = coordXML.getAttribute('authority');\n                coord.taxon = coordXML.getAttribute('taxid');\n                coord.version = coordXML.getAttribute('version');\n                coords.push(coord);\n            }\n            \n            var caps = [];\n            var capXMLs = versionXML.getElementsByTagName('CAPABILITY');\n            var uri;\n            for (var ci = 0; ci < capXMLs.length; ++ci) {\n                var capXML = capXMLs[ci];\n                \n                caps.push(capXML.getAttribute('type'));\n\n                if (capXML.getAttribute('type') == 'das1:features') {\n                    var fep = capXML.getAttribute('query_uri');\n                    uri = fep.substring(0, fep.length - ('features'.length));\n                }\n            }\n\n            var props = {};\n            var propXMLs = versionXML.getElementsByTagName('PROP');\n            for (var pi = 0; pi < propXMLs.length; ++pi) {\n                pusho(props, propXMLs[pi].getAttribute('name'), propXMLs[pi].getAttribute('value'));\n            }\n            \n            if (uri) {\n                var source = new DASSource(uri, {\n                    source_uri: sourceXML.getAttribute('uri'),\n                    name:  sourceXML.getAttribute('title'),\n                    desc:  sourceXML.getAttribute('description'),\n                    coords: coords,\n                    props: props,\n                    capabilities: caps\n                });\n                sources.push(source);\n            }\n        }\n        \n        callback(sources);\n    });\n}\n\n\n//\n// Utility functions\n//\n\nfunction elementValue(element, tag)\n{\n    var children = element.getElementsByTagName(tag);\n    if (children.length > 0 && children[0].firstChild) {\n        var c = children[0];\n        if (c.childNodes.length == 1) {\n            return c.firstChild.nodeValue;\n        } else {\n            var s = '';\n            for (var ni = 0; ni < c.childNodes.length; ++ni) {\n                s += c.childNodes[ni].nodeValue;\n            }\n            return s;\n        }\n\n    } else {\n        return null;\n    }\n}\n\nfunction childElementOf(element)\n{\n    if (element.hasChildNodes()) {\n        var child = element.firstChild;\n        do {\n            if (child.nodeType == Node.ELEMENT_NODE) {\n                return child;\n            } \n            child = child.nextSibling;\n        } while (child != null);\n    }\n    return null;\n}\n\n\nfunction dasLinksOf(element)\n{\n    var links = new Array();\n    var maybeLinkChilden = element.getElementsByTagName('LINK');\n    for (var ci = 0; ci < maybeLinkChilden.length; ++ci) {\n        var linkXML = maybeLinkChilden[ci];\n        if (linkXML.parentNode == element) {\n            links.push(new DASLink(linkXML.firstChild ? linkXML.firstChild.nodeValue : 'Unknown', linkXML.getAttribute('href')));\n        }\n    }\n    \n    return links;\n}\n\nfunction dasNotesOf(element)\n{\n    var notes = [];\n    var maybeNotes = element.getElementsByTagName('NOTE');\n    for (var ni = 0; ni < maybeNotes.length; ++ni) {\n        if (maybeNotes[ni].firstChild) {\n            notes.push(maybeNotes[ni].firstChild.nodeValue);\n        }\n    }\n    return notes;\n}\n\nfunction doCrossDomainRequest(url, handler, credentials, custAuth) {\n    // TODO: explicit error handlers?\n\n    if (window.XDomainRequest) {\n        var req = new XDomainRequest();\n        req.onload = function() {\n            var dom = new ActiveXObject(\"Microsoft.XMLDOM\");\n            dom.async = false;\n            dom.loadXML(req.responseText);\n            handler(dom);\n        }\n        req.open(\"get\", url);\n        req.send();\n    } else {\n        try {\n            var req = new XMLHttpRequest();\n            var timeout = setTimeout(\n                function() {\n                    console.log('timing out '  + url);\n                    req.abort();\n                    handler(null, req);\n                },\n                5000\n            );\n\n            req.ontimeout = function() {\n                console.log('timeout on ' + url);\n            };\n\n            req.onreadystatechange = function() {\n                if (req.readyState == 4) {\n                    clearTimeout(timeout);\n                    if (req.status >= 200 || req.status == 0) {\n                        handler(req.responseXML, req);\n                    }\n                }\n            };\n            req.open(\"get\", url, true);\n            // IE10/11 fix: The timeout property may be set only in the time interval between a call to the open method\n            //              and the first call to the send method.\n            req.timeout = 5000;\n            if (credentials) {\n                req.withCredentials = true;\n            }\n            if (custAuth) {\n                req.setRequestHeader('X-DAS-Authorisation', custAuth);\n            }\n            req.overrideMimeType('text/xml');\n            req.setRequestHeader('Accept', 'application/xml,*/*');\n            req.send();\n        } catch (e) {\n            handler(null, req, e);\n        }\n    }\n}\n\nDASSource.prototype.doCrossDomainRequest = function(url, handler, errHandler) {\n    var custAuth;\n    if (this.xUser) {\n        custAuth = 'Basic ' + btoa(this.xUser + ':' + this.xPass);\n    }\n\n    try {\n        return doCrossDomainRequest(url, handler, this.credentials, custAuth);\n    } catch (err) {\n        if (errHandler) {\n            errHandler(err);\n        } else {\n            throw err;\n        }\n    }\n}\n\nfunction isDasBooleanTrue(s) {\n    s = ('' + s).toLowerCase();\n    return s==='yes' || s==='true';\n}\n\nfunction isDasBooleanNotFalse(s) {\n    if (!s)\n        return false;\n\n    s = ('' + s).toLowerCase();\n    return s!=='no' || s!=='false';\n}\n\nfunction copyStylesheet(ss) {\n    var nss = shallowCopy(ss);\n    nss.styles = [];\n    for (var si = 0; si < ss.styles.length; ++si) {\n        var sh = nss.styles[si] = shallowCopy(ss.styles[si]);\n        sh._methodRE = sh._labelRE = sh._typeRE = undefined;\n        sh.style = shallowCopy(sh.style);\n        sh.style.id = undefined;\n        sh.style._gradient = undefined;\n    }\n    return nss;\n}\n\nif (typeof(module) !== 'undefined') {\n    module.exports = {\n        DASGroup: DASGroup,\n        DASFeature: DASFeature,\n        DASStylesheet: DASStylesheet,\n        DASStyle: DASStyle,\n        DASSource: DASSource,\n        DASSegment: DASSegment,\n        DASRegistry: DASRegistry,\n        DASSequence: DASSequence,\n        DASLink: DASLink,\n\n        isDasBooleanTrue: isDasBooleanTrue,\n        isDasBooleanNotFalse: isDasBooleanNotFalse,\n        copyStylesheet: copyStylesheet,\n        coordsMatch: coordsMatch\n    };\n}\n","/* -*- mode: javascript; c-basic-offset: 4; indent-tabs-mode: nil -*- */\n\n// \n// Dalliance Genome Explorer\n// (c) Thomas Down 2006-2014\n//\n// encode.js: interface for ENCODE DCC services\n//\n\n\"use strict\";\n\nif (typeof(require) !== 'undefined') {\n    var Promise = require('es6-promise').Promise;\n}\n\nfunction lookupEncodeURI(uri, json) {\n    if (uri.indexOf('?') < 0)\n        uri = uri + '?soft=true';\n\n    return new Promise(function(accept, reject) {\n        var req = new XMLHttpRequest();\n        req.onreadystatechange = function() {\n            if (req.readyState == 4) {\n                if (req.status >= 300) {\n                    reject('Error code ' + req.status);\n                } else {\n                    var resp = JSON.parse(req.response);\n                    accept(json ? resp : resp.location);\n                }\n            }\n        };\n    \n        req.open('GET', uri, true);\n        req.setRequestHeader('Accept', 'application/json');\n        req.responseType = 'text';\n        req.send();\n    });\n}\n\nfunction EncodeURLHolder(url) {\n    this.rawurl = url;\n}\n\nEncodeURLHolder.prototype.getURLPromise = function() {\n    if (this.urlPromise && this.urlPromiseValidity > Date.now()) {\n        return this.urlPromise;\n    } else {\n        this.urlPromise = lookupEncodeURI(this.rawurl, true).then(function(resp) {\n            return resp.location;\n        });\n        this.urlPromiseValidity = Date.now() + (12 * 3600 * 1000);\n        return this.urlPromise;\n    }\n}\n\nfunction EncodeFetchable(url, start, end, opts) {\n    if (!opts) {\n        if (typeof start === 'object') {\n            opts = start;\n            start = undefined;\n        } else {\n            opts = {};\n        }\n    }\n\n    this.url = (typeof url === 'string' ? new EncodeURLHolder(url) : url);\n    this.start = start || 0;\n    if (end) {\n        this.end = end;\n    }\n    this.opts = opts;\n}\n\n\n\nEncodeFetchable.prototype.slice = function(s, l) {\n    if (s < 0) {\n        throw 'Bad slice ' + s;\n    }\n\n    var ns = this.start, ne = this.end;\n    if (ns && s) {\n        ns = ns + s;\n    } else {\n        ns = s || ns;\n    }\n    if (l && ns) {\n        ne = ns + l - 1;\n    } else {\n        ne = ne || l - 1;\n    }\n    return new EncodeFetchable(this.url, ns, ne, this.opts);\n}\n\nEncodeFetchable.prototype.fetchAsText = function(callback) {\n    var self = this;\n    var req = new XMLHttpRequest();\n    var length;\n    self.url.getURLPromise().then(function(url) {\n        req.open('GET', url, true);\n\n        if (self.end) {\n            if (self.end - self.start > 100000000) {\n                throw 'Monster fetch!';\n            }\n            req.setRequestHeader('Range', 'bytes=' + self.start + '-' + self.end);\n            length = self.end - self.start + 1;\n        }\n\n        req.onreadystatechange = function() {\n            if (req.readyState == 4) {\n                if (req.status == 200 || req.status == 206) {\n                    return callback(req.responseText);\n                } else {\n                    return callback(null);\n                }\n            }\n        };\n        if (self.opts.credentials) {\n            req.withCredentials = true;\n        }\n        req.send();\n    }).catch(function(err) {\n        console.log(err);\n        return callback(null);\n    });\n}\n\nEncodeFetchable.prototype.salted = function() {\n    return this;\n}\n\nEncodeFetchable.prototype.fetch = function(callback, attempt, truncatedLength) {\n    var self = this;\n\n    attempt = attempt || 1;\n    if (attempt > 3) {\n        return callback(null);\n    }\n\n    self.url.getURLPromise().then(function (url) {\n        var req = new XMLHttpRequest();\n        var length;\n        req.open('GET', url, true);\n        req.overrideMimeType('text/plain; charset=x-user-defined');\n        if (self.end) {\n            if (self.end - self.start > 100000000) {\n                throw 'Monster fetch!';\n            }\n            req.setRequestHeader('Range', 'bytes=' + self.start + '-' + self.end);\n            length = self.end - self.start + 1;\n        }\n        req.responseType = 'arraybuffer';\n        req.onreadystatechange = function() {\n            if (req.readyState == 4) {\n                if (req.status == 200 || req.status == 206) {\n                    if (req.response) {\n                        var bl = req.response.byteLength;\n                        if (length && length != bl && (!truncatedLength || bl != truncatedLength)) {\n                            return self.fetch(callback, attempt + 1, bl);\n                        } else {\n                            return callback(req.response);\n                        }\n                    } else if (req.mozResponseArrayBuffer) {\n                        return callback(req.mozResponseArrayBuffer);\n                    } else {\n                        var r = req.responseText;\n                        if (length && length != r.length && (!truncatedLength || r.length != truncatedLength)) {\n                            return self.fetch(callback, attempt + 1, r.length);\n                        } else {\n                            return callback(bstringToBuffer(req.responseText));\n                        }\n                    }\n                } else {\n                    return self.fetch(callback, attempt + 1);\n                }\n            }\n        };\n        if (self.opts.credentials) {\n            req.withCredentials = true;\n        }\n        req.send();\n    }).catch(function(err) {\n        console.log(err);\n    });\n}\n\nfunction bstringToBuffer(result) {\n    if (!result) {\n        return null;\n    }\n\n    var ba = new Uint8Array(result.length);\n    for (var i = 0; i < ba.length; ++i) {\n        ba[i] = result.charCodeAt(i);\n    }\n    return ba.buffer;\n}\n\nif (typeof(module) !== 'undefined') {\n    module.exports = {\n        lookupEncodeURI: lookupEncodeURI,\n        EncodeFetchable: EncodeFetchable\n    };\n}\n","/* -*- mode: javascript; c-basic-offset: 4; indent-tabs-mode: nil -*- */\n\n// \n// Dalliance Genome Explorer\n// (c) Thomas Down 2006-2014\n//\n// fetchworker.js\n//\n\n\"use strict\";\n\nvar bin = require('./bin');\nvar bam = require('./bam');\nvar cram = require('./cram');\nvar bigwig = require('./bigwig');\nvar encode = require('./encode');\nvar utils = require('./utils');\n\nvar Promise = require('es6-promise').Promise;\n\nvar connections = {};\nvar resolveResolvers = {};\n\nvar idSeed = 0;\n\nglobal.newID = function() {\n    return 'cn' + (++idSeed);\n}\n\npostMessage({tag: 'init'});\n\nself.onmessage = function(event) {\n    var d = event.data;\n    var command = event.data.command;\n    var tag = event.data.tag;\n\n    if (!command) {\n        var rr = resolveResolvers[tag];\n        if (rr) {\n            if (d.err) {\n                rr.reject(d.err);\n            } else {\n                rr.resolve(d.url);\n            }\n                \n            delete resolveResolvers[tag];\n        }\n    } else if (command === 'connectBAM') {\n        var id = newID();\n        var resolver;\n        if (d.resolver) {\n            resolver = proxyResolver(d.resolver);\n        }\n        var bamF, baiF, indexChunks;\n        if (d.blob) {\n            bamF = new bin.BlobFetchable(d.blob);\n            baiF = new bin.BlobFetchable(d.indexBlob);\n        } else {\n            bamF = new bin.URLFetchable(d.uri, {credentials: d.credentials, resolver: resolver});\n            baiF = new bin.URLFetchable(d.indexUri, {credentials: d.credentials, resolver: resolver});\n            indexChunks = d.indexChunks;\n        }\n\n        bam.makeBam(bamF, baiF, indexChunks, function(bamObj, err) {\n            if (bamObj) {\n                connections[id] = new BAMWorkerFetcher(bamObj);\n                postMessage({tag: tag, result: id});\n            } else {\n                postMessage({tag: tag, error: err || \"Couldn't fetch BAM\"});\n            }\n        });\n      } else if (command === 'connectCRAM') {\n          var id = newID();\n          var resolver;\n          if (d.resolver) {\n              resolver = proxyResolver(d.resolver);\n          }\n          var cramF, craiF, indexChunks;\n          if (d.blob) {\n              cramF = new bin.BlobFetchable(d.blob);\n              craiF = new bin.BlobFetchable(d.indexBlob);\n          } else {\n              cramF = new bin.URLFetchable(d.uri, {credentials: d.credentials, resolver: resolver});\n              craiF = new bin.URLFetchable(d.indexUri, {credentials: d.credentials, resolver: resolver});\n              indexChunks = d.indexChunks;\n          }\n\n          cram.makeCram(cramF, craiF, indexChunks, function(cramObj, err) {\n              if (cramObj) {\n                  connections[id] = new CRAMWorkerFetcher(bamObj);\n                  postMessage({tag: tag, result: id});\n              } else {\n                  postMessage({tag: tag, error: err || \"Couldn't fetch CRAM\"});\n              }\n          });\n    } else if (command === 'connectBBI') {\n        var id = newID();\n        var resolver;\n        if (d.resolver) {\n            resolver = proxyResolver(d.resolver);\n        }\n        var bbi;\n        if (d.blob) {\n            bbi = new bin.BlobFetchable(d.blob);\n        } else if (d.transport == 'encode') {\n            bbi = new encode.EncodeFetchable(d.uri, {credentials: d.credentials});\n        } else {\n            bbi = new bin.URLFetchable(d.uri, {credentials: d.credentials, resolver: resolver});\n        }\n\n        bigwig.makeBwg(bbi, function(bwg, err) {\n            if (bwg) {\n                connections[id] = new BBIWorkerFetcher(bwg);\n                postMessage({tag: tag, result: id});\n            } else {\n                postMessage({tag: tag, error: err || \"Couldn't fetch BBI\"});\n            }\n        }, d.uri);\n    } else if (command === 'textxhr') {\n        utils.textXHR(d.uri, function(resp, err) {\n            if (resp) {\n                postMessage({tag: tag, result: resp});\n            } else {\n                postMessage({tag: tag, err: err || \"Couldn't fetch resource\"});\n            }\n        });\n    } else if (command === 'fetch') {\n        var con = connections[event.data.connection];\n        if (!con) {\n            return postMessage({tag: tag, error: 'No such connection: ' + event.data.connection});\n        }\n\n        con.fetch(d.tag, d.chr, d.min, d.max, d.zoom, d.opts);\n    } else if (command === 'leap') {\n        var con = connections[event.data.connection];\n        if (!con) {\n            return postMessage({tag: tag, error: 'No such connection: ' + event.data.connection});\n        }\n\n        con.leap(d.tag, d.chr, d.pos, d.dir);\n    } else if (command === 'quantLeap') {\n        var con = connections[event.data.connection];\n        if (!con) {\n            return postMessage({tag: tag, error: 'No such connection: ' + event.data.connection});\n        }\n\n        con.quantLeap(d.tag, d.chr, d.pos, d.dir, d.threshold, d.under);\n    } else if (command === 'meta') {\n        var con = connections[event.data.connection];\n        if (!con) {\n            return postMessage({tag: tag, error: 'No such connection: ' + event.data.connection});\n        }\n\n        con.meta(d.tag);\n    } else if (command === 'search') {\n        var con = connections[event.data.connection];\n        if (!con) {\n            return postMessage({tag: tag, error: 'No such connection: ' + event.data.connection});\n        }\n\n        con.search(d.tag, d.query, d.index);\n    } else if (command === 'date') {\n        return postMessage({tag: tag, result: Date.now()|0});\n    } else {\n        postMessage({tag: tag, error: 'Bad command ' + command});\n    }\n}\n\nfunction BAMWorkerFetcher(bam) {\n    this.bam = bam;\n}\n\nBAMWorkerFetcher.prototype.fetch = function(tag, chr, min, max, zoom, opts) {\n    opts = opts || {};\n    this.bam.fetch(chr, min, max, function(records, err) {\n        if (records) {\n            postMessage({tag: tag, result: records, time: Date.now()|0});\n        } else {\n            postMessage({tag: tag, error: err});\n        }\n    }, opts);\n}\n\nfunction BBIWorkerFetcher(bbi) {\n    this.bbi = bbi;\n}\n\nBBIWorkerFetcher.prototype.fetch = function(tag, chr, min, max, zoom) {\n    if (typeof(zoom) !== 'number')\n        zoom = -1;\n\n    var data;\n    if (zoom < 0) {\n        data = this.bbi.getUnzoomedView();\n    } else {\n        data = this.bbi.getZoomedView(zoom);\n    }\n\n    data.readWigData(chr, min, max, function(features) {\n        postMessage({tag: tag, result: features});\n    });\n}\n\nBBIWorkerFetcher.prototype.meta = function(tag) {\n    var scales = [1];\n    for (var z = 0; z < this.bbi.zoomLevels.length; ++z) {\n        scales.push(this.bbi.zoomLevels[z].reduction);\n    }\n\n    var thisB = this;\n    var meta = {type: this.bbi.type,\n                zoomLevels: scales,\n                fieldCount: this.bbi.fieldCount,\n                definedFieldCount: this.bbi.definedFieldCount,\n                schema: this.bbi.schema};\n    if (this.bbi.type === 'bigbed') {\n        this.bbi.getExtraIndices(function(ei) {\n            if (ei) {\n                thisB.extraIndices = ei;\n                meta.extraIndices = ei.map(function(i) {return i.field});\n            }\n            postMessage({tag: tag, result: meta});\n        });\n    } else {\n        postMessage({tag: tag, result: meta});\n    }\n}\n\nBBIWorkerFetcher.prototype.leap = function(tag, chr, pos, dir) {\n    this.bbi.getUnzoomedView().getFirstAdjacent(chr, pos, dir, function(result, err) {\n        postMessage({tag: tag, result: result, error: err});\n    });\n}\n\nBBIWorkerFetcher.prototype.quantLeap = function(tag, chr, pos, dir, threshold, under) {\n    this.bbi.thresholdSearch(chr, pos, dir, threshold, function(result, err) {\n        postMessage({tag: tag, result: result, error: err});\n    });\n}\n\nBBIWorkerFetcher.prototype.search = function(tag, query, index) {\n    var is = this.extraIndices[0];\n    is.lookup(query, function(result, err) {\n        postMessage({tag: tag, result: result, error: err});\n    });\n}\n\nfunction proxyResolver(tag) {\n    return function(url) {\n        var lid = newID();\n        return new Promise(function (resolve, reject) {\n            resolveResolvers[lid] = {resolve: resolve, reject: reject};\n            postMessage({tag: lid,\n                         cmd: 'resolve',\n                         resolver: tag,\n                         url: url});\n        });\n    }\n}\n","/* -*- mode: javascript; c-basic-offset: 4; indent-tabs-mode: nil -*- */\n\n// \n// Dalliance Genome Explorer\n// (c) Thomas Down 2006-2011\n//\n// lh3utils.js: common support for lh3's file formats\n//\n\nif (typeof(require) !== 'undefined') {\n    var jszlib = require('jszlib');\n    var jszlib_inflate_buffer = jszlib.inflateBuffer;\n    var arrayCopy = jszlib.arrayCopy;\n}\n\nfunction Vob(b, o) {\n    this.block = b;\n    this.offset = o;\n}\n\nVob.prototype.toString = function() {\n    return '' + this.block + ':' + this.offset;\n}\n\nfunction readVob(ba, offset, allowZero) {\n    var block = ((ba[offset+6] & 0xff) * 0x100000000) + ((ba[offset+5] & 0xff) * 0x1000000) + ((ba[offset+4] & 0xff) * 0x10000) + ((ba[offset+3] & 0xff) * 0x100) + ((ba[offset+2] & 0xff));\n    var bint = (ba[offset+1] << 8) | (ba[offset]);\n    if (block == 0 && bint == 0 && !allowZero) {\n        return null;  // Should only happen in the linear index?\n    } else {\n        return new Vob(block, bint);\n    }\n}\n\nfunction unbgzf(data, lim) {\n    lim = Math.min(lim || 1, data.byteLength - 50);\n    var oBlockList = [];\n    var ptr = [0];\n    var totalSize = 0;\n\n    while (ptr[0] < lim) {\n        var ba = new Uint8Array(data, ptr[0], 12); // FIXME is this enough for all credible BGZF block headers?\n        var xlen = (ba[11] << 8) | (ba[10]);\n        // dlog('xlen[' + (ptr[0]) +']=' + xlen);\n        var unc = jszlib_inflate_buffer(data, 12 + xlen + ptr[0], Math.min(65536, data.byteLength - 12 - xlen - ptr[0]), ptr);\n        ptr[0] += 8;\n        totalSize += unc.byteLength;\n        oBlockList.push(unc);\n    }\n\n    if (oBlockList.length == 1) {\n        return oBlockList[0];\n    } else {\n        var out = new Uint8Array(totalSize);\n        var cursor = 0;\n        for (var i = 0; i < oBlockList.length; ++i) {\n            var b = new Uint8Array(oBlockList[i]);\n            arrayCopy(b, 0, out, cursor, b.length);\n            cursor += b.length;\n        }\n        return out.buffer;\n    }\n}\n\nfunction Chunk(minv, maxv) {\n    this.minv = minv; this.maxv = maxv;\n}\n\n\n//\n// Binning (transliterated from SAM1.3 spec)\n//\n\n/* calculate bin given an alignment covering [beg,end) (zero-based, half-close-half-open) */\nfunction reg2bin(beg, end)\n{\n    --end;\n    if (beg>>14 == end>>14) return ((1<<15)-1)/7 + (beg>>14);\n    if (beg>>17 == end>>17) return ((1<<12)-1)/7 + (beg>>17);\n    if (beg>>20 == end>>20) return ((1<<9)-1)/7 + (beg>>20);\n    if (beg>>23 == end>>23) return ((1<<6)-1)/7 + (beg>>23);\n    if (beg>>26 == end>>26) return ((1<<3)-1)/7 + (beg>>26);\n    return 0;\n}\n\n/* calculate the list of bins that may overlap with region [beg,end) (zero-based) */\nvar MAX_BIN = (((1<<18)-1)/7);\nfunction reg2bins(beg, end) \n{\n    var i = 0, k, list = [];\n    --end;\n    list.push(0);\n    for (k = 1 + (beg>>26); k <= 1 + (end>>26); ++k) list.push(k);\n    for (k = 9 + (beg>>23); k <= 9 + (end>>23); ++k) list.push(k);\n    for (k = 73 + (beg>>20); k <= 73 + (end>>20); ++k) list.push(k);\n    for (k = 585 + (beg>>17); k <= 585 + (end>>17); ++k) list.push(k);\n    for (k = 4681 + (beg>>14); k <= 4681 + (end>>14); ++k) list.push(k);\n    return list;\n}\n\nif (typeof(module) !== 'undefined') {\n    module.exports = {\n        unbgzf: unbgzf,\n        readVob: readVob,\n        reg2bin: reg2bin,\n        reg2bins: reg2bins,\n        Chunk: Chunk\n    };\n}\n","/*\r\n * A JavaScript implementation of the Secure Hash Algorithm, SHA-1, as defined\r\n * in FIPS 180-1\r\n * Version 2.2 Copyright Paul Johnston 2000 - 2009.\r\n * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet\r\n * Distributed under the BSD License\r\n * See http://pajhome.org.uk/crypt/md5 for details.\r\n */\r\n\r\n \"use strict\";\r\n\r\n/*\r\n * Configurable variables. You may need to tweak these to be compatible with\r\n * the server-side, but the defaults work in most cases.\r\n */\r\nvar hexcase = 0;  /* hex output format. 0 - lowercase; 1 - uppercase        */\r\nvar b64pad  = \"\"; /* base-64 pad character. \"=\" for strict RFC compliance   */\r\n\r\n/*\r\n * These are the functions you'll usually want to call\r\n * They take string arguments and return either hex or base-64 encoded strings\r\n */\r\nfunction hex_sha1(s)    { return rstr2hex(rstr_sha1(str2rstr_utf8(s))); }\r\nfunction b64_sha1(s)    { return rstr2b64(rstr_sha1(str2rstr_utf8(s))); }\r\nfunction any_sha1(s, e) { return rstr2any(rstr_sha1(str2rstr_utf8(s)), e); }\r\nfunction hex_hmac_sha1(k, d)\r\n  { return rstr2hex(rstr_hmac_sha1(str2rstr_utf8(k), str2rstr_utf8(d))); }\r\nfunction b64_hmac_sha1(k, d)\r\n  { return rstr2b64(rstr_hmac_sha1(str2rstr_utf8(k), str2rstr_utf8(d))); }\r\nfunction any_hmac_sha1(k, d, e)\r\n  { return rstr2any(rstr_hmac_sha1(str2rstr_utf8(k), str2rstr_utf8(d)), e); }\r\n\r\n/*\r\n * Perform a simple self-test to see if the VM is working\r\n */\r\nfunction sha1_vm_test()\r\n{\r\n  return hex_sha1(\"abc\").toLowerCase() == \"a9993e364706816aba3e25717850c26c9cd0d89d\";\r\n}\r\n\r\n/*\r\n * Calculate the SHA1 of a raw string\r\n */\r\nfunction rstr_sha1(s)\r\n{\r\n  return binb2rstr(binb_sha1(rstr2binb(s), s.length * 8));\r\n}\r\n\r\n/*\r\n * Calculate the HMAC-SHA1 of a key and some data (raw strings)\r\n */\r\nfunction rstr_hmac_sha1(key, data)\r\n{\r\n  var bkey = rstr2binb(key);\r\n  if(bkey.length > 16) bkey = binb_sha1(bkey, key.length * 8);\r\n\r\n  var ipad = Array(16), opad = Array(16);\r\n  for(var i = 0; i < 16; i++)\r\n  {\r\n    ipad[i] = bkey[i] ^ 0x36363636;\r\n    opad[i] = bkey[i] ^ 0x5C5C5C5C;\r\n  }\r\n\r\n  var hash = binb_sha1(ipad.concat(rstr2binb(data)), 512 + data.length * 8);\r\n  return binb2rstr(binb_sha1(opad.concat(hash), 512 + 160));\r\n}\r\n\r\n/*\r\n * Convert a raw string to a hex string\r\n */\r\nfunction rstr2hex(input)\r\n{\r\n  // try { hexcase } catch(e) { hexcase=0; }\r\n  var hex_tab = hexcase ? \"0123456789ABCDEF\" : \"0123456789abcdef\";\r\n  var output = \"\";\r\n  var x;\r\n  for(var i = 0; i < input.length; i++)\r\n  {\r\n    x = input.charCodeAt(i);\r\n    output += hex_tab.charAt((x >>> 4) & 0x0F)\r\n           +  hex_tab.charAt( x        & 0x0F);\r\n  }\r\n  return output;\r\n}\r\n\r\n/*\r\n * Convert a raw string to a base-64 string\r\n */\r\nfunction rstr2b64(input)\r\n{\r\n  // try { b64pad } catch(e) { b64pad=''; }\r\n  var tab = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\r\n  var output = \"\";\r\n  var len = input.length;\r\n  for(var i = 0; i < len; i += 3)\r\n  {\r\n    var triplet = (input.charCodeAt(i) << 16)\r\n                | (i + 1 < len ? input.charCodeAt(i+1) << 8 : 0)\r\n                | (i + 2 < len ? input.charCodeAt(i+2)      : 0);\r\n    for(var j = 0; j < 4; j++)\r\n    {\r\n      if(i * 8 + j * 6 > input.length * 8) output += b64pad;\r\n      else output += tab.charAt((triplet >>> 6*(3-j)) & 0x3F);\r\n    }\r\n  }\r\n  return output;\r\n}\r\n\r\n/*\r\n * Convert a raw string to an arbitrary string encoding\r\n */\r\nfunction rstr2any(input, encoding)\r\n{\r\n  var divisor = encoding.length;\r\n  var remainders = Array();\r\n  var i, q, x, quotient;\r\n\r\n  /* Convert to an array of 16-bit big-endian values, forming the dividend */\r\n  var dividend = Array(Math.ceil(input.length / 2));\r\n  for(i = 0; i < dividend.length; i++)\r\n  {\r\n    dividend[i] = (input.charCodeAt(i * 2) << 8) | input.charCodeAt(i * 2 + 1);\r\n  }\r\n\r\n  /*\r\n   * Repeatedly perform a long division. The binary array forms the dividend,\r\n   * the length of the encoding is the divisor. Once computed, the quotient\r\n   * forms the dividend for the next step. We stop when the dividend is zero.\r\n   * All remainders are stored for later use.\r\n   */\r\n  while(dividend.length > 0)\r\n  {\r\n    quotient = Array();\r\n    x = 0;\r\n    for(i = 0; i < dividend.length; i++)\r\n    {\r\n      x = (x << 16) + dividend[i];\r\n      q = Math.floor(x / divisor);\r\n      x -= q * divisor;\r\n      if(quotient.length > 0 || q > 0)\r\n        quotient[quotient.length] = q;\r\n    }\r\n    remainders[remainders.length] = x;\r\n    dividend = quotient;\r\n  }\r\n\r\n  /* Convert the remainders to the output string */\r\n  var output = \"\";\r\n  for(i = remainders.length - 1; i >= 0; i--)\r\n    output += encoding.charAt(remainders[i]);\r\n\r\n  /* Append leading zero equivalents */\r\n  var full_length = Math.ceil(input.length * 8 /\r\n                                    (Math.log(encoding.length) / Math.log(2)))\r\n  for(i = output.length; i < full_length; i++)\r\n    output = encoding[0] + output;\r\n\r\n  return output;\r\n}\r\n\r\n/*\r\n * Encode a string as utf-8.\r\n * For efficiency, this assumes the input is valid utf-16.\r\n */\r\nfunction str2rstr_utf8(input)\r\n{\r\n  var output = \"\";\r\n  var i = -1;\r\n  var x, y;\r\n\r\n  while(++i < input.length)\r\n  {\r\n    /* Decode utf-16 surrogate pairs */\r\n    x = input.charCodeAt(i);\r\n    y = i + 1 < input.length ? input.charCodeAt(i + 1) : 0;\r\n    if(0xD800 <= x && x <= 0xDBFF && 0xDC00 <= y && y <= 0xDFFF)\r\n    {\r\n      x = 0x10000 + ((x & 0x03FF) << 10) + (y & 0x03FF);\r\n      i++;\r\n    }\r\n\r\n    /* Encode output as utf-8 */\r\n    if(x <= 0x7F)\r\n      output += String.fromCharCode(x);\r\n    else if(x <= 0x7FF)\r\n      output += String.fromCharCode(0xC0 | ((x >>> 6 ) & 0x1F),\r\n                                    0x80 | ( x         & 0x3F));\r\n    else if(x <= 0xFFFF)\r\n      output += String.fromCharCode(0xE0 | ((x >>> 12) & 0x0F),\r\n                                    0x80 | ((x >>> 6 ) & 0x3F),\r\n                                    0x80 | ( x         & 0x3F));\r\n    else if(x <= 0x1FFFFF)\r\n      output += String.fromCharCode(0xF0 | ((x >>> 18) & 0x07),\r\n                                    0x80 | ((x >>> 12) & 0x3F),\r\n                                    0x80 | ((x >>> 6 ) & 0x3F),\r\n                                    0x80 | ( x         & 0x3F));\r\n  }\r\n  return output;\r\n}\r\n\r\n/*\r\n * Encode a string as utf-16\r\n */\r\nfunction str2rstr_utf16le(input)\r\n{\r\n  var output = \"\";\r\n  for(var i = 0; i < input.length; i++)\r\n    output += String.fromCharCode( input.charCodeAt(i)        & 0xFF,\r\n                                  (input.charCodeAt(i) >>> 8) & 0xFF);\r\n  return output;\r\n}\r\n\r\nfunction str2rstr_utf16be(input)\r\n{\r\n  var output = \"\";\r\n  for(var i = 0; i < input.length; i++)\r\n    output += String.fromCharCode((input.charCodeAt(i) >>> 8) & 0xFF,\r\n                                   input.charCodeAt(i)        & 0xFF);\r\n  return output;\r\n}\r\n\r\n/*\r\n * Convert a raw string to an array of big-endian words\r\n * Characters >255 have their high-byte silently ignored.\r\n */\r\nfunction rstr2binb(input)\r\n{\r\n  var output = Array(input.length >> 2);\r\n  for(var i = 0; i < output.length; i++)\r\n    output[i] = 0;\r\n  for(var i = 0; i < input.length * 8; i += 8)\r\n    output[i>>5] |= (input.charCodeAt(i / 8) & 0xFF) << (24 - i % 32);\r\n  return output;\r\n}\r\n\r\n/*\r\n * Convert an array of big-endian words to a string\r\n */\r\nfunction binb2rstr(input)\r\n{\r\n  var output = \"\";\r\n  for(var i = 0; i < input.length * 32; i += 8)\r\n    output += String.fromCharCode((input[i>>5] >>> (24 - i % 32)) & 0xFF);\r\n  return output;\r\n}\r\n\r\n/*\r\n * Calculate the SHA-1 of an array of big-endian words, and a bit length\r\n */\r\nfunction binb_sha1(x, len)\r\n{\r\n  /* append padding */\r\n  x[len >> 5] |= 0x80 << (24 - len % 32);\r\n  x[((len + 64 >> 9) << 4) + 15] = len;\r\n\r\n  var w = Array(80);\r\n  var a =  1732584193;\r\n  var b = -271733879;\r\n  var c = -1732584194;\r\n  var d =  271733878;\r\n  var e = -1009589776;\r\n\r\n  for(var i = 0; i < x.length; i += 16)\r\n  {\r\n    var olda = a;\r\n    var oldb = b;\r\n    var oldc = c;\r\n    var oldd = d;\r\n    var olde = e;\r\n\r\n    for(var j = 0; j < 80; j++)\r\n    {\r\n      if(j < 16) w[j] = x[i + j];\r\n      else w[j] = bit_rol(w[j-3] ^ w[j-8] ^ w[j-14] ^ w[j-16], 1);\r\n      var t = safe_add(safe_add(bit_rol(a, 5), sha1_ft(j, b, c, d)),\r\n                       safe_add(safe_add(e, w[j]), sha1_kt(j)));\r\n      e = d;\r\n      d = c;\r\n      c = bit_rol(b, 30);\r\n      b = a;\r\n      a = t;\r\n    }\r\n\r\n    a = safe_add(a, olda);\r\n    b = safe_add(b, oldb);\r\n    c = safe_add(c, oldc);\r\n    d = safe_add(d, oldd);\r\n    e = safe_add(e, olde);\r\n  }\r\n  return Array(a, b, c, d, e);\r\n\r\n}\r\n\r\n/*\r\n * Perform the appropriate triplet combination function for the current\r\n * iteration\r\n */\r\nfunction sha1_ft(t, b, c, d)\r\n{\r\n  if(t < 20) return (b & c) | ((~b) & d);\r\n  if(t < 40) return b ^ c ^ d;\r\n  if(t < 60) return (b & c) | (b & d) | (c & d);\r\n  return b ^ c ^ d;\r\n}\r\n\r\n/*\r\n * Determine the appropriate additive constant for the current iteration\r\n */\r\nfunction sha1_kt(t)\r\n{\r\n  return (t < 20) ?  1518500249 : (t < 40) ?  1859775393 :\r\n         (t < 60) ? -1894007588 : -899497514;\r\n}\r\n\r\n/*\r\n * Add integers, wrapping at 2^32. This uses 16-bit operations internally\r\n * to work around bugs in some JS interpreters.\r\n */\r\nfunction safe_add(x, y)\r\n{\r\n  var lsw = (x & 0xFFFF) + (y & 0xFFFF);\r\n  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);\r\n  return (msw << 16) | (lsw & 0xFFFF);\r\n}\r\n\r\n/*\r\n * Bitwise rotate a 32-bit number to the left.\r\n */\r\nfunction bit_rol(num, cnt)\r\n{\r\n  return (num << cnt) | (num >>> (32 - cnt));\r\n}\r\n\r\nif (typeof(module) !== 'undefined') {\r\n  module.exports = {\r\n    b64_sha1: b64_sha1,\r\n    hex_sha1: hex_sha1\r\n  }\r\n}\r\n","/* -*- mode: javascript; c-basic-offset: 4; indent-tabs-mode: nil -*- */\n\n// \n// Dalliance Genome Explorer\n// (c) Thomas Down 2006-2010\n//\n// spans.js: JavaScript Intset/Location port.\n//\n\n\"use strict\";\n\n\nfunction Range(min, max)\n{\n    if (typeof(min) != 'number' || typeof(max) != 'number')\n        throw 'Bad range ' + min + ',' + max;\n    this._min = min;\n    this._max = max;\n}\n\nRange.prototype.min = function() {\n    return this._min;\n}\n\nRange.prototype.max = function() {\n    return this._max;\n}\n\nRange.prototype.contains = function(pos) {\n    return pos >= this._min && pos <= this._max;\n}\n\nRange.prototype.isContiguous = function() {\n    return true;\n}\n\nRange.prototype.ranges = function() {\n    return [this];\n}\n\nRange.prototype._pushRanges = function(ranges) {\n    ranges.push(this);\n}\n\nRange.prototype.toString = function() {\n    return '[' + this._min + '-' + this._max + ']';\n}\n\nfunction _Compound(ranges) {\n    // given: a set of unsorted possibly overlapping ranges\n    // sort the input ranges\n    var sorted = ranges.sort(_rangeOrder);\n    // merge overlaps between adjacent ranges\n    var merged = [];\n    var current = sorted.shift();\n    sorted.forEach(function(range) {\n        if (range._min <= current._max) {\n            if (range._max > current._max) {\n                current._max = range._max;\n            }\n        }\n        else {\n            merged.push(current);\n            current = range;\n        }\n    });\n    merged.push(current);\n    this._ranges = merged;\n}\n\n_Compound.prototype.min = function() {\n    return this._ranges[0].min();\n}\n\n_Compound.prototype.max = function() {\n    return this._ranges[this._ranges.length - 1].max();\n}\n\n// returns the index of the first range that is not less than pos\n_Compound.prototype.lower_bound = function(pos) {\n    // first check if pos is out of range\n    var r = this.ranges();\n    if (pos > this.max()) return r.length;\n    if (pos < this.min()) return 0;\n    // do a binary search\n    var a=0, b=r.length - 1;\n    while (a <= b) {\n        var m = Math.floor((a+b)/2);\n        if (pos > r[m]._max) {\n            a = m+1;\n        }\n        else if (pos < r[m]._min) {\n            b = m-1;\n        }\n        else {\n            return m;\n        }\n    }\n    return a;\n}\n\n_Compound.prototype.contains = function(pos) {\n    var lb = this.lower_bound(pos);\n    if (lb < this._ranges.length && this._ranges[lb].contains(pos)) {\n        return true;\n    }\n    return false;\n}\n\n_Compound.prototype.insertRange = function(range) {\n    var lb = this.lower_bound(range._min);\n    if (lb === this._ranges.length) { // range follows this\n        this._ranges.push(range);\n        return;\n    }\n    \n    var r = this.ranges();\n    if (range._max < r[lb]._min) { // range preceeds lb\n        this._ranges.splice(lb,0,range);\n        return;\n    }\n\n    // range overlaps lb (at least)\n    if (r[lb]._min < range._min) range._min = r[lb]._min;\n    var ub = lb+1;\n    while (ub < r.length && r[ub]._min <= range._max) {\n        ub++;\n    }\n    ub--;\n    // ub is the upper bound of the new range\n    if (r[ub]._max > range._max) range._max = r[ub]._max;\n    \n    // splice range into this._ranges\n    this._ranges.splice(lb,ub-lb+1,range);\n    return;\n}\n\n_Compound.prototype.isContiguous = function() {\n    return this._ranges.length > 1;\n}\n\n_Compound.prototype.ranges = function() {\n    return this._ranges;\n}\n\n_Compound.prototype._pushRanges = function(ranges) {\n    for (var ri = 0; ri < this._ranges.length; ++ri)\n        ranges.push(this._ranges[ri]);\n}\n\n_Compound.prototype.toString = function() {\n    var s = '';\n    for (var r = 0; r < this._ranges.length; ++r) {\n        if (r>0) {\n            s = s + ',';\n        }\n        s = s + this._ranges[r].toString();\n    }\n    return s;\n}\n\nfunction union(s0, s1) {\n    if (! (s0 instanceof _Compound)) {\n        if (! (s0 instanceof Array))\n            s0 = [s0];\n        s0 = new _Compound(s0);\n    }\n    \n    if (s1)\n        s0.insertRange(s1);\n\n    return s0;\n}\n\nfunction intersection(s0, s1) {\n    var r0 = s0.ranges();\n    var r1 = s1.ranges();\n    var l0 = r0.length, l1 = r1.length;\n    var i0 = 0, i1 = 0;\n    var or = [];\n\n    while (i0 < l0 && i1 < l1) {\n        var s0 = r0[i0], s1 = r1[i1];\n        var lapMin = Math.max(s0.min(), s1.min());\n        var lapMax = Math.min(s0.max(), s1.max());\n        if (lapMax >= lapMin) {\n            or.push(new Range(lapMin, lapMax));\n        }\n        if (s0.max() > s1.max()) {\n            ++i1;\n        } else {\n            ++i0;\n        }\n    }\n    \n    if (or.length == 0) {\n        return null; // FIXME\n    } else if (or.length == 1) {\n        return or[0];\n    } else {\n        return new _Compound(or);\n    }\n}\n\nfunction coverage(s) {\n    var tot = 0;\n    var rl = s.ranges();\n    for (var ri = 0; ri < rl.length; ++ri) {\n        var r = rl[ri];\n        tot += (r.max() - r.min() + 1);\n    }\n    return tot;\n}\n\n\n\nfunction rangeOrder(a, b)\n{\n    if (a.min() < b.min()) {\n        return -1;\n    } else if (a.min() > b.min()) {\n        return 1;\n    } else if (a.max() < b.max()) {\n        return -1;\n    } else if (b.max() > a.max()) {\n        return 1;\n    } else {\n        return 0;\n    }\n}\n\nfunction _rangeOrder(a, b)\n{\n    if (a._min < b._min) {\n        return -1;\n    } else if (a._min > b._min) {\n        return 1;\n    } else if (a._max < b._max) {\n        return -1;\n    } else if (b._max > a._max) {\n        return 1;\n    } else {\n        return 0;\n    }\n}\n\nif (typeof(module) !== 'undefined') {\n    module.exports = {\n        Range: Range,\n        union: union,\n        intersection: intersection,\n        coverage: coverage,\n        rangeOver: rangeOrder,\n        _rangeOrder: _rangeOrder\n    }\n}","/* -*- mode: javascript; c-basic-offset: 4; indent-tabs-mode: nil -*- */\n\n// \n// Dalliance Genome Explorer\n// (c) Thomas Down 2006-2010\n//\n// utils.js: odds, sods, and ends.\n//\n\n\"use strict\";\n\nif (typeof(require) !== 'undefined') {\n    var sha1 = require('./sha1');\n    var b64_sha1 = sha1.b64_sha1;\n}\n\nvar NUM_REGEXP = new RegExp('[0-9]+');\n\nfunction stringToNumbersArray(str) {\n    var nums = new Array();\n    var m;\n    while (m = NUM_REGEXP.exec(str)) {\n        nums.push(m[0]);\n        str=str.substring(m.index + (m[0].length));\n    }\n    return nums;\n}\n\nvar STRICT_NUM_REGEXP = new RegExp('^[0-9]+$');\n\nfunction stringToInt(str) {\n    str = str.replace(new RegExp(',', 'g'), '');\n    if (!STRICT_NUM_REGEXP.test(str)) {\n        return null;\n    }\n    return str|0;\n}\n\nfunction pushnew(a, v) {\n    for (var i = 0; i < a.length; ++i) {\n        if (a[i] == v) {\n            return;\n        }\n    }\n    a.push(v);\n}\n\nfunction pusho(obj, k, v) {\n    if (obj[k]) {\n        obj[k].push(v);\n    } else {\n        obj[k] = [v];\n    }\n}\n\nfunction pushnewo(obj, k, v) {\n    var a = obj[k];\n    if (a) {\n        for (var i = 0; i < a.length; ++i) {    // indexOf requires JS16 :-(.\n            if (a[i] == v) {\n                return;\n            }\n        }\n        a.push(v);\n    } else {\n        obj[k] = [v];\n    }\n}\n\n\nfunction pick(a, b, c, d)\n{\n    if (a) {\n        return a;\n    } else if (b) {\n        return b;\n    } else if (c) {\n        return c;\n    } else if (d) {\n        return d;\n    }\n}\n\nfunction pushnew(l, o)\n{\n    for (var i = 0; i < l.length; ++i) {\n        if (l[i] == o) {\n            return;\n        }\n    }\n    l.push(o);\n}\n\n\n\nfunction arrayIndexOf(a, x) {\n    if (!a) {\n        return -1;\n    }\n\n    for (var i = 0; i < a.length; ++i) {\n        if (a[i] === x) {\n            return i;\n        }\n    }\n    return -1;\n}\n\nfunction arrayRemove(a, x) {\n    var i = arrayIndexOf(a, x);\n    if (i >= 0) {\n        a.splice(i, 1);\n        return true;\n    }\n    return false;\n}\n\n//\n// DOM utilities\n//\n\n\nfunction makeElement(tag, children, attribs, styles)\n{\n    var ele = document.createElement(tag);\n    if (children) {\n        if (! (children instanceof Array)) {\n            children = [children];\n        }\n        for (var i = 0; i < children.length; ++i) {\n            var c = children[i];\n            if (c) {\n                if (typeof c == 'string') {\n                    c = document.createTextNode(c);\n                } else if (typeof c == 'number') {\n                    c = document.createTextNode('' + c);\n                }\n                ele.appendChild(c);\n            }\n        }\n    }\n    \n    if (attribs) {\n        for (var l in attribs) {\n            try {\n                ele[l] = attribs[l];\n            } catch (e) {\n                console.log('error setting ' + l);\n                throw(e);\n            }\n        }\n    }\n    if (styles) {\n        for (var l in styles) {\n            ele.style[l] = styles[l];\n        }\n    }\n    return ele;\n}\n\nfunction makeElementNS(namespace, tag, children, attribs)\n{\n    var ele = document.createElementNS(namespace, tag);\n    if (children) {\n        if (! (children instanceof Array)) {\n            children = [children];\n        }\n        for (var i = 0; i < children.length; ++i) {\n            var c = children[i];\n            if (typeof c == 'string') {\n                c = document.createTextNode(c);\n            }\n            ele.appendChild(c);\n        }\n    }\n    \n    setAttrs(ele, attribs);\n    return ele;\n}\n\nvar attr_name_cache = {};\n\nfunction setAttr(node, key, value)\n{\n    var attr = attr_name_cache[key];\n    if (!attr) {\n        var _attr = '';\n        for (var c = 0; c < key.length; ++c) {\n            var cc = key.substring(c, c+1);\n            var lcc = cc.toLowerCase();\n            if (lcc != cc) {\n                _attr = _attr + '-' + lcc;\n            } else {\n                _attr = _attr + cc;\n            }\n        }\n        attr_name_cache[key] = _attr;\n        attr = _attr;\n    }\n    node.setAttribute(attr, value);\n}\n\nfunction setAttrs(node, attribs)\n{\n    if (attribs) {\n        for (var l in attribs) {\n            setAttr(node, l, attribs[l]);\n        }\n    }\n}\n\n\n\nfunction removeChildren(node)\n{\n    if (!node || !node.childNodes) {\n        return;\n    }\n\n    while (node.childNodes.length > 0) {\n        node.removeChild(node.firstChild);\n    }\n}\n\n\n\n//\n// WARNING: not for general use!\n//\n\nfunction miniJSONify(o, exc) {\n    if (typeof o === 'undefined') {\n        return 'undefined';\n    } else if (o == null) {\n        return 'null';\n    } else if (typeof o == 'string') {\n        return \"'\" + o + \"'\";\n    } else if (typeof o == 'number') {\n        return \"\" + o;\n    } else if (typeof o == 'boolean') {\n        return \"\" + o;\n    } else if (typeof o == 'object') {\n        if (o instanceof Array) {\n            var s = null;\n            for (var i = 0; i < o.length; ++i) {\n                s = (s == null ? '' : (s + ', ')) + miniJSONify(o[i], exc);\n            }\n            return '[' + (s?s:'') + ']';\n        } else {\n            exc = exc || {};\n            var s = null;\n            for (var k in o) {\n                if (exc[k])\n                    continue;\n                if (k != undefined && typeof(o[k]) != 'function') {\n                    s = (s == null ? '' : (s + ', ')) + k + ': ' + miniJSONify(o[k], exc);\n                }\n            }\n            return '{' + (s?s:'') + '}';\n        }\n    } else {\n        return (typeof o);\n    }\n}\n\nfunction shallowCopy(o) {\n    var n = {};\n    for (var k in o) {\n        n[k] = o[k];\n    }\n    return n;\n}\n\nfunction Observed(x) {\n    this.value = x;\n    this.listeners = [];\n}\n\nObserved.prototype.addListener = function(f) {\n    this.listeners.push(f);\n}\n\nObserved.prototype.addListenerAndFire = function(f) {\n    this.listeners.push(f);\n    f(this.value);\n}\n\nObserved.prototype.removeListener = function(f) {\n    arrayRemove(this.listeners, f);\n}\n\nObserved.prototype.get = function() {\n    return this.value;\n}\n\nObserved.prototype.set = function(x) {\n    this.value = x;\n    for (var i = 0; i < this.listeners.length; ++i) {\n        this.listeners[i](x);\n    }\n}\n\nfunction Awaited() {\n    this.queue = [];\n}\n\nAwaited.prototype.provide = function(x) {\n    if (this.res !== undefined) {\n        throw \"Resource has already been provided.\";\n    }\n\n    this.res = x;\n    for (var i = 0; i < this.queue.length; ++i) {\n        this.queue[i](x);\n    }\n    this.queue = null;   // avoid leaking closures.\n}\n\nAwaited.prototype.await = function(f) {\n    if (this.res !== undefined) {\n        f(this.res);\n        return this.res;\n    } else {\n        this.queue.push(f);\n    }\n}\n\nvar __dalliance_saltSeed = 0;\n\nfunction saltURL(url) {\n    return url + '?salt=' + b64_sha1('' + Date.now() + ',' + (++__dalliance_saltSeed));\n}\n\nfunction textXHR(url, callback, opts) {\n    if (opts && opts.salt) \n        url = saltURL(url);\n\n    try {\n        var timeout;\n        if (opts && opts.timeout) {\n            timeout = setTimeout(\n                function() {\n                    console.log('timing out ' + url);\n                    req.abort();\n                    return callback(null, 'Timeout');\n                },\n                opts.timeout\n            );\n        }\n\n        var req = new XMLHttpRequest();\n        req.onreadystatechange = function() {\n    \t    if (req.readyState == 4) {\n                if (timeout)\n                    clearTimeout(timeout);\n    \t        if (req.status < 200 || req.status >= 300) {\n    \t\t    callback(null, 'Error code ' + req.status);\n    \t        } else {\n    \t\t    callback(req.responseText);\n    \t        }\n    \t    }\n        };\n        \n        req.open('GET', url, true);\n        req.responseType = 'text';\n\n        if (opts && opts.credentials) {\n            req.withCredentials = true;\n        }\n        req.send();\n    } catch (e) {\n        callback(null, 'Exception ' + e);\n    }\n}\n\nfunction relativeURL(base, rel) {\n    // FIXME quite naive -- good enough for trackhubs?\n\n    if (rel.indexOf('http:') == 0 || rel.indexOf('https:') == 0) {\n        return rel;\n    }\n\n    var li = base.lastIndexOf('/');\n    if (li >= 0) {\n        return base.substr(0, li + 1) + rel;\n    } else {\n        return rel;\n    }\n}\n\nvar AMINO_ACID_TRANSLATION = {\n    'TTT': 'F',\n    'TTC': 'F',\n    'TTA': 'L',\n    'TTG': 'L',\n    'CTT': 'L',\n    'CTC': 'L',\n    'CTA': 'L',\n    'CTG': 'L',\n    'ATT': 'I',\n    'ATC': 'I',\n    'ATA': 'I',\n    'ATG': 'M',\n    'GTT': 'V',\n    'GTC': 'V',\n    'GTA': 'V',\n    'GTG': 'V',\n    'TCT': 'S',\n    'TCC': 'S',\n    'TCA': 'S',\n    'TCG': 'S',\n    'CCT': 'P',\n    'CCC': 'P',\n    'CCA': 'P',\n    'CCG': 'P',\n    'ACT': 'T',\n    'ACC': 'T',\n    'ACA': 'T',\n    'ACG': 'T',\n    'GCT': 'A',\n    'GCC': 'A',\n    'GCA': 'A',\n    'GCG': 'A',\n    'TAT': 'Y',\n    'TAC': 'Y',\n    'TAA': '*',  // stop\n    'TAG': '*',  // stop\n    'CAT': 'H',\n    'CAC': 'H',\n    'CAA': 'Q',\n    'CAG': 'Q',\n    'AAT': 'N',\n    'AAC': 'N',\n    'AAA': 'K',\n    'AAG': 'K',\n    'GAT': 'D',\n    'GAC': 'D',\n    'GAA': 'E',\n    'GAG': 'E',\n    'TGT': 'C',\n    'TGC': 'C',\n    'TGA': '*',  // stop\n    'TGG': 'W',\n    'CGT': 'R',\n    'CGC': 'R',\n    'CGA': 'R',\n    'CGG': 'R',\n    'AGT': 'S',\n    'AGC': 'S',\n    'AGA': 'R',\n    'AGG': 'R',\n    'GGT': 'G',\n    'GGC': 'G',\n    'GGA': 'G',\n    'GGG': 'G'\n}\n\nfunction resolveUrlToPage(rel) {\n    return makeElement('a', null, {href: rel}).href;\n}\n\n//\n// Missing APIs\n// \n\nif (!('trim' in String.prototype)) {\n    String.prototype.trim = function() {\n        return this.replace(/^\\s+/, '').replace(/\\s+$/, '');\n    };\n}\n\nif (typeof(module) !== 'undefined') {\n    module.exports = {\n        textXHR: textXHR,\n        relativeURL: relativeURL,\n        resolveUrlToPage: resolveUrlToPage,\n        shallowCopy: shallowCopy,\n        pusho: pusho,\n        pushnew: pushnew,\n        pushnewo: pushnewo,\n        arrayIndexOf: arrayIndexOf,\n        pick: pick,\n\n        makeElement: makeElement,\n        makeElementNS: makeElementNS,\n        removeChildren: removeChildren,\n\n        miniJSONify: miniJSONify,\n\n        Observed: Observed,\n        Awaited: Awaited,\n\n        AMINO_ACID_TRANSLATION: AMINO_ACID_TRANSLATION\n    }\n}\n","\"use strict\";\nvar Promise = require(\"./promise/promise\").Promise;\nvar polyfill = require(\"./promise/polyfill\").polyfill;\nexports.Promise = Promise;\nexports.polyfill = polyfill;","\"use strict\";\n/* global toString */\n\nvar isArray = require(\"./utils\").isArray;\nvar isFunction = require(\"./utils\").isFunction;\n\n/**\n  Returns a promise that is fulfilled when all the given promises have been\n  fulfilled, or rejected if any of them become rejected. The return promise\n  is fulfilled with an array that gives all the values in the order they were\n  passed in the `promises` array argument.\n\n  Example:\n\n  ```javascript\n  var promise1 = RSVP.resolve(1);\n  var promise2 = RSVP.resolve(2);\n  var promise3 = RSVP.resolve(3);\n  var promises = [ promise1, promise2, promise3 ];\n\n  RSVP.all(promises).then(function(array){\n    // The array here would be [ 1, 2, 3 ];\n  });\n  ```\n\n  If any of the `promises` given to `RSVP.all` are rejected, the first promise\n  that is rejected will be given as an argument to the returned promises's\n  rejection handler. For example:\n\n  Example:\n\n  ```javascript\n  var promise1 = RSVP.resolve(1);\n  var promise2 = RSVP.reject(new Error(\"2\"));\n  var promise3 = RSVP.reject(new Error(\"3\"));\n  var promises = [ promise1, promise2, promise3 ];\n\n  RSVP.all(promises).then(function(array){\n    // Code here never runs because there are rejected promises!\n  }, function(error) {\n    // error.message === \"2\"\n  });\n  ```\n\n  @method all\n  @for RSVP\n  @param {Array} promises\n  @param {String} label\n  @return {Promise} promise that is fulfilled when all `promises` have been\n  fulfilled, or rejected if any of them become rejected.\n*/\nfunction all(promises) {\n  /*jshint validthis:true */\n  var Promise = this;\n\n  if (!isArray(promises)) {\n    throw new TypeError('You must pass an array to all.');\n  }\n\n  return new Promise(function(resolve, reject) {\n    var results = [], remaining = promises.length,\n    promise;\n\n    if (remaining === 0) {\n      resolve([]);\n    }\n\n    function resolver(index) {\n      return function(value) {\n        resolveAll(index, value);\n      };\n    }\n\n    function resolveAll(index, value) {\n      results[index] = value;\n      if (--remaining === 0) {\n        resolve(results);\n      }\n    }\n\n    for (var i = 0; i < promises.length; i++) {\n      promise = promises[i];\n\n      if (promise && isFunction(promise.then)) {\n        promise.then(resolver(i), reject);\n      } else {\n        resolveAll(i, promise);\n      }\n    }\n  });\n}\n\nexports.all = all;","\"use strict\";\nvar browserGlobal = (typeof window !== 'undefined') ? window : {};\nvar BrowserMutationObserver = browserGlobal.MutationObserver || browserGlobal.WebKitMutationObserver;\nvar local = (typeof global !== 'undefined') ? global : (this === undefined? window:this);\n\n// node\nfunction useNextTick() {\n  return function() {\n    process.nextTick(flush);\n  };\n}\n\nfunction useMutationObserver() {\n  var iterations = 0;\n  var observer = new BrowserMutationObserver(flush);\n  var node = document.createTextNode('');\n  observer.observe(node, { characterData: true });\n\n  return function() {\n    node.data = (iterations = ++iterations % 2);\n  };\n}\n\nfunction useSetTimeout() {\n  return function() {\n    local.setTimeout(flush, 1);\n  };\n}\n\nvar queue = [];\nfunction flush() {\n  for (var i = 0; i < queue.length; i++) {\n    var tuple = queue[i];\n    var callback = tuple[0], arg = tuple[1];\n    callback(arg);\n  }\n  queue = [];\n}\n\nvar scheduleFlush;\n\n// Decide what async method to use to triggering processing of queued callbacks:\nif (typeof process !== 'undefined' && {}.toString.call(process) === '[object process]') {\n  scheduleFlush = useNextTick();\n} else if (BrowserMutationObserver) {\n  scheduleFlush = useMutationObserver();\n} else {\n  scheduleFlush = useSetTimeout();\n}\n\nfunction asap(callback, arg) {\n  var length = queue.push([callback, arg]);\n  if (length === 1) {\n    // If length is 1, that means that we need to schedule an async flush.\n    // If additional callbacks are queued before the queue is flushed, they\n    // will be processed by this flush that we are scheduling.\n    scheduleFlush();\n  }\n}\n\nexports.asap = asap;","\"use strict\";\n/**\n  `RSVP.Promise.cast` returns the same promise if that promise shares a constructor\n  with the promise being casted.\n\n  Example:\n\n  ```javascript\n  var promise = RSVP.resolve(1);\n  var casted = RSVP.Promise.cast(promise);\n\n  console.log(promise === casted); // true\n  ```\n\n  In the case of a promise whose constructor does not match, it is assimilated.\n  The resulting promise will fulfill or reject based on the outcome of the\n  promise being casted.\n\n  In the case of a non-promise, a promise which will fulfill with that value is\n  returned.\n\n  Example:\n\n  ```javascript\n  var value = 1; // could be a number, boolean, string, undefined...\n  var casted = RSVP.Promise.cast(value);\n\n  console.log(value === casted); // false\n  console.log(casted instanceof RSVP.Promise) // true\n\n  casted.then(function(val) {\n    val === value // => true\n  });\n  ```\n\n  `RSVP.Promise.cast` is similar to `RSVP.resolve`, but `RSVP.Promise.cast` differs in the\n  following ways:\n  * `RSVP.Promise.cast` serves as a memory-efficient way of getting a promise, when you\n  have something that could either be a promise or a value. RSVP.resolve\n  will have the same effect but will create a new promise wrapper if the\n  argument is a promise.\n  * `RSVP.Promise.cast` is a way of casting incoming thenables or promise subclasses to\n  promises of the exact class specified, so that the resulting object's `then` is\n  ensured to have the behavior of the constructor you are calling cast on (i.e., RSVP.Promise).\n\n  @method cast\n  @for RSVP\n  @param {Object} object to be casted\n  @return {Promise} promise that is fulfilled when all properties of `promises`\n  have been fulfilled, or rejected if any of them become rejected.\n*/\n\n\nfunction cast(object) {\n  /*jshint validthis:true */\n  if (object && typeof object === 'object' && object.constructor === this) {\n    return object;\n  }\n\n  var Promise = this;\n\n  return new Promise(function(resolve) {\n    resolve(object);\n  });\n}\n\nexports.cast = cast;","\"use strict\";\nvar config = {\n  instrument: false\n};\n\nfunction configure(name, value) {\n  if (arguments.length === 2) {\n    config[name] = value;\n  } else {\n    return config[name];\n  }\n}\n\nexports.config = config;\nexports.configure = configure;","\"use strict\";\n/*global self*/\nvar RSVPPromise = require(\"./promise\").Promise;\nvar isFunction = require(\"./utils\").isFunction;\n\nfunction polyfill() {\n  var local;\n\n  if (typeof global !== 'undefined') {\n    local = global;\n  } else if (typeof window !== 'undefined' && window.document) {\n    local = window;\n  } else {\n    local = self;\n  }\n\n  var es6PromiseSupport = \n    \"Promise\" in local &&\n    // Some of these methods are missing from\n    // Firefox/Chrome experimental implementations\n    \"cast\" in local.Promise &&\n    \"resolve\" in local.Promise &&\n    \"reject\" in local.Promise &&\n    \"all\" in local.Promise &&\n    \"race\" in local.Promise &&\n    // Older version of the spec had a resolver object\n    // as the arg rather than a function\n    (function() {\n      var resolve;\n      new local.Promise(function(r) { resolve = r; });\n      return isFunction(resolve);\n    }());\n\n  if (!es6PromiseSupport) {\n    local.Promise = RSVPPromise;\n  }\n}\n\nexports.polyfill = polyfill;","\"use strict\";\nvar config = require(\"./config\").config;\nvar configure = require(\"./config\").configure;\nvar objectOrFunction = require(\"./utils\").objectOrFunction;\nvar isFunction = require(\"./utils\").isFunction;\nvar now = require(\"./utils\").now;\nvar cast = require(\"./cast\").cast;\nvar all = require(\"./all\").all;\nvar race = require(\"./race\").race;\nvar staticResolve = require(\"./resolve\").resolve;\nvar staticReject = require(\"./reject\").reject;\nvar asap = require(\"./asap\").asap;\n\nvar counter = 0;\n\nconfig.async = asap; // default async is asap;\n\nfunction Promise(resolver) {\n  if (!isFunction(resolver)) {\n    throw new TypeError('You must pass a resolver function as the first argument to the promise constructor');\n  }\n\n  if (!(this instanceof Promise)) {\n    throw new TypeError(\"Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.\");\n  }\n\n  this._subscribers = [];\n\n  invokeResolver(resolver, this);\n}\n\nfunction invokeResolver(resolver, promise) {\n  function resolvePromise(value) {\n    resolve(promise, value);\n  }\n\n  function rejectPromise(reason) {\n    reject(promise, reason);\n  }\n\n  try {\n    resolver(resolvePromise, rejectPromise);\n  } catch(e) {\n    rejectPromise(e);\n  }\n}\n\nfunction invokeCallback(settled, promise, callback, detail) {\n  var hasCallback = isFunction(callback),\n      value, error, succeeded, failed;\n\n  if (hasCallback) {\n    try {\n      value = callback(detail);\n      succeeded = true;\n    } catch(e) {\n      failed = true;\n      error = e;\n    }\n  } else {\n    value = detail;\n    succeeded = true;\n  }\n\n  if (handleThenable(promise, value)) {\n    return;\n  } else if (hasCallback && succeeded) {\n    resolve(promise, value);\n  } else if (failed) {\n    reject(promise, error);\n  } else if (settled === FULFILLED) {\n    resolve(promise, value);\n  } else if (settled === REJECTED) {\n    reject(promise, value);\n  }\n}\n\nvar PENDING   = void 0;\nvar SEALED    = 0;\nvar FULFILLED = 1;\nvar REJECTED  = 2;\n\nfunction subscribe(parent, child, onFulfillment, onRejection) {\n  var subscribers = parent._subscribers;\n  var length = subscribers.length;\n\n  subscribers[length] = child;\n  subscribers[length + FULFILLED] = onFulfillment;\n  subscribers[length + REJECTED]  = onRejection;\n}\n\nfunction publish(promise, settled) {\n  var child, callback, subscribers = promise._subscribers, detail = promise._detail;\n\n  for (var i = 0; i < subscribers.length; i += 3) {\n    child = subscribers[i];\n    callback = subscribers[i + settled];\n\n    invokeCallback(settled, child, callback, detail);\n  }\n\n  promise._subscribers = null;\n}\n\nPromise.prototype = {\n  constructor: Promise,\n\n  _state: undefined,\n  _detail: undefined,\n  _subscribers: undefined,\n\n  then: function(onFulfillment, onRejection) {\n    var promise = this;\n\n    var thenPromise = new this.constructor(function() {});\n\n    if (this._state) {\n      var callbacks = arguments;\n      config.async(function invokePromiseCallback() {\n        invokeCallback(promise._state, thenPromise, callbacks[promise._state - 1], promise._detail);\n      });\n    } else {\n      subscribe(this, thenPromise, onFulfillment, onRejection);\n    }\n\n    return thenPromise;\n  },\n\n  'catch': function(onRejection) {\n    return this.then(null, onRejection);\n  }\n};\n\nPromise.all = all;\nPromise.cast = cast;\nPromise.race = race;\nPromise.resolve = staticResolve;\nPromise.reject = staticReject;\n\nfunction handleThenable(promise, value) {\n  var then = null,\n  resolved;\n\n  try {\n    if (promise === value) {\n      throw new TypeError(\"A promises callback cannot return that same promise.\");\n    }\n\n    if (objectOrFunction(value)) {\n      then = value.then;\n\n      if (isFunction(then)) {\n        then.call(value, function(val) {\n          if (resolved) { return true; }\n          resolved = true;\n\n          if (value !== val) {\n            resolve(promise, val);\n          } else {\n            fulfill(promise, val);\n          }\n        }, function(val) {\n          if (resolved) { return true; }\n          resolved = true;\n\n          reject(promise, val);\n        });\n\n        return true;\n      }\n    }\n  } catch (error) {\n    if (resolved) { return true; }\n    reject(promise, error);\n    return true;\n  }\n\n  return false;\n}\n\nfunction resolve(promise, value) {\n  if (promise === value) {\n    fulfill(promise, value);\n  } else if (!handleThenable(promise, value)) {\n    fulfill(promise, value);\n  }\n}\n\nfunction fulfill(promise, value) {\n  if (promise._state !== PENDING) { return; }\n  promise._state = SEALED;\n  promise._detail = value;\n\n  config.async(publishFulfillment, promise);\n}\n\nfunction reject(promise, reason) {\n  if (promise._state !== PENDING) { return; }\n  promise._state = SEALED;\n  promise._detail = reason;\n\n  config.async(publishRejection, promise);\n}\n\nfunction publishFulfillment(promise) {\n  publish(promise, promise._state = FULFILLED);\n}\n\nfunction publishRejection(promise) {\n  publish(promise, promise._state = REJECTED);\n}\n\nexports.Promise = Promise;","\"use strict\";\n/* global toString */\nvar isArray = require(\"./utils\").isArray;\n\n/**\n  `RSVP.race` allows you to watch a series of promises and act as soon as the\n  first promise given to the `promises` argument fulfills or rejects.\n\n  Example:\n\n  ```javascript\n  var promise1 = new RSVP.Promise(function(resolve, reject){\n    setTimeout(function(){\n      resolve(\"promise 1\");\n    }, 200);\n  });\n\n  var promise2 = new RSVP.Promise(function(resolve, reject){\n    setTimeout(function(){\n      resolve(\"promise 2\");\n    }, 100);\n  });\n\n  RSVP.race([promise1, promise2]).then(function(result){\n    // result === \"promise 2\" because it was resolved before promise1\n    // was resolved.\n  });\n  ```\n\n  `RSVP.race` is deterministic in that only the state of the first completed\n  promise matters. For example, even if other promises given to the `promises`\n  array argument are resolved, but the first completed promise has become\n  rejected before the other promises became fulfilled, the returned promise\n  will become rejected:\n\n  ```javascript\n  var promise1 = new RSVP.Promise(function(resolve, reject){\n    setTimeout(function(){\n      resolve(\"promise 1\");\n    }, 200);\n  });\n\n  var promise2 = new RSVP.Promise(function(resolve, reject){\n    setTimeout(function(){\n      reject(new Error(\"promise 2\"));\n    }, 100);\n  });\n\n  RSVP.race([promise1, promise2]).then(function(result){\n    // Code here never runs because there are rejected promises!\n  }, function(reason){\n    // reason.message === \"promise2\" because promise 2 became rejected before\n    // promise 1 became fulfilled\n  });\n  ```\n\n  @method race\n  @for RSVP\n  @param {Array} promises array of promises to observe\n  @param {String} label optional string for describing the promise returned.\n  Useful for tooling.\n  @return {Promise} a promise that becomes fulfilled with the value the first\n  completed promises is resolved with if the first completed promise was\n  fulfilled, or rejected with the reason that the first completed promise\n  was rejected with.\n*/\nfunction race(promises) {\n  /*jshint validthis:true */\n  var Promise = this;\n\n  if (!isArray(promises)) {\n    throw new TypeError('You must pass an array to race.');\n  }\n  return new Promise(function(resolve, reject) {\n    var results = [], promise;\n\n    for (var i = 0; i < promises.length; i++) {\n      promise = promises[i];\n\n      if (promise && typeof promise.then === 'function') {\n        promise.then(resolve, reject);\n      } else {\n        resolve(promise);\n      }\n    }\n  });\n}\n\nexports.race = race;","\"use strict\";\n/**\n  `RSVP.reject` returns a promise that will become rejected with the passed\n  `reason`. `RSVP.reject` is essentially shorthand for the following:\n\n  ```javascript\n  var promise = new RSVP.Promise(function(resolve, reject){\n    reject(new Error('WHOOPS'));\n  });\n\n  promise.then(function(value){\n    // Code here doesn't run because the promise is rejected!\n  }, function(reason){\n    // reason.message === 'WHOOPS'\n  });\n  ```\n\n  Instead of writing the above, your code now simply becomes the following:\n\n  ```javascript\n  var promise = RSVP.reject(new Error('WHOOPS'));\n\n  promise.then(function(value){\n    // Code here doesn't run because the promise is rejected!\n  }, function(reason){\n    // reason.message === 'WHOOPS'\n  });\n  ```\n\n  @method reject\n  @for RSVP\n  @param {Any} reason value that the returned promise will be rejected with.\n  @param {String} label optional string for identifying the returned promise.\n  Useful for tooling.\n  @return {Promise} a promise that will become rejected with the given\n  `reason`.\n*/\nfunction reject(reason) {\n  /*jshint validthis:true */\n  var Promise = this;\n\n  return new Promise(function (resolve, reject) {\n    reject(reason);\n  });\n}\n\nexports.reject = reject;","\"use strict\";\n/**\n  `RSVP.resolve` returns a promise that will become fulfilled with the passed\n  `value`. `RSVP.resolve` is essentially shorthand for the following:\n\n  ```javascript\n  var promise = new RSVP.Promise(function(resolve, reject){\n    resolve(1);\n  });\n\n  promise.then(function(value){\n    // value === 1\n  });\n  ```\n\n  Instead of writing the above, your code now simply becomes the following:\n\n  ```javascript\n  var promise = RSVP.resolve(1);\n\n  promise.then(function(value){\n    // value === 1\n  });\n  ```\n\n  @method resolve\n  @for RSVP\n  @param {Any} value value that the returned promise will be resolved with\n  @param {String} label optional string for identifying the returned promise.\n  Useful for tooling.\n  @return {Promise} a promise that will become fulfilled with the given\n  `value`\n*/\nfunction resolve(value) {\n  /*jshint validthis:true */\n  var Promise = this;\n  return new Promise(function(resolve, reject) {\n    resolve(value);\n  });\n}\n\nexports.resolve = resolve;","\"use strict\";\nfunction objectOrFunction(x) {\n  return isFunction(x) || (typeof x === \"object\" && x !== null);\n}\n\nfunction isFunction(x) {\n  return typeof x === \"function\";\n}\n\nfunction isArray(x) {\n  return Object.prototype.toString.call(x) === \"[object Array]\";\n}\n\n// Date.now is not available in browsers < IE9\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/now#Compatibility\nvar now = Date.now || function() { return new Date().getTime(); };\n\n\nexports.objectOrFunction = objectOrFunction;\nexports.isFunction = isFunction;\nexports.isArray = isArray;\nexports.now = now;","/* -*- mode: javascript; c-basic-offset: 4; indent-tabs-mode: nil -*- */\n\n// \n// Javascript ZLib\n// By Thomas Down 2010-2011\n//\n// Based very heavily on portions of jzlib (by ymnk@jcraft.com), who in\n// turn credits Jean-loup Gailly and Mark Adler for the original zlib code.\n//\n// inflate.js: ZLib inflate code\n//\n\n//\n// Shared constants\n//\n\nvar MAX_WBITS=15; // 32K LZ77 window\nvar DEF_WBITS=MAX_WBITS;\nvar MAX_MEM_LEVEL=9;\nvar MANY=1440;\nvar BMAX = 15;\n\n// preset dictionary flag in zlib header\nvar PRESET_DICT=0x20;\n\nvar Z_NO_FLUSH=0;\nvar Z_PARTIAL_FLUSH=1;\nvar Z_SYNC_FLUSH=2;\nvar Z_FULL_FLUSH=3;\nvar Z_FINISH=4;\n\nvar Z_DEFLATED=8;\n\nvar Z_OK=0;\nvar Z_STREAM_END=1;\nvar Z_NEED_DICT=2;\nvar Z_ERRNO=-1;\nvar Z_STREAM_ERROR=-2;\nvar Z_DATA_ERROR=-3;\nvar Z_MEM_ERROR=-4;\nvar Z_BUF_ERROR=-5;\nvar Z_VERSION_ERROR=-6;\n\nvar METHOD=0;   // waiting for method byte\nvar FLAG=1;     // waiting for flag byte\nvar DICT4=2;    // four dictionary check bytes to go\nvar DICT3=3;    // three dictionary check bytes to go\nvar DICT2=4;    // two dictionary check bytes to go\nvar DICT1=5;    // one dictionary check byte to go\nvar DICT0=6;    // waiting for inflateSetDictionary\nvar BLOCKS=7;   // decompressing blocks\nvar CHECK4=8;   // four check bytes to go\nvar CHECK3=9;   // three check bytes to go\nvar CHECK2=10;  // two check bytes to go\nvar CHECK1=11;  // one check byte to go\nvar DONE=12;    // finished check, done\nvar BAD=13;     // got an error--stay here\n\nvar inflate_mask = [0x00000000, 0x00000001, 0x00000003, 0x00000007, 0x0000000f, 0x0000001f, 0x0000003f, 0x0000007f, 0x000000ff, 0x000001ff, 0x000003ff, 0x000007ff, 0x00000fff, 0x00001fff, 0x00003fff, 0x00007fff, 0x0000ffff];\n\nvar IB_TYPE=0;  // get type bits (3, including end bit)\nvar IB_LENS=1;  // get lengths for stored\nvar IB_STORED=2;// processing stored block\nvar IB_TABLE=3; // get table lengths\nvar IB_BTREE=4; // get bit lengths tree for a dynamic block\nvar IB_DTREE=5; // get length, distance trees for a dynamic block\nvar IB_CODES=6; // processing fixed or dynamic block\nvar IB_DRY=7;   // output remaining window bytes\nvar IB_DONE=8;  // finished last block, done\nvar IB_BAD=9;   // ot a data error--stuck here\n\nvar fixed_bl = 9;\nvar fixed_bd = 5;\n\nvar fixed_tl = [\n    96,7,256, 0,8,80, 0,8,16, 84,8,115,\n    82,7,31, 0,8,112, 0,8,48, 0,9,192,\n    80,7,10, 0,8,96, 0,8,32, 0,9,160,\n    0,8,0, 0,8,128, 0,8,64, 0,9,224,\n    80,7,6, 0,8,88, 0,8,24, 0,9,144,\n    83,7,59, 0,8,120, 0,8,56, 0,9,208,\n    81,7,17, 0,8,104, 0,8,40, 0,9,176,\n    0,8,8, 0,8,136, 0,8,72, 0,9,240,\n    80,7,4, 0,8,84, 0,8,20, 85,8,227,\n    83,7,43, 0,8,116, 0,8,52, 0,9,200,\n    81,7,13, 0,8,100, 0,8,36, 0,9,168,\n    0,8,4, 0,8,132, 0,8,68, 0,9,232,\n    80,7,8, 0,8,92, 0,8,28, 0,9,152,\n    84,7,83, 0,8,124, 0,8,60, 0,9,216,\n    82,7,23, 0,8,108, 0,8,44, 0,9,184,\n    0,8,12, 0,8,140, 0,8,76, 0,9,248,\n    80,7,3, 0,8,82, 0,8,18, 85,8,163,\n    83,7,35, 0,8,114, 0,8,50, 0,9,196,\n    81,7,11, 0,8,98, 0,8,34, 0,9,164,\n    0,8,2, 0,8,130, 0,8,66, 0,9,228,\n    80,7,7, 0,8,90, 0,8,26, 0,9,148,\n    84,7,67, 0,8,122, 0,8,58, 0,9,212,\n    82,7,19, 0,8,106, 0,8,42, 0,9,180,\n    0,8,10, 0,8,138, 0,8,74, 0,9,244,\n    80,7,5, 0,8,86, 0,8,22, 192,8,0,\n    83,7,51, 0,8,118, 0,8,54, 0,9,204,\n    81,7,15, 0,8,102, 0,8,38, 0,9,172,\n    0,8,6, 0,8,134, 0,8,70, 0,9,236,\n    80,7,9, 0,8,94, 0,8,30, 0,9,156,\n    84,7,99, 0,8,126, 0,8,62, 0,9,220,\n    82,7,27, 0,8,110, 0,8,46, 0,9,188,\n    0,8,14, 0,8,142, 0,8,78, 0,9,252,\n    96,7,256, 0,8,81, 0,8,17, 85,8,131,\n    82,7,31, 0,8,113, 0,8,49, 0,9,194,\n    80,7,10, 0,8,97, 0,8,33, 0,9,162,\n    0,8,1, 0,8,129, 0,8,65, 0,9,226,\n    80,7,6, 0,8,89, 0,8,25, 0,9,146,\n    83,7,59, 0,8,121, 0,8,57, 0,9,210,\n    81,7,17, 0,8,105, 0,8,41, 0,9,178,\n    0,8,9, 0,8,137, 0,8,73, 0,9,242,\n    80,7,4, 0,8,85, 0,8,21, 80,8,258,\n    83,7,43, 0,8,117, 0,8,53, 0,9,202,\n    81,7,13, 0,8,101, 0,8,37, 0,9,170,\n    0,8,5, 0,8,133, 0,8,69, 0,9,234,\n    80,7,8, 0,8,93, 0,8,29, 0,9,154,\n    84,7,83, 0,8,125, 0,8,61, 0,9,218,\n    82,7,23, 0,8,109, 0,8,45, 0,9,186,\n    0,8,13, 0,8,141, 0,8,77, 0,9,250,\n    80,7,3, 0,8,83, 0,8,19, 85,8,195,\n    83,7,35, 0,8,115, 0,8,51, 0,9,198,\n    81,7,11, 0,8,99, 0,8,35, 0,9,166,\n    0,8,3, 0,8,131, 0,8,67, 0,9,230,\n    80,7,7, 0,8,91, 0,8,27, 0,9,150,\n    84,7,67, 0,8,123, 0,8,59, 0,9,214,\n    82,7,19, 0,8,107, 0,8,43, 0,9,182,\n    0,8,11, 0,8,139, 0,8,75, 0,9,246,\n    80,7,5, 0,8,87, 0,8,23, 192,8,0,\n    83,7,51, 0,8,119, 0,8,55, 0,9,206,\n    81,7,15, 0,8,103, 0,8,39, 0,9,174,\n    0,8,7, 0,8,135, 0,8,71, 0,9,238,\n    80,7,9, 0,8,95, 0,8,31, 0,9,158,\n    84,7,99, 0,8,127, 0,8,63, 0,9,222,\n    82,7,27, 0,8,111, 0,8,47, 0,9,190,\n    0,8,15, 0,8,143, 0,8,79, 0,9,254,\n    96,7,256, 0,8,80, 0,8,16, 84,8,115,\n    82,7,31, 0,8,112, 0,8,48, 0,9,193,\n\n    80,7,10, 0,8,96, 0,8,32, 0,9,161,\n    0,8,0, 0,8,128, 0,8,64, 0,9,225,\n    80,7,6, 0,8,88, 0,8,24, 0,9,145,\n    83,7,59, 0,8,120, 0,8,56, 0,9,209,\n    81,7,17, 0,8,104, 0,8,40, 0,9,177,\n    0,8,8, 0,8,136, 0,8,72, 0,9,241,\n    80,7,4, 0,8,84, 0,8,20, 85,8,227,\n    83,7,43, 0,8,116, 0,8,52, 0,9,201,\n    81,7,13, 0,8,100, 0,8,36, 0,9,169,\n    0,8,4, 0,8,132, 0,8,68, 0,9,233,\n    80,7,8, 0,8,92, 0,8,28, 0,9,153,\n    84,7,83, 0,8,124, 0,8,60, 0,9,217,\n    82,7,23, 0,8,108, 0,8,44, 0,9,185,\n    0,8,12, 0,8,140, 0,8,76, 0,9,249,\n    80,7,3, 0,8,82, 0,8,18, 85,8,163,\n    83,7,35, 0,8,114, 0,8,50, 0,9,197,\n    81,7,11, 0,8,98, 0,8,34, 0,9,165,\n    0,8,2, 0,8,130, 0,8,66, 0,9,229,\n    80,7,7, 0,8,90, 0,8,26, 0,9,149,\n    84,7,67, 0,8,122, 0,8,58, 0,9,213,\n    82,7,19, 0,8,106, 0,8,42, 0,9,181,\n    0,8,10, 0,8,138, 0,8,74, 0,9,245,\n    80,7,5, 0,8,86, 0,8,22, 192,8,0,\n    83,7,51, 0,8,118, 0,8,54, 0,9,205,\n    81,7,15, 0,8,102, 0,8,38, 0,9,173,\n    0,8,6, 0,8,134, 0,8,70, 0,9,237,\n    80,7,9, 0,8,94, 0,8,30, 0,9,157,\n    84,7,99, 0,8,126, 0,8,62, 0,9,221,\n    82,7,27, 0,8,110, 0,8,46, 0,9,189,\n    0,8,14, 0,8,142, 0,8,78, 0,9,253,\n    96,7,256, 0,8,81, 0,8,17, 85,8,131,\n    82,7,31, 0,8,113, 0,8,49, 0,9,195,\n    80,7,10, 0,8,97, 0,8,33, 0,9,163,\n    0,8,1, 0,8,129, 0,8,65, 0,9,227,\n    80,7,6, 0,8,89, 0,8,25, 0,9,147,\n    83,7,59, 0,8,121, 0,8,57, 0,9,211,\n    81,7,17, 0,8,105, 0,8,41, 0,9,179,\n    0,8,9, 0,8,137, 0,8,73, 0,9,243,\n    80,7,4, 0,8,85, 0,8,21, 80,8,258,\n    83,7,43, 0,8,117, 0,8,53, 0,9,203,\n    81,7,13, 0,8,101, 0,8,37, 0,9,171,\n    0,8,5, 0,8,133, 0,8,69, 0,9,235,\n    80,7,8, 0,8,93, 0,8,29, 0,9,155,\n    84,7,83, 0,8,125, 0,8,61, 0,9,219,\n    82,7,23, 0,8,109, 0,8,45, 0,9,187,\n    0,8,13, 0,8,141, 0,8,77, 0,9,251,\n    80,7,3, 0,8,83, 0,8,19, 85,8,195,\n    83,7,35, 0,8,115, 0,8,51, 0,9,199,\n    81,7,11, 0,8,99, 0,8,35, 0,9,167,\n    0,8,3, 0,8,131, 0,8,67, 0,9,231,\n    80,7,7, 0,8,91, 0,8,27, 0,9,151,\n    84,7,67, 0,8,123, 0,8,59, 0,9,215,\n    82,7,19, 0,8,107, 0,8,43, 0,9,183,\n    0,8,11, 0,8,139, 0,8,75, 0,9,247,\n    80,7,5, 0,8,87, 0,8,23, 192,8,0,\n    83,7,51, 0,8,119, 0,8,55, 0,9,207,\n    81,7,15, 0,8,103, 0,8,39, 0,9,175,\n    0,8,7, 0,8,135, 0,8,71, 0,9,239,\n    80,7,9, 0,8,95, 0,8,31, 0,9,159,\n    84,7,99, 0,8,127, 0,8,63, 0,9,223,\n    82,7,27, 0,8,111, 0,8,47, 0,9,191,\n    0,8,15, 0,8,143, 0,8,79, 0,9,255\n];\nvar fixed_td = [\n    80,5,1, 87,5,257, 83,5,17, 91,5,4097,\n    81,5,5, 89,5,1025, 85,5,65, 93,5,16385,\n    80,5,3, 88,5,513, 84,5,33, 92,5,8193,\n    82,5,9, 90,5,2049, 86,5,129, 192,5,24577,\n    80,5,2, 87,5,385, 83,5,25, 91,5,6145,\n    81,5,7, 89,5,1537, 85,5,97, 93,5,24577,\n    80,5,4, 88,5,769, 84,5,49, 92,5,12289,\n    82,5,13, 90,5,3073, 86,5,193, 192,5,24577\n];\n\n  // Tables for deflate from PKZIP's appnote.txt.\n  var cplens = [ // Copy lengths for literal codes 257..285\n        3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,\n        35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0\n  ];\n\n  // see note #13 above about 258\n  var cplext = [ // Extra bits for literal codes 257..285\n        0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2,\n        3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 112, 112  // 112==invalid\n  ];\n\n var cpdist = [ // Copy offsets for distance codes 0..29\n        1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,\n        257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,\n        8193, 12289, 16385, 24577\n  ];\n\n  var cpdext = [ // Extra bits for distance codes\n        0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6,\n        7, 7, 8, 8, 9, 9, 10, 10, 11, 11,\n        12, 12, 13, 13];\n\n//\n// ZStream.java\n//\n\nfunction ZStream() {\n}\n\n\nZStream.prototype.inflateInit = function(w, nowrap) {\n    if (!w) {\n\tw = DEF_WBITS;\n    }\n    if (nowrap) {\n\tnowrap = false;\n    }\n    this.istate = new Inflate();\n    return this.istate.inflateInit(this, nowrap?-w:w);\n}\n\nZStream.prototype.inflate = function(f) {\n    if(this.istate==null) return Z_STREAM_ERROR;\n    return this.istate.inflate(this, f);\n}\n\nZStream.prototype.inflateEnd = function(){\n    if(this.istate==null) return Z_STREAM_ERROR;\n    var ret=istate.inflateEnd(this);\n    this.istate = null;\n    return ret;\n}\nZStream.prototype.inflateSync = function(){\n    // if(istate == null) return Z_STREAM_ERROR;\n    return istate.inflateSync(this);\n}\nZStream.prototype.inflateSetDictionary = function(dictionary, dictLength){\n    // if(istate == null) return Z_STREAM_ERROR;\n    return istate.inflateSetDictionary(this, dictionary, dictLength);\n}\n\n/*\n\n  public int deflateInit(int level){\n    return deflateInit(level, MAX_WBITS);\n  }\n  public int deflateInit(int level, boolean nowrap){\n    return deflateInit(level, MAX_WBITS, nowrap);\n  }\n  public int deflateInit(int level, int bits){\n    return deflateInit(level, bits, false);\n  }\n  public int deflateInit(int level, int bits, boolean nowrap){\n    dstate=new Deflate();\n    return dstate.deflateInit(this, level, nowrap?-bits:bits);\n  }\n  public int deflate(int flush){\n    if(dstate==null){\n      return Z_STREAM_ERROR;\n    }\n    return dstate.deflate(this, flush);\n  }\n  public int deflateEnd(){\n    if(dstate==null) return Z_STREAM_ERROR;\n    int ret=dstate.deflateEnd();\n    dstate=null;\n    return ret;\n  }\n  public int deflateParams(int level, int strategy){\n    if(dstate==null) return Z_STREAM_ERROR;\n    return dstate.deflateParams(this, level, strategy);\n  }\n  public int deflateSetDictionary (byte[] dictionary, int dictLength){\n    if(dstate == null)\n      return Z_STREAM_ERROR;\n    return dstate.deflateSetDictionary(this, dictionary, dictLength);\n  }\n\n*/\n\n/*\n  // Flush as much pending output as possible. All deflate() output goes\n  // through this function so some applications may wish to modify it\n  // to avoid allocating a large strm->next_out buffer and copying into it.\n  // (See also read_buf()).\n  void flush_pending(){\n    int len=dstate.pending;\n\n    if(len>avail_out) len=avail_out;\n    if(len==0) return;\n\n    if(dstate.pending_buf.length<=dstate.pending_out ||\n       next_out.length<=next_out_index ||\n       dstate.pending_buf.length<(dstate.pending_out+len) ||\n       next_out.length<(next_out_index+len)){\n      System.out.println(dstate.pending_buf.length+\", \"+dstate.pending_out+\n\t\t\t \", \"+next_out.length+\", \"+next_out_index+\", \"+len);\n      System.out.println(\"avail_out=\"+avail_out);\n    }\n\n    System.arraycopy(dstate.pending_buf, dstate.pending_out,\n\t\t     next_out, next_out_index, len);\n\n    next_out_index+=len;\n    dstate.pending_out+=len;\n    total_out+=len;\n    avail_out-=len;\n    dstate.pending-=len;\n    if(dstate.pending==0){\n      dstate.pending_out=0;\n    }\n  }\n\n  // Read a new buffer from the current input stream, update the adler32\n  // and total number of bytes read.  All deflate() input goes through\n  // this function so some applications may wish to modify it to avoid\n  // allocating a large strm->next_in buffer and copying from it.\n  // (See also flush_pending()).\n  int read_buf(byte[] buf, int start, int size) {\n    int len=avail_in;\n\n    if(len>size) len=size;\n    if(len==0) return 0;\n\n    avail_in-=len;\n\n    if(dstate.noheader==0) {\n      adler=_adler.adler32(adler, next_in, next_in_index, len);\n    }\n    System.arraycopy(next_in, next_in_index, buf, start, len);\n    next_in_index  += len;\n    total_in += len;\n    return len;\n  }\n\n  public void free(){\n    next_in=null;\n    next_out=null;\n    msg=null;\n    _adler=null;\n  }\n}\n*/\n\n\n//\n// Inflate.java\n//\n\nfunction Inflate() {\n    this.was = [0];\n}\n\nInflate.prototype.inflateReset = function(z) {\n    if(z == null || z.istate == null) return Z_STREAM_ERROR;\n    \n    z.total_in = z.total_out = 0;\n    z.msg = null;\n    z.istate.mode = z.istate.nowrap!=0 ? BLOCKS : METHOD;\n    z.istate.blocks.reset(z, null);\n    return Z_OK;\n}\n\nInflate.prototype.inflateEnd = function(z){\n    if(this.blocks != null)\n      this.blocks.free(z);\n    this.blocks=null;\n    return Z_OK;\n}\n\nInflate.prototype.inflateInit = function(z, w){\n    z.msg = null;\n    this.blocks = null;\n\n    // handle undocumented nowrap option (no zlib header or check)\n    nowrap = 0;\n    if(w < 0){\n      w = - w;\n      nowrap = 1;\n    }\n\n    // set window size\n    if(w<8 ||w>15){\n      this.inflateEnd(z);\n      return Z_STREAM_ERROR;\n    }\n    this.wbits=w;\n\n    z.istate.blocks=new InfBlocks(z, \n\t\t\t\t  z.istate.nowrap!=0 ? null : this,\n\t\t\t\t  1<<w);\n\n    // reset state\n    this.inflateReset(z);\n    return Z_OK;\n  }\n\nInflate.prototype.inflate = function(z, f){\n    var r, b;\n\n    if(z == null || z.istate == null || z.next_in == null)\n      return Z_STREAM_ERROR;\n    f = f == Z_FINISH ? Z_BUF_ERROR : Z_OK;\n    r = Z_BUF_ERROR;\n    while (true){\n      switch (z.istate.mode){\n      case METHOD:\n\n        if(z.avail_in==0)return r;r=f;\n\n        z.avail_in--; z.total_in++;\n        if(((z.istate.method = z.next_in[z.next_in_index++])&0xf)!=Z_DEFLATED){\n          z.istate.mode = BAD;\n          z.msg=\"unknown compression method\";\n          z.istate.marker = 5;       // can't try inflateSync\n          break;\n        }\n        if((z.istate.method>>4)+8>z.istate.wbits){\n          z.istate.mode = BAD;\n          z.msg=\"invalid window size\";\n          z.istate.marker = 5;       // can't try inflateSync\n          break;\n        }\n        z.istate.mode=FLAG;\n      case FLAG:\n\n        if(z.avail_in==0)return r;r=f;\n\n        z.avail_in--; z.total_in++;\n        b = (z.next_in[z.next_in_index++])&0xff;\n\n        if((((z.istate.method << 8)+b) % 31)!=0){\n          z.istate.mode = BAD;\n          z.msg = \"incorrect header check\";\n          z.istate.marker = 5;       // can't try inflateSync\n          break;\n        }\n\n        if((b&PRESET_DICT)==0){\n          z.istate.mode = BLOCKS;\n          break;\n        }\n        z.istate.mode = DICT4;\n      case DICT4:\n\n        if(z.avail_in==0)return r;r=f;\n\n        z.avail_in--; z.total_in++;\n        z.istate.need=((z.next_in[z.next_in_index++]&0xff)<<24)&0xff000000;\n        z.istate.mode=DICT3;\n      case DICT3:\n\n        if(z.avail_in==0)return r;r=f;\n\n        z.avail_in--; z.total_in++;\n        z.istate.need+=((z.next_in[z.next_in_index++]&0xff)<<16)&0xff0000;\n        z.istate.mode=DICT2;\n      case DICT2:\n\n        if(z.avail_in==0)return r;r=f;\n\n        z.avail_in--; z.total_in++;\n        z.istate.need+=((z.next_in[z.next_in_index++]&0xff)<<8)&0xff00;\n        z.istate.mode=DICT1;\n      case DICT1:\n\n        if(z.avail_in==0)return r;r=f;\n\n        z.avail_in--; z.total_in++;\n        z.istate.need += (z.next_in[z.next_in_index++]&0xff);\n        z.adler = z.istate.need;\n        z.istate.mode = DICT0;\n        return Z_NEED_DICT;\n      case DICT0:\n        z.istate.mode = BAD;\n        z.msg = \"need dictionary\";\n        z.istate.marker = 0;       // can try inflateSync\n        return Z_STREAM_ERROR;\n      case BLOCKS:\n\n        r = z.istate.blocks.proc(z, r);\n        if(r == Z_DATA_ERROR){\n          z.istate.mode = BAD;\n          z.istate.marker = 0;     // can try inflateSync\n          break;\n        }\n        if(r == Z_OK){\n          r = f;\n        }\n        if(r != Z_STREAM_END){\n          return r;\n        }\n        r = f;\n        z.istate.blocks.reset(z, z.istate.was);\n        if(z.istate.nowrap!=0){\n          z.istate.mode=DONE;\n          break;\n        }\n        z.istate.mode=CHECK4;\n      case CHECK4:\n\n        if(z.avail_in==0)return r;r=f;\n\n        z.avail_in--; z.total_in++;\n        z.istate.need=((z.next_in[z.next_in_index++]&0xff)<<24)&0xff000000;\n        z.istate.mode=CHECK3;\n      case CHECK3:\n\n        if(z.avail_in==0)return r;r=f;\n\n        z.avail_in--; z.total_in++;\n        z.istate.need+=((z.next_in[z.next_in_index++]&0xff)<<16)&0xff0000;\n        z.istate.mode = CHECK2;\n      case CHECK2:\n\n        if(z.avail_in==0)return r;r=f;\n\n        z.avail_in--; z.total_in++;\n        z.istate.need+=((z.next_in[z.next_in_index++]&0xff)<<8)&0xff00;\n        z.istate.mode = CHECK1;\n      case CHECK1:\n\n        if(z.avail_in==0)return r;r=f;\n\n        z.avail_in--; z.total_in++;\n        z.istate.need+=(z.next_in[z.next_in_index++]&0xff);\n\n        if(((z.istate.was[0])) != ((z.istate.need))){\n          z.istate.mode = BAD;\n          z.msg = \"incorrect data check\";\n          z.istate.marker = 5;       // can't try inflateSync\n          break;\n        }\n\n        z.istate.mode = DONE;\n      case DONE:\n        return Z_STREAM_END;\n      case BAD:\n        return Z_DATA_ERROR;\n      default:\n        return Z_STREAM_ERROR;\n      }\n    }\n  }\n\n\nInflate.prototype.inflateSetDictionary = function(z,  dictionary, dictLength) {\n    var index=0;\n    var length = dictLength;\n    if(z==null || z.istate == null|| z.istate.mode != DICT0)\n      return Z_STREAM_ERROR;\n\n    if(z._adler.adler32(1, dictionary, 0, dictLength)!=z.adler){\n      return Z_DATA_ERROR;\n    }\n\n    z.adler = z._adler.adler32(0, null, 0, 0);\n\n    if(length >= (1<<z.istate.wbits)){\n      length = (1<<z.istate.wbits)-1;\n      index=dictLength - length;\n    }\n    z.istate.blocks.set_dictionary(dictionary, index, length);\n    z.istate.mode = BLOCKS;\n    return Z_OK;\n  }\n\n//  static private byte[] mark = {(byte)0, (byte)0, (byte)0xff, (byte)0xff};\nvar mark = [0, 0, 255, 255]\n\nInflate.prototype.inflateSync = function(z){\n    var n;       // number of bytes to look at\n    var p;       // pointer to bytes\n    var m;       // number of marker bytes found in a row\n    var r, w;   // temporaries to save total_in and total_out\n\n    // set up\n    if(z == null || z.istate == null)\n      return Z_STREAM_ERROR;\n    if(z.istate.mode != BAD){\n      z.istate.mode = BAD;\n      z.istate.marker = 0;\n    }\n    if((n=z.avail_in)==0)\n      return Z_BUF_ERROR;\n    p=z.next_in_index;\n    m=z.istate.marker;\n\n    // search\n    while (n!=0 && m < 4){\n      if(z.next_in[p] == mark[m]){\n        m++;\n      }\n      else if(z.next_in[p]!=0){\n        m = 0;\n      }\n      else{\n        m = 4 - m;\n      }\n      p++; n--;\n    }\n\n    // restore\n    z.total_in += p-z.next_in_index;\n    z.next_in_index = p;\n    z.avail_in = n;\n    z.istate.marker = m;\n\n    // return no joy or set up to restart on a new block\n    if(m != 4){\n      return Z_DATA_ERROR;\n    }\n    r=z.total_in;  w=z.total_out;\n    this.inflateReset(z);\n    z.total_in=r;  z.total_out = w;\n    z.istate.mode = BLOCKS;\n    return Z_OK;\n}\n\n  // Returns true if inflate is currently at the end of a block generated\n  // by Z_SYNC_FLUSH or Z_FULL_FLUSH. This function is used by one PPP\n  // implementation to provide an additional safety check. PPP uses Z_SYNC_FLUSH\n  // but removes the length bytes of the resulting empty stored block. When\n  // decompressing, PPP checks that at the end of input packet, inflate is\n  // waiting for these length bytes.\nInflate.prototype.inflateSyncPoint = function(z){\n    if(z == null || z.istate == null || z.istate.blocks == null)\n      return Z_STREAM_ERROR;\n    return z.istate.blocks.sync_point();\n}\n\n\n//\n// InfBlocks.java\n//\n\nvar INFBLOCKS_BORDER = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];\n\nfunction InfBlocks(z, checkfn, w) {\n    this.hufts=new Int32Array(MANY*3);\n    this.window=new Uint8Array(w);\n    this.end=w;\n    this.checkfn = checkfn;\n    this.mode = IB_TYPE;\n    this.reset(z, null);\n\n    this.left = 0;            // if STORED, bytes left to copy \n\n    this.table = 0;           // table lengths (14 bits) \n    this.index = 0;           // index into blens (or border) \n    this.blens = null;         // bit lengths of codes \n    this.bb=new Int32Array(1); // bit length tree depth \n    this.tb=new Int32Array(1); // bit length decoding tree \n\n    this.codes = new InfCodes();\n\n    this.last = 0;            // true if this block is the last block \n\n  // mode independent information \n    this.bitk = 0;            // bits in bit buffer \n    this.bitb = 0;            // bit buffer \n    this.read = 0;            // window read pointer \n    this.write = 0;           // window write pointer \n    this.check = 0;          // check on output \n\n    this.inftree=new InfTree();\n}\n\n\n\n\nInfBlocks.prototype.reset = function(z, c){\n    if(c) c[0]=this.check;\n    if(this.mode==IB_CODES){\n      this.codes.free(z);\n    }\n    this.mode=IB_TYPE;\n    this.bitk=0;\n    this.bitb=0;\n    this.read=this.write=0;\n\n    if(this.checkfn)\n      z.adler=this.check=z._adler.adler32(0, null, 0, 0);\n  }\n\n InfBlocks.prototype.proc = function(z, r){\n    var t;              // temporary storage\n    var b;              // bit buffer\n    var k;              // bits in bit buffer\n    var p;              // input data pointer\n    var n;              // bytes available there\n    var q;              // output window write pointer\n    var m;              // bytes to end of window or read pointer\n\n    // copy input/output information to locals (UPDATE macro restores)\n    {p=z.next_in_index;n=z.avail_in;b=this.bitb;k=this.bitk;}\n    {q=this.write;m=(q<this.read ? this.read-q-1 : this.end-q);}\n\n    // process input based on current state\n    while(true){\n      switch (this.mode){\n      case IB_TYPE:\n\n\twhile(k<(3)){\n\t  if(n!=0){\n\t    r=Z_OK;\n\t  }\n\t  else{\n\t    this.bitb=b; this.bitk=k; \n\t    z.avail_in=n;\n\t    z.total_in+=p-z.next_in_index;z.next_in_index=p;\n\t    this.write=q;\n\t    return this.inflate_flush(z,r);\n\t  };\n\t  n--;\n\t  b|=(z.next_in[p++]&0xff)<<k;\n\t  k+=8;\n\t}\n\tt = (b & 7);\n\tthis.last = t & 1;\n\n\tswitch (t >>> 1){\n        case 0:                         // stored \n          {b>>>=(3);k-=(3);}\n          t = k & 7;                    // go to byte boundary\n\n          {b>>>=(t);k-=(t);}\n          this.mode = IB_LENS;                  // get length of stored block\n          break;\n        case 1:                         // fixed\n          {\n              var bl=new Int32Array(1);\n\t      var bd=new Int32Array(1);\n              var tl=[];\n\t      var td=[];\n\n\t      inflate_trees_fixed(bl, bd, tl, td, z);\n              this.codes.init(bl[0], bd[0], tl[0], 0, td[0], 0, z);\n          }\n\n          {b>>>=(3);k-=(3);}\n\n          this.mode = IB_CODES;\n          break;\n        case 2:                         // dynamic\n\n          {b>>>=(3);k-=(3);}\n\n          this.mode = IB_TABLE;\n          break;\n        case 3:                         // illegal\n\n          {b>>>=(3);k-=(3);}\n          this.mode = BAD;\n          z.msg = \"invalid block type\";\n          r = Z_DATA_ERROR;\n\n\t  this.bitb=b; this.bitk=k; \n\t  z.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;\n\t  this.write=q;\n\t  return this.inflate_flush(z,r);\n\t}\n\tbreak;\n      case IB_LENS:\n\twhile(k<(32)){\n\t  if(n!=0){\n\t    r=Z_OK;\n\t  }\n\t  else{\n\t    this.bitb=b; this.bitk=k; \n\t    z.avail_in=n;\n\t    z.total_in+=p-z.next_in_index;z.next_in_index=p;\n\t    this.write=q;\n\t    return this.inflate_flush(z,r);\n\t  };\n\t  n--;\n\t  b|=(z.next_in[p++]&0xff)<<k;\n\t  k+=8;\n\t}\n\n\tif ((((~b) >>> 16) & 0xffff) != (b & 0xffff)){\n\t  this.mode = BAD;\n\t  z.msg = \"invalid stored block lengths\";\n\t  r = Z_DATA_ERROR;\n\n\t  this.bitb=b; this.bitk=k; \n\t  z.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;\n\t  this.write=q;\n\t  return this.inflate_flush(z,r);\n\t}\n\tthis.left = (b & 0xffff);\n\tb = k = 0;                       // dump bits\n\tthis.mode = this.left!=0 ? IB_STORED : (this.last!=0 ? IB_DRY : IB_TYPE);\n\tbreak;\n      case IB_STORED:\n\tif (n == 0){\n\t  this.bitb=b; this.bitk=k; \n\t  z.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;\n\t  write=q;\n\t  return this.inflate_flush(z,r);\n\t}\n\n\tif(m==0){\n\t  if(q==end&&read!=0){\n\t    q=0; m=(q<this.read ? this.read-q-1 : this.end-q);\n\t  }\n\t  if(m==0){\n\t    this.write=q; \n\t    r=this.inflate_flush(z,r);\n\t    q=this.write; m = (q < this.read ? this.read-q-1 : this.end-q);\n\t    if(q==this.end && this.read != 0){\n\t      q=0; m = (q < this.read ? this.read-q-1 : this.end-q);\n\t    }\n\t    if(m==0){\n\t      this.bitb=b; this.bitk=k; \n\t      z.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;\n\t      this.write=q;\n\t      return this.inflate_flush(z,r);\n\t    }\n\t  }\n\t}\n\tr=Z_OK;\n\n\tt = this.left;\n\tif(t>n) t = n;\n\tif(t>m) t = m;\n\tarrayCopy(z.next_in, p, this.window, q, t);\n\tp += t;  n -= t;\n\tq += t;  m -= t;\n\tif ((this.left -= t) != 0)\n\t  break;\n\tthis.mode = (this.last != 0 ? IB_DRY : IB_TYPE);\n\tbreak;\n      case IB_TABLE:\n\n\twhile(k<(14)){\n\t  if(n!=0){\n\t    r=Z_OK;\n\t  }\n\t  else{\n\t    this.bitb=b; this.bitk=k; \n\t    z.avail_in=n;\n\t    z.total_in+=p-z.next_in_index;z.next_in_index=p;\n\t    this.write=q;\n\t    return this.inflate_flush(z,r);\n\t  };\n\t  n--;\n\t  b|=(z.next_in[p++]&0xff)<<k;\n\t  k+=8;\n\t}\n\n\tthis.table = t = (b & 0x3fff);\n\tif ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)\n\t  {\n\t    this.mode = IB_BAD;\n\t    z.msg = \"too many length or distance symbols\";\n\t    r = Z_DATA_ERROR;\n\n\t    this.bitb=b; this.bitk=k; \n\t    z.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;\n\t    this.write=q;\n\t    return this.inflate_flush(z,r);\n\t  }\n\tt = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);\n\tif(this.blens==null || this.blens.length<t){\n\t    this.blens=new Int32Array(t);\n\t}\n\telse{\n\t  for(var i=0; i<t; i++){\n              this.blens[i]=0;\n          }\n\t}\n\n\t{b>>>=(14);k-=(14);}\n\n\tthis.index = 0;\n\tmode = IB_BTREE;\n      case IB_BTREE:\n\twhile (this.index < 4 + (this.table >>> 10)){\n\t  while(k<(3)){\n\t    if(n!=0){\n\t      r=Z_OK;\n\t    }\n\t    else{\n\t      this.bitb=b; this.bitk=k; \n\t      z.avail_in=n;\n\t      z.total_in+=p-z.next_in_index;z.next_in_index=p;\n\t      this.write=q;\n\t      return this.inflate_flush(z,r);\n\t    };\n\t    n--;\n\t    b|=(z.next_in[p++]&0xff)<<k;\n\t    k+=8;\n\t  }\n\n\t  this.blens[INFBLOCKS_BORDER[this.index++]] = b&7;\n\n\t  {b>>>=(3);k-=(3);}\n\t}\n\n\twhile(this.index < 19){\n\t  this.blens[INFBLOCKS_BORDER[this.index++]] = 0;\n\t}\n\n\tthis.bb[0] = 7;\n\tt = this.inftree.inflate_trees_bits(this.blens, this.bb, this.tb, this.hufts, z);\n\tif (t != Z_OK){\n\t  r = t;\n\t  if (r == Z_DATA_ERROR){\n\t    this.blens=null;\n\t    this.mode = IB_BAD;\n\t  }\n\n\t  this.bitb=b; this.bitk=k; \n\t  z.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;\n\t  write=q;\n\t  return this.inflate_flush(z,r);\n\t}\n\n\tthis.index = 0;\n\tthis.mode = IB_DTREE;\n      case IB_DTREE:\n\twhile (true){\n\t  t = this.table;\n\t  if(!(this.index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))){\n\t    break;\n\t  }\n\n\t  var h; //int[]\n\t  var i, j, c;\n\n\t  t = this.bb[0];\n\n\t  while(k<(t)){\n\t    if(n!=0){\n\t      r=Z_OK;\n\t    }\n\t    else{\n\t      this.bitb=b; this.bitk=k; \n\t      z.avail_in=n;\n\t      z.total_in+=p-z.next_in_index;z.next_in_index=p;\n\t      this.write=q;\n\t      return this.inflate_flush(z,r);\n\t    };\n\t    n--;\n\t    b|=(z.next_in[p++]&0xff)<<k;\n\t    k+=8;\n\t  }\n\n//\t  if (this.tb[0]==-1){\n//            dlog(\"null...\");\n//\t  }\n\n\t  t=this.hufts[(this.tb[0]+(b & inflate_mask[t]))*3+1];\n\t  c=this.hufts[(this.tb[0]+(b & inflate_mask[t]))*3+2];\n\n\t  if (c < 16){\n\t    b>>>=(t);k-=(t);\n\t    this.blens[this.index++] = c;\n\t  }\n\t  else { // c == 16..18\n\t    i = c == 18 ? 7 : c - 14;\n\t    j = c == 18 ? 11 : 3;\n\n\t    while(k<(t+i)){\n\t      if(n!=0){\n\t\tr=Z_OK;\n\t      }\n\t      else{\n\t\tthis.bitb=b; this.bitk=k; \n\t\tz.avail_in=n;\n\t\tz.total_in+=p-z.next_in_index;z.next_in_index=p;\n\t\tthis.write=q;\n\t\treturn this.inflate_flush(z,r);\n\t      };\n\t      n--;\n\t      b|=(z.next_in[p++]&0xff)<<k;\n\t      k+=8;\n\t    }\n\n\t    b>>>=(t);k-=(t);\n\n\t    j += (b & inflate_mask[i]);\n\n\t    b>>>=(i);k-=(i);\n\n\t    i = this.index;\n\t    t = this.table;\n\t    if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) ||\n\t\t(c == 16 && i < 1)){\n\t      this.blens=null;\n\t      this.mode = IB_BAD;\n\t      z.msg = \"invalid bit length repeat\";\n\t      r = Z_DATA_ERROR;\n\n\t      this.bitb=b; this.bitk=k; \n\t      z.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;\n\t      this.write=q;\n\t      return this.inflate_flush(z,r);\n\t    }\n\n\t    c = c == 16 ? this.blens[i-1] : 0;\n\t    do{\n\t      this.blens[i++] = c;\n\t    }\n\t    while (--j!=0);\n\t    this.index = i;\n\t  }\n\t}\n\n\tthis.tb[0]=-1;\n\t{\n\t    var bl=new Int32Array(1);\n\t    var bd=new Int32Array(1);\n\t    var tl=new Int32Array(1);\n\t    var td=new Int32Array(1);\n\t    bl[0] = 9;         // must be <= 9 for lookahead assumptions\n\t    bd[0] = 6;         // must be <= 9 for lookahead assumptions\n\n\t    t = this.table;\n\t    t = this.inftree.inflate_trees_dynamic(257 + (t & 0x1f), \n\t\t\t\t\t      1 + ((t >> 5) & 0x1f),\n\t\t\t\t\t      this.blens, bl, bd, tl, td, this.hufts, z);\n\n\t    if (t != Z_OK){\n\t        if (t == Z_DATA_ERROR){\n\t            this.blens=null;\n\t            this.mode = BAD;\n\t        }\n\t        r = t;\n\n\t        this.bitb=b; this.bitk=k; \n\t        z.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;\n\t        this.write=q;\n\t        return this.inflate_flush(z,r);\n\t    }\n\t    this.codes.init(bl[0], bd[0], this.hufts, tl[0], this.hufts, td[0], z);\n\t}\n\tthis.mode = IB_CODES;\n      case IB_CODES:\n\tthis.bitb=b; this.bitk=k;\n\tz.avail_in=n; z.total_in+=p-z.next_in_index;z.next_in_index=p;\n\tthis.write=q;\n\n\tif ((r = this.codes.proc(this, z, r)) != Z_STREAM_END){\n\t  return this.inflate_flush(z, r);\n\t}\n\tr = Z_OK;\n\tthis.codes.free(z);\n\n\tp=z.next_in_index; n=z.avail_in;b=this.bitb;k=this.bitk;\n\tq=this.write;m = (q < this.read ? this.read-q-1 : this.end-q);\n\n\tif (this.last==0){\n\t  this.mode = IB_TYPE;\n\t  break;\n\t}\n\tthis.mode = IB_DRY;\n      case IB_DRY:\n\tthis.write=q; \n\tr = this.inflate_flush(z, r); \n\tq=this.write; m = (q < this.read ? this.read-q-1 : this.end-q);\n\tif (this.read != this.write){\n\t  this.bitb=b; this.bitk=k; \n\t  z.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;\n\t  this.write=q;\n\t  return this.inflate_flush(z, r);\n\t}\n\tmode = DONE;\n      case IB_DONE:\n\tr = Z_STREAM_END;\n\n\tthis.bitb=b; this.bitk=k; \n\tz.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;\n\tthis.write=q;\n\treturn this.inflate_flush(z, r);\n      case IB_BAD:\n\tr = Z_DATA_ERROR;\n\n\tthis.bitb=b; this.bitk=k; \n\tz.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;\n\tthis.write=q;\n\treturn this.inflate_flush(z, r);\n\n      default:\n\tr = Z_STREAM_ERROR;\n\n\tthis.bitb=b; this.bitk=k; \n\tz.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;\n\tthis.write=q;\n\treturn this.inflate_flush(z, r);\n      }\n    }\n  }\n\nInfBlocks.prototype.free = function(z){\n    this.reset(z, null);\n    this.window=null;\n    this.hufts=null;\n}\n\nInfBlocks.prototype.set_dictionary = function(d, start, n){\n    arrayCopy(d, start, window, 0, n);\n    this.read = this.write = n;\n}\n\n  // Returns true if inflate is currently at the end of a block generated\n  // by Z_SYNC_FLUSH or Z_FULL_FLUSH. \nInfBlocks.prototype.sync_point = function(){\n    return this.mode == IB_LENS;\n}\n\n  // copy as much as possible from the sliding window to the output area\nInfBlocks.prototype.inflate_flush = function(z, r){\n    var n;\n    var p;\n    var q;\n\n    // local copies of source and destination pointers\n    p = z.next_out_index;\n    q = this.read;\n\n    // compute number of bytes to copy as far as end of window\n    n = ((q <= this.write ? this.write : this.end) - q);\n    if (n > z.avail_out) n = z.avail_out;\n    if (n!=0 && r == Z_BUF_ERROR) r = Z_OK;\n\n    // update counters\n    z.avail_out -= n;\n    z.total_out += n;\n\n    // update check information\n    if(this.checkfn != null)\n      z.adler=this.check=z._adler.adler32(this.check, this.window, q, n);\n\n    // copy as far as end of window\n    arrayCopy(this.window, q, z.next_out, p, n);\n    p += n;\n    q += n;\n\n    // see if more to copy at beginning of window\n    if (q == this.end){\n      // wrap pointers\n      q = 0;\n      if (this.write == this.end)\n        this.write = 0;\n\n      // compute bytes to copy\n      n = this.write - q;\n      if (n > z.avail_out) n = z.avail_out;\n      if (n!=0 && r == Z_BUF_ERROR) r = Z_OK;\n\n      // update counters\n      z.avail_out -= n;\n      z.total_out += n;\n\n      // update check information\n      if(this.checkfn != null)\n\tz.adler=this.check=z._adler.adler32(this.check, this.window, q, n);\n\n      // copy\n      arrayCopy(this.window, q, z.next_out, p, n);\n      p += n;\n      q += n;\n    }\n\n    // update pointers\n    z.next_out_index = p;\n    this.read = q;\n\n    // done\n    return r;\n  }\n\n//\n// InfCodes.java\n//\n\nvar IC_START=0;  // x: set up for LEN\nvar IC_LEN=1;    // i: get length/literal/eob next\nvar IC_LENEXT=2; // i: getting length extra (have base)\nvar IC_DIST=3;   // i: get distance next\nvar IC_DISTEXT=4;// i: getting distance extra\nvar IC_COPY=5;   // o: copying bytes in window, waiting for space\nvar IC_LIT=6;    // o: got literal, waiting for output space\nvar IC_WASH=7;   // o: got eob, possibly still output waiting\nvar IC_END=8;    // x: got eob and all data flushed\nvar IC_BADCODE=9;// x: got error\n\nfunction InfCodes() {\n}\n\nInfCodes.prototype.init = function(bl, bd, tl, tl_index, td, td_index, z) {\n    this.mode=IC_START;\n    this.lbits=bl;\n    this.dbits=bd;\n    this.ltree=tl;\n    this.ltree_index=tl_index;\n    this.dtree = td;\n    this.dtree_index=td_index;\n    this.tree=null;\n}\n\nInfCodes.prototype.proc = function(s, z, r){ \n    var j;              // temporary storage\n    var t;              // temporary pointer (int[])\n    var tindex;         // temporary pointer\n    var e;              // extra bits or operation\n    var b=0;            // bit buffer\n    var k=0;            // bits in bit buffer\n    var p=0;            // input data pointer\n    var n;              // bytes available there\n    var q;              // output window write pointer\n    var m;              // bytes to end of window or read pointer\n    var f;              // pointer to copy strings from\n\n    // copy input/output information to locals (UPDATE macro restores)\n    p=z.next_in_index;n=z.avail_in;b=s.bitb;k=s.bitk;\n    q=s.write;m=q<s.read?s.read-q-1:s.end-q;\n\n    // process input and output based on current state\n    while (true){\n      switch (this.mode){\n\t// waiting for \"i:\"=input, \"o:\"=output, \"x:\"=nothing\n      case IC_START:         // x: set up for LEN\n\tif (m >= 258 && n >= 10){\n\n\t  s.bitb=b;s.bitk=k;\n\t  z.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;\n\t  s.write=q;\n\t  r = this.inflate_fast(this.lbits, this.dbits, \n\t\t\t   this.ltree, this.ltree_index, \n\t\t\t   this.dtree, this.dtree_index,\n\t\t\t   s, z);\n\n\t  p=z.next_in_index;n=z.avail_in;b=s.bitb;k=s.bitk;\n\t  q=s.write;m=q<s.read?s.read-q-1:s.end-q;\n\n\t  if (r != Z_OK){\n\t    this.mode = r == Z_STREAM_END ? IC_WASH : IC_BADCODE;\n\t    break;\n\t  }\n\t}\n\tthis.need = this.lbits;\n\tthis.tree = this.ltree;\n\tthis.tree_index=this.ltree_index;\n\n\tthis.mode = IC_LEN;\n      case IC_LEN:           // i: get length/literal/eob next\n\tj = this.need;\n\n\twhile(k<(j)){\n\t  if(n!=0)r=Z_OK;\n\t  else{\n\n\t    s.bitb=b;s.bitk=k;\n\t    z.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;\n\t    s.write=q;\n\t    return s.inflate_flush(z,r);\n\t  }\n\t  n--;\n\t  b|=(z.next_in[p++]&0xff)<<k;\n\t  k+=8;\n\t}\n\n\ttindex=(this.tree_index+(b&inflate_mask[j]))*3;\n\n\tb>>>=(this.tree[tindex+1]);\n\tk-=(this.tree[tindex+1]);\n\n\te=this.tree[tindex];\n\n\tif(e == 0){               // literal\n\t  this.lit = this.tree[tindex+2];\n\t  this.mode = IC_LIT;\n\t  break;\n\t}\n\tif((e & 16)!=0 ){          // length\n\t  this.get = e & 15;\n\t  this.len = this.tree[tindex+2];\n\t  this.mode = IC_LENEXT;\n\t  break;\n\t}\n\tif ((e & 64) == 0){        // next table\n\t  this.need = e;\n\t  this.tree_index = tindex/3 + this.tree[tindex+2];\n\t  break;\n\t}\n\tif ((e & 32)!=0){               // end of block\n\t  this.mode = IC_WASH;\n\t  break;\n\t}\n\tthis.mode = IC_BADCODE;        // invalid code\n\tz.msg = \"invalid literal/length code\";\n\tr = Z_DATA_ERROR;\n\n\ts.bitb=b;s.bitk=k;\n\tz.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;\n\ts.write=q;\n\treturn s.inflate_flush(z,r);\n\n      case IC_LENEXT:        // i: getting length extra (have base)\n\tj = this.get;\n\n\twhile(k<(j)){\n\t  if(n!=0)r=Z_OK;\n\t  else{\n\n\t    s.bitb=b;s.bitk=k;\n\t    z.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;\n\t    s.write=q;\n\t    return s.inflate_flush(z,r);\n\t  }\n\t  n--; b|=(z.next_in[p++]&0xff)<<k;\n\t  k+=8;\n\t}\n\n\tthis.len += (b & inflate_mask[j]);\n\n\tb>>=j;\n\tk-=j;\n\n\tthis.need = this.dbits;\n\tthis.tree = this.dtree;\n\tthis.tree_index = this.dtree_index;\n\tthis.mode = IC_DIST;\n      case IC_DIST:          // i: get distance next\n\tj = this.need;\n\n\twhile(k<(j)){\n\t  if(n!=0)r=Z_OK;\n\t  else{\n\n\t    s.bitb=b;s.bitk=k;\n\t    z.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;\n\t    s.write=q;\n\t    return s.inflate_flush(z,r);\n\t  }\n\t  n--; b|=(z.next_in[p++]&0xff)<<k;\n\t  k+=8;\n\t}\n\n\ttindex=(this.tree_index+(b & inflate_mask[j]))*3;\n\n\tb>>=this.tree[tindex+1];\n\tk-=this.tree[tindex+1];\n\n\te = (this.tree[tindex]);\n\tif((e & 16)!=0){               // distance\n\t  this.get = e & 15;\n\t  this.dist = this.tree[tindex+2];\n\t  this.mode = IC_DISTEXT;\n\t  break;\n\t}\n\tif ((e & 64) == 0){        // next table\n\t  this.need = e;\n\t  this.tree_index = tindex/3 + this.tree[tindex+2];\n\t  break;\n\t}\n\tthis.mode = IC_BADCODE;        // invalid code\n\tz.msg = \"invalid distance code\";\n\tr = Z_DATA_ERROR;\n\n\ts.bitb=b;s.bitk=k;\n\tz.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;\n\ts.write=q;\n\treturn s.inflate_flush(z,r);\n\n      case IC_DISTEXT:       // i: getting distance extra\n\tj = this.get;\n\n\twhile(k<(j)){\n\t  if(n!=0)r=Z_OK;\n\t  else{\n\n\t    s.bitb=b;s.bitk=k;\n\t    z.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;\n\t    s.write=q;\n\t    return s.inflate_flush(z,r);\n\t  }\n\t  n--; b|=(z.next_in[p++]&0xff)<<k;\n\t  k+=8;\n\t}\n\n\tthis.dist += (b & inflate_mask[j]);\n\n\tb>>=j;\n\tk-=j;\n\n\tthis.mode = IC_COPY;\n      case IC_COPY:          // o: copying bytes in window, waiting for space\n        f = q - this.dist;\n        while(f < 0){     // modulo window size-\"while\" instead\n          f += s.end;     // of \"if\" handles invalid distances\n\t}\n\twhile (this.len!=0){\n\n\t  if(m==0){\n\t    if(q==s.end&&s.read!=0){q=0;m=q<s.read?s.read-q-1:s.end-q;}\n\t    if(m==0){\n\t      s.write=q; r=s.inflate_flush(z,r);\n\t      q=s.write;m=q<s.read?s.read-q-1:s.end-q;\n\n\t      if(q==s.end&&s.read!=0){q=0;m=q<s.read?s.read-q-1:s.end-q;}\n\n\t      if(m==0){\n\t\ts.bitb=b;s.bitk=k;\n\t\tz.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;\n\t\ts.write=q;\n\t\treturn s.inflate_flush(z,r);\n\t      }  \n\t    }\n\t  }\n\n\t  s.window[q++]=s.window[f++]; m--;\n\n\t  if (f == s.end)\n            f = 0;\n\t  this.len--;\n\t}\n\tthis.mode = IC_START;\n\tbreak;\n      case IC_LIT:           // o: got literal, waiting for output space\n\tif(m==0){\n\t  if(q==s.end&&s.read!=0){q=0;m=q<s.read?s.read-q-1:s.end-q;}\n\t  if(m==0){\n\t    s.write=q; r=s.inflate_flush(z,r);\n\t    q=s.write;m=q<s.read?s.read-q-1:s.end-q;\n\n\t    if(q==s.end&&s.read!=0){q=0;m=q<s.read?s.read-q-1:s.end-q;}\n\t    if(m==0){\n\t      s.bitb=b;s.bitk=k;\n\t      z.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;\n\t      s.write=q;\n\t      return s.inflate_flush(z,r);\n\t    }\n\t  }\n\t}\n\tr=Z_OK;\n\n\ts.window[q++]=this.lit; m--;\n\n\tthis.mode = IC_START;\n\tbreak;\n      case IC_WASH:           // o: got eob, possibly more output\n\tif (k > 7){        // return unused byte, if any\n\t  k -= 8;\n\t  n++;\n\t  p--;             // can always return one\n\t}\n\n\ts.write=q; r=s.inflate_flush(z,r);\n\tq=s.write;m=q<s.read?s.read-q-1:s.end-q;\n\n\tif (s.read != s.write){\n\t  s.bitb=b;s.bitk=k;\n\t  z.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;\n\t  s.write=q;\n\t  return s.inflate_flush(z,r);\n\t}\n\tthis.mode = IC_END;\n      case IC_END:\n\tr = Z_STREAM_END;\n\ts.bitb=b;s.bitk=k;\n\tz.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;\n\ts.write=q;\n\treturn s.inflate_flush(z,r);\n\n      case IC_BADCODE:       // x: got error\n\n\tr = Z_DATA_ERROR;\n\n\ts.bitb=b;s.bitk=k;\n\tz.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;\n\ts.write=q;\n\treturn s.inflate_flush(z,r);\n\n      default:\n\tr = Z_STREAM_ERROR;\n\n\ts.bitb=b;s.bitk=k;\n\tz.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;\n\ts.write=q;\n\treturn s.inflate_flush(z,r);\n      }\n    }\n  }\n\nInfCodes.prototype.free = function(z){\n    //  ZFREE(z, c);\n}\n\n  // Called with number of bytes left to write in window at least 258\n  // (the maximum string length) and number of input bytes available\n  // at least ten.  The ten bytes are six bytes for the longest length/\n  // distance pair plus four bytes for overloading the bit buffer.\n\nInfCodes.prototype.inflate_fast = function(bl, bd, tl, tl_index, td, td_index, s, z) {\n    var t;                // temporary pointer\n    var   tp;             // temporary pointer (int[])\n    var tp_index;         // temporary pointer\n    var e;                // extra bits or operation\n    var b;                // bit buffer\n    var k;                // bits in bit buffer\n    var p;                // input data pointer\n    var n;                // bytes available there\n    var q;                // output window write pointer\n    var m;                // bytes to end of window or read pointer\n    var ml;               // mask for literal/length tree\n    var md;               // mask for distance tree\n    var c;                // bytes to copy\n    var d;                // distance back to copy from\n    var r;                // copy source pointer\n\n    var tp_index_t_3;     // (tp_index+t)*3\n\n    // load input, output, bit values\n    p=z.next_in_index;n=z.avail_in;b=s.bitb;k=s.bitk;\n    q=s.write;m=q<s.read?s.read-q-1:s.end-q;\n\n    // initialize masks\n    ml = inflate_mask[bl];\n    md = inflate_mask[bd];\n\n    // do until not enough input or output space for fast loop\n    do {                          // assume called with m >= 258 && n >= 10\n      // get literal/length code\n      while(k<(20)){              // max bits for literal/length code\n\tn--;\n\tb|=(z.next_in[p++]&0xff)<<k;k+=8;\n      }\n\n      t= b&ml;\n      tp=tl; \n      tp_index=tl_index;\n      tp_index_t_3=(tp_index+t)*3;\n      if ((e = tp[tp_index_t_3]) == 0){\n\tb>>=(tp[tp_index_t_3+1]); k-=(tp[tp_index_t_3+1]);\n\n\ts.window[q++] = tp[tp_index_t_3+2];\n\tm--;\n\tcontinue;\n      }\n      do {\n\n\tb>>=(tp[tp_index_t_3+1]); k-=(tp[tp_index_t_3+1]);\n\n\tif((e&16)!=0){\n\t  e &= 15;\n\t  c = tp[tp_index_t_3+2] + (b & inflate_mask[e]);\n\n\t  b>>=e; k-=e;\n\n\t  // decode distance base of block to copy\n\t  while(k<(15)){           // max bits for distance code\n\t    n--;\n\t    b|=(z.next_in[p++]&0xff)<<k;k+=8;\n\t  }\n\n\t  t= b&md;\n\t  tp=td;\n\t  tp_index=td_index;\n          tp_index_t_3=(tp_index+t)*3;\n\t  e = tp[tp_index_t_3];\n\n\t  do {\n\n\t    b>>=(tp[tp_index_t_3+1]); k-=(tp[tp_index_t_3+1]);\n\n\t    if((e&16)!=0){\n\t      // get extra bits to add to distance base\n\t      e &= 15;\n\t      while(k<(e)){         // get extra bits (up to 13)\n\t\tn--;\n\t\tb|=(z.next_in[p++]&0xff)<<k;k+=8;\n\t      }\n\n\t      d = tp[tp_index_t_3+2] + (b&inflate_mask[e]);\n\n\t      b>>=(e); k-=(e);\n\n\t      // do the copy\n\t      m -= c;\n\t      if (q >= d){                // offset before dest\n\t\t//  just copy\n\t\tr=q-d;\n\t\tif(q-r>0 && 2>(q-r)){           \n\t\t  s.window[q++]=s.window[r++]; // minimum count is three,\n\t\t  s.window[q++]=s.window[r++]; // so unroll loop a little\n\t\t  c-=2;\n\t\t}\n\t\telse{\n\t\t  s.window[q++]=s.window[r++]; // minimum count is three,\n\t\t  s.window[q++]=s.window[r++]; // so unroll loop a little\n\t\t  c-=2;\n\t\t}\n\t      }\n\t      else{                  // else offset after destination\n                r=q-d;\n                do{\n                  r+=s.end;          // force pointer in window\n                }while(r<0);         // covers invalid distances\n\t\te=s.end-r;\n\t\tif(c>e){             // if source crosses,\n\t\t  c-=e;              // wrapped copy\n\t\t  if(q-r>0 && e>(q-r)){           \n\t\t    do{s.window[q++] = s.window[r++];}\n\t\t    while(--e!=0);\n\t\t  }\n\t\t  else{\n\t\t    arrayCopy(s.window, r, s.window, q, e);\n\t\t    q+=e; r+=e; e=0;\n\t\t  }\n\t\t  r = 0;                  // copy rest from start of window\n\t\t}\n\n\t      }\n\n\t      // copy all or what's left\n              do{s.window[q++] = s.window[r++];}\n\t\twhile(--c!=0);\n\t      break;\n\t    }\n\t    else if((e&64)==0){\n\t      t+=tp[tp_index_t_3+2];\n\t      t+=(b&inflate_mask[e]);\n\t      tp_index_t_3=(tp_index+t)*3;\n\t      e=tp[tp_index_t_3];\n\t    }\n\t    else{\n\t      z.msg = \"invalid distance code\";\n\n\t      c=z.avail_in-n;c=(k>>3)<c?k>>3:c;n+=c;p-=c;k-=c<<3;\n\n\t      s.bitb=b;s.bitk=k;\n\t      z.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;\n\t      s.write=q;\n\n\t      return Z_DATA_ERROR;\n\t    }\n\t  }\n\t  while(true);\n\t  break;\n\t}\n\n\tif((e&64)==0){\n\t  t+=tp[tp_index_t_3+2];\n\t  t+=(b&inflate_mask[e]);\n\t  tp_index_t_3=(tp_index+t)*3;\n\t  if((e=tp[tp_index_t_3])==0){\n\n\t    b>>=(tp[tp_index_t_3+1]); k-=(tp[tp_index_t_3+1]);\n\n\t    s.window[q++]=tp[tp_index_t_3+2];\n\t    m--;\n\t    break;\n\t  }\n\t}\n\telse if((e&32)!=0){\n\n\t  c=z.avail_in-n;c=(k>>3)<c?k>>3:c;n+=c;p-=c;k-=c<<3;\n \n\t  s.bitb=b;s.bitk=k;\n\t  z.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;\n\t  s.write=q;\n\n\t  return Z_STREAM_END;\n\t}\n\telse{\n\t  z.msg=\"invalid literal/length code\";\n\n\t  c=z.avail_in-n;c=(k>>3)<c?k>>3:c;n+=c;p-=c;k-=c<<3;\n\n\t  s.bitb=b;s.bitk=k;\n\t  z.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;\n\t  s.write=q;\n\n\t  return Z_DATA_ERROR;\n\t}\n      } \n      while(true);\n    } \n    while(m>=258 && n>= 10);\n\n    // not enough input or output--restore pointers and return\n    c=z.avail_in-n;c=(k>>3)<c?k>>3:c;n+=c;p-=c;k-=c<<3;\n\n    s.bitb=b;s.bitk=k;\n    z.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;\n    s.write=q;\n\n    return Z_OK;\n}\n\n//\n// InfTree.java\n//\n\nfunction InfTree() {\n}\n\nInfTree.prototype.huft_build = function(b, bindex, n, s, d, e, t, m, hp, hn, v) {\n\n    // Given a list of code lengths and a maximum table size, make a set of\n    // tables to decode that set of codes.  Return Z_OK on success, Z_BUF_ERROR\n    // if the given code set is incomplete (the tables are still built in this\n    // case), Z_DATA_ERROR if the input is invalid (an over-subscribed set of\n    // lengths), or Z_MEM_ERROR if not enough memory.\n\n    var a;                       // counter for codes of length k\n    var f;                       // i repeats in table every f entries\n    var g;                       // maximum code length\n    var h;                       // table level\n    var i;                       // counter, current code\n    var j;                       // counter\n    var k;                       // number of bits in current code\n    var l;                       // bits per table (returned in m)\n    var mask;                    // (1 << w) - 1, to avoid cc -O bug on HP\n    var p;                       // pointer into c[], b[], or v[]\n    var q;                       // points to current table\n    var w;                       // bits before this table == (l * h)\n    var xp;                      // pointer into x\n    var y;                       // number of dummy codes added\n    var z;                       // number of entries in current table\n\n    // Generate counts for each bit length\n\n    p = 0; i = n;\n    do {\n      this.c[b[bindex+p]]++; p++; i--;   // assume all entries <= BMAX\n    }while(i!=0);\n\n    if(this.c[0] == n){                // null input--all zero length codes\n      t[0] = -1;\n      m[0] = 0;\n      return Z_OK;\n    }\n\n    // Find minimum and maximum length, bound *m by those\n    l = m[0];\n    for (j = 1; j <= BMAX; j++)\n      if(this.c[j]!=0) break;\n    k = j;                        // minimum code length\n    if(l < j){\n      l = j;\n    }\n    for (i = BMAX; i!=0; i--){\n      if(this.c[i]!=0) break;\n    }\n    g = i;                        // maximum code length\n    if(l > i){\n      l = i;\n    }\n    m[0] = l;\n\n    // Adjust last length count to fill out codes, if needed\n    for (y = 1 << j; j < i; j++, y <<= 1){\n      if ((y -= this.c[j]) < 0){\n        return Z_DATA_ERROR;\n      }\n    }\n    if ((y -= this.c[i]) < 0){\n      return Z_DATA_ERROR;\n    }\n    this.c[i] += y;\n\n    // Generate starting offsets into the value table for each length\n    this.x[1] = j = 0;\n    p = 1;  xp = 2;\n    while (--i!=0) {                 // note that i == g from above\n      this.x[xp] = (j += this.c[p]);\n      xp++;\n      p++;\n    }\n\n    // Make a table of values in order of bit lengths\n    i = 0; p = 0;\n    do {\n      if ((j = b[bindex+p]) != 0){\n        this.v[this.x[j]++] = i;\n      }\n      p++;\n    }\n    while (++i < n);\n    n = this.x[g];                     // set n to length of v\n\n    // Generate the Huffman codes and for each, make the table entries\n    this.x[0] = i = 0;                 // first Huffman code is zero\n    p = 0;                        // grab values in bit order\n    h = -1;                       // no tables yet--level -1\n    w = -l;                       // bits decoded == (l * h)\n    this.u[0] = 0;                     // just to keep compilers happy\n    q = 0;                        // ditto\n    z = 0;                        // ditto\n\n    // go through the bit lengths (k already is bits in shortest code)\n    for (; k <= g; k++){\n      a = this.c[k];\n      while (a--!=0){\n\t// here i is the Huffman code of length k bits for value *p\n\t// make tables up to required level\n        while (k > w + l){\n          h++;\n          w += l;                 // previous table always l bits\n\t  // compute minimum size table less than or equal to l bits\n          z = g - w;\n          z = (z > l) ? l : z;        // table size upper limit\n          if((f=1<<(j=k-w))>a+1){     // try a k-w bit table\n                                      // too few codes for k-w bit table\n            f -= a + 1;               // deduct codes from patterns left\n            xp = k;\n            if(j < z){\n              while (++j < z){        // try smaller tables up to z bits\n                if((f <<= 1) <= this.c[++xp])\n                  break;              // enough codes to use up j bits\n                f -= this.c[xp];           // else deduct codes from patterns\n              }\n\t    }\n          }\n          z = 1 << j;                 // table entries for j-bit table\n\n\t  // allocate new table\n          if (this.hn[0] + z > MANY){       // (note: doesn't matter for fixed)\n            return Z_DATA_ERROR;       // overflow of MANY\n          }\n          this.u[h] = q = /*hp+*/ this.hn[0];   // DEBUG\n          this.hn[0] += z;\n \n\t  // connect to last table, if there is one\n\t  if(h!=0){\n            this.x[h]=i;           // save pattern for backing up\n            this.r[0]=j;     // bits in this table\n            this.r[1]=l;     // bits to dump before this table\n            j=i>>>(w - l);\n            this.r[2] = (q - this.u[h-1] - j);               // offset to this table\n            arrayCopy(this.r, 0, hp, (this.u[h-1]+j)*3, 3); // connect to last table\n          }\n          else{\n            t[0] = q;               // first table is returned result\n\t  }\n        }\n\n\t// set up table entry in r\n        this.r[1] = (k - w);\n        if (p >= n){\n          this.r[0] = 128 + 64;      // out of values--invalid code\n\t}\n        else if (v[p] < s){\n          this.r[0] = (this.v[p] < 256 ? 0 : 32 + 64);  // 256 is end-of-block\n          this.r[2] = this.v[p++];          // simple code is just the value\n        }\n        else{\n          this.r[0]=(e[this.v[p]-s]+16+64); // non-simple--look up in lists\n          this.r[2]=d[this.v[p++] - s];\n        }\n\n        // fill code-like entries with r\n        f=1<<(k-w);\n        for (j=i>>>w;j<z;j+=f){\n          arrayCopy(this.r, 0, hp, (q+j)*3, 3);\n\t}\n\n\t// backwards increment the k-bit code i\n        for (j = 1 << (k - 1); (i & j)!=0; j >>>= 1){\n          i ^= j;\n\t}\n        i ^= j;\n\n\t// backup over finished tables\n        mask = (1 << w) - 1;      // needed on HP, cc -O bug\n        while ((i & mask) != this.x[h]){\n          h--;                    // don't need to update q\n          w -= l;\n          mask = (1 << w) - 1;\n        }\n      }\n    }\n    // Return Z_BUF_ERROR if we were given an incomplete table\n    return y != 0 && g != 1 ? Z_BUF_ERROR : Z_OK;\n}\n\nInfTree.prototype.inflate_trees_bits = function(c, bb, tb, hp, z) {\n    var result;\n    this.initWorkArea(19);\n    this.hn[0]=0;\n    result = this.huft_build(c, 0, 19, 19, null, null, tb, bb, hp, this.hn, this.v);\n\n    if(result == Z_DATA_ERROR){\n      z.msg = \"oversubscribed dynamic bit lengths tree\";\n    }\n    else if(result == Z_BUF_ERROR || bb[0] == 0){\n      z.msg = \"incomplete dynamic bit lengths tree\";\n      result = Z_DATA_ERROR;\n    }\n    return result;\n}\n\nInfTree.prototype.inflate_trees_dynamic = function(nl, nd, c, bl, bd, tl, td, hp, z) {\n    var result;\n\n    // build literal/length tree\n    this.initWorkArea(288);\n    this.hn[0]=0;\n    result = this.huft_build(c, 0, nl, 257, cplens, cplext, tl, bl, hp, this.hn, this.v);\n    if (result != Z_OK || bl[0] == 0){\n      if(result == Z_DATA_ERROR){\n        z.msg = \"oversubscribed literal/length tree\";\n      }\n      else if (result != Z_MEM_ERROR){\n        z.msg = \"incomplete literal/length tree\";\n        result = Z_DATA_ERROR;\n      }\n      return result;\n    }\n\n    // build distance tree\n    this.initWorkArea(288);\n    result = this.huft_build(c, nl, nd, 0, cpdist, cpdext, td, bd, hp, this.hn, this.v);\n\n    if (result != Z_OK || (bd[0] == 0 && nl > 257)){\n      if (result == Z_DATA_ERROR){\n        z.msg = \"oversubscribed distance tree\";\n      }\n      else if (result == Z_BUF_ERROR) {\n        z.msg = \"incomplete distance tree\";\n        result = Z_DATA_ERROR;\n      }\n      else if (result != Z_MEM_ERROR){\n        z.msg = \"empty distance tree with lengths\";\n        result = Z_DATA_ERROR;\n      }\n      return result;\n    }\n\n    return Z_OK;\n}\n/*\n  static int inflate_trees_fixed(int[] bl,  //literal desired/actual bit depth\n                                 int[] bd,  //distance desired/actual bit depth\n                                 int[][] tl,//literal/length tree result\n                                 int[][] td,//distance tree result \n                                 ZStream z  //for memory allocation\n\t\t\t\t ){\n\n*/\n\nfunction inflate_trees_fixed(bl, bd, tl, td, z) {\n    bl[0]=fixed_bl;\n    bd[0]=fixed_bd;\n    tl[0]=fixed_tl;\n    td[0]=fixed_td;\n    return Z_OK;\n}\n\nInfTree.prototype.initWorkArea = function(vsize){\n    if(this.hn==null){\n        this.hn=new Int32Array(1);\n        this.v=new Int32Array(vsize);\n        this.c=new Int32Array(BMAX+1);\n        this.r=new Int32Array(3);\n        this.u=new Int32Array(BMAX);\n        this.x=new Int32Array(BMAX+1);\n    }\n    if(this.v.length<vsize){ \n        this.v=new Int32Array(vsize); \n    }\n    for(var i=0; i<vsize; i++){this.v[i]=0;}\n    for(var i=0; i<BMAX+1; i++){this.c[i]=0;}\n    for(var i=0; i<3; i++){this.r[i]=0;}\n//  for(int i=0; i<BMAX; i++){u[i]=0;}\n    arrayCopy(this.c, 0, this.u, 0, BMAX);\n//  for(int i=0; i<BMAX+1; i++){x[i]=0;}\n    arrayCopy(this.c, 0, this.x, 0, BMAX+1);\n}\n\nvar testArray = new Uint8Array(1);\nvar hasSubarray = (typeof testArray.subarray === 'function');\nvar hasSlice = false; /* (typeof testArray.slice === 'function'); */ // Chrome slice performance is so dire that we're currently not using it...\n\nfunction arrayCopy(src, srcOffset, dest, destOffset, count) {\n    if (count == 0) {\n        return;\n    } \n    if (!src) {\n        throw \"Undef src\";\n    } else if (!dest) {\n        throw \"Undef dest\";\n    }\n\n    if (srcOffset == 0 && count == src.length) {\n        arrayCopy_fast(src, dest, destOffset);\n    } else if (hasSubarray) {\n        arrayCopy_fast(src.subarray(srcOffset, srcOffset + count), dest, destOffset); \n    } else if (src.BYTES_PER_ELEMENT == 1 && count > 100) {\n        arrayCopy_fast(new Uint8Array(src.buffer, src.byteOffset + srcOffset, count), dest, destOffset);\n    } else { \n        arrayCopy_slow(src, srcOffset, dest, destOffset, count);\n    }\n\n}\n\nfunction arrayCopy_slow(src, srcOffset, dest, destOffset, count) {\n\n    // dlog('_slow call: srcOffset=' + srcOffset + '; destOffset=' + destOffset + '; count=' + count);\n\n     for (var i = 0; i < count; ++i) {\n        dest[destOffset + i] = src[srcOffset + i];\n    }\n}\n\nfunction arrayCopy_fast(src, dest, destOffset) {\n    dest.set(src, destOffset);\n}\n\n\n  // largest prime smaller than 65536\nvar ADLER_BASE=65521; \n  // NMAX is the largest n such that 255n(n+1)/2 + (n+1)(BASE-1) <= 2^32-1\nvar ADLER_NMAX=5552;\n\nfunction adler32(adler, /* byte[] */ buf,  index, len){\n    if(buf == null){ return 1; }\n\n    var s1=adler&0xffff;\n    var s2=(adler>>16)&0xffff;\n    var k;\n\n    while(len > 0) {\n      k=len<ADLER_NMAX?len:ADLER_NMAX;\n      len-=k;\n      while(k>=16){\n        s1+=buf[index++]&0xff; s2+=s1;\n        s1+=buf[index++]&0xff; s2+=s1;\n        s1+=buf[index++]&0xff; s2+=s1;\n        s1+=buf[index++]&0xff; s2+=s1;\n        s1+=buf[index++]&0xff; s2+=s1;\n        s1+=buf[index++]&0xff; s2+=s1;\n        s1+=buf[index++]&0xff; s2+=s1;\n        s1+=buf[index++]&0xff; s2+=s1;\n        s1+=buf[index++]&0xff; s2+=s1;\n        s1+=buf[index++]&0xff; s2+=s1;\n        s1+=buf[index++]&0xff; s2+=s1;\n        s1+=buf[index++]&0xff; s2+=s1;\n        s1+=buf[index++]&0xff; s2+=s1;\n        s1+=buf[index++]&0xff; s2+=s1;\n        s1+=buf[index++]&0xff; s2+=s1;\n        s1+=buf[index++]&0xff; s2+=s1;\n        k-=16;\n      }\n      if(k!=0){\n        do{\n          s1+=buf[index++]&0xff; s2+=s1;\n        }\n        while(--k!=0);\n      }\n      s1%=ADLER_BASE;\n      s2%=ADLER_BASE;\n    }\n    return (s2<<16)|s1;\n}\n\n\n\nfunction jszlib_inflate_buffer(buffer, start, length, afterUncOffset) {\n    if (!start) {\n        buffer = new Uint8Array(buffer);\n    } else if (!length) {\n        buffer = new Uint8Array(buffer, start, buffer.byteLength - start);\n    } else {\n        buffer = new Uint8Array(buffer, start, length);\n    }\n\n    var z = new ZStream();\n    z.inflateInit(DEF_WBITS, true);\n    z.next_in = buffer;\n    z.next_in_index = 0;\n    z.avail_in = buffer.length;\n\n    var oBlockList = [];\n    var totalSize = 0;\n    while (true) {\n        var obuf = new Uint8Array(32000);\n        z.next_out = obuf;\n        z.next_out_index = 0;\n        z.avail_out = obuf.length;\n        var status = z.inflate(Z_NO_FLUSH);\n        if (status != Z_OK && status != Z_STREAM_END && status != Z_BUF_ERROR) {\n            throw z.msg;\n        }\n        if (z.avail_out != 0) {\n            var newob = new Uint8Array(obuf.length - z.avail_out);\n            arrayCopy(obuf, 0, newob, 0, (obuf.length - z.avail_out));\n            obuf = newob;\n        }\n        oBlockList.push(obuf);\n        totalSize += obuf.length;\n        if (status == Z_STREAM_END || status == Z_BUF_ERROR) {\n            break;\n        }\n    }\n\n    if (afterUncOffset) {\n        afterUncOffset[0] = (start || 0) + z.next_in_index;\n    }\n\n    if (oBlockList.length == 1) {\n        return oBlockList[0].buffer;\n    } else {\n        var out = new Uint8Array(totalSize);\n        var cursor = 0;\n        for (var i = 0; i < oBlockList.length; ++i) {\n            var b = oBlockList[i];\n            arrayCopy(b, 0, out, cursor, b.length);\n            cursor += b.length;\n        }\n        return out.buffer;\n    }\n}\n\nif (typeof(module) !== 'undefined') {\n  module.exports = {\n    inflateBuffer: jszlib_inflate_buffer,\n    arrayCopy: arrayCopy\n  };\n}\n","// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n"],"sourceRoot":"/source/"}